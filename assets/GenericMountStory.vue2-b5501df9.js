var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { S as SvelteComponentDev, Q as init, R as safe_not_equal, U as dispatch_dev, V as assign, W as compute_rest_props, X as validate_slots, Y as getContext, Z as exclude_internal_props, $ as symbol, a0 as d3area, a1 as svg_element, a2 as claim_svg_element, a3 as children, a4 as detach_dev, a5 as set_svg_attributes, a6 as toggle_class, a7 as add_location, a8 as attr_dev, a9 as set_style, aa as insert_hydration_dev, ab as append_hydration_dev, ac as action_destroyer, ad as get_spread_update, ae as is_function, af as noop, ag as subscribe, ah as create_component, ai as claim_component, aj as null_to_empty, ak as mount_component, al as get_spread_object, am as transition_in, an as transition_out, ao as destroy_component, ap as create_slot, aq as update_slot_base, ar as get_all_dirty_from_scope, as as get_slot_changes, at as validate_each_argument, au as validate_store, av as component_subscribe, aw as axis, ax as empty, ay as group_outros, az as check_outros, aA as destroy_each, aB as space, aC as claim_space, aD as text, aE as claim_text, aF as set_data_dev, aG as group, aH as d3line, aI as run_all, aJ as LayerCake, aK as Svg, aL as element, aM as claim_element, aN as binding_callbacks, aO as bind, aP as add_flush_callback, aQ as fuzzysort, aR as chroma, aS as maxIndex, aT as compute_slots, aU as band, aV as set_attributes, aW as Html, aX as listen_dev, aY as bubble, aZ as logEvent, a_ as add_render_callback, a$ as add_resize_listener, b0 as get_binding_group_value, b1 as prop_dev, b2 as tick, b3 as prevent_default, b4 as set_input_value, b5 as lodash_debounce, b6 as csvParse, b7 as select_options, b8 as select_option, b9 as select_value, ba as onMount, bb as globals, _ as __vitePreload, bc as markRaw, E as reactive, d as defineComponent, r as ref, bd as watchEffect, o as openBlock, q as createBlock, be as mergeProps, bf as resolveDynamicComponent, h as createCommentVNode } from "./vendor-4822719a.js";
import { c as clientSupportPlugins } from "./__resolved__virtual__histoire-support-plugins-client-5e433a7f.js";
function get(f, data, index = 0) {
  const coords = f(data);
  if (typeof coords === "number")
    return coords;
  return coords[index];
}
function isStacked(data) {
  let isStacked2 = false;
  if (data.length > 0) {
    const d = data[0];
    isStacked2 = d.key != void 0 && d.index != void 0 && Array.isArray(d);
  }
  return isStacked2;
}
const AreaY_svelte_svelte_type_style_lang = "";
const file$_ = "src/lib/components/layercake/AreaY.svelte";
function create_fragment$13(ctx) {
  let g;
  let path;
  let symbol_action;
  let mounted;
  let dispose;
  let path_levels = [ctx[7], { d: ctx[0] }];
  let path_data = {};
  for (let i = 0; i < path_levels.length; i += 1) {
    path_data = assign(path_data, path_levels[i]);
  }
  const block = {
    c: function create() {
      g = svg_element("g");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { class: true });
      var g_nodes = children(g);
      path = claim_svg_element(g_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(path, path_data);
      toggle_class(path, "area", true);
      toggle_class(path, "s-g6XqzDxDD4f2", true);
      add_location(path, file$_, 48, 2, 1247);
      attr_dev(g, "class", "area-y0 s-g6XqzDxDD4f2");
      set_style(g, "--_color", ctx[7].stroke || ctx[1] || "");
      set_style(g, "--_outline", ctx[2] || "");
      set_style(g, "--_outline-width", ctx[6] || "");
      set_style(g, "--_opacity", ctx[7].opacity || "");
      add_location(g, file$_, 40, 0, 1017);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      append_hydration_dev(g, path);
      if (!mounted) {
        dispose = action_destroyer(symbol_action = symbol.call(null, g, ctx[5]));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(path, path_data = get_spread_update(path_levels, [
        dirty & 128 && ctx2[7],
        dirty & 1 && { d: ctx2[0] }
      ]));
      toggle_class(path, "area", true);
      toggle_class(path, "s-g6XqzDxDD4f2", true);
      if (symbol_action && is_function(symbol_action.update) && dirty & 32)
        symbol_action.update.call(null, ctx2[5]);
      if (dirty & 130) {
        set_style(g, "--_color", ctx2[7].stroke || ctx2[1] || "");
      }
      if (dirty & 4) {
        set_style(g, "--_outline", ctx2[2] || "");
      }
      if (dirty & 64) {
        set_style(g, "--_outline-width", ctx2[6] || "");
      }
      if (dirty & 128) {
        set_style(g, "--_opacity", ctx2[7].opacity || "");
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$13($$self, $$props, $$invalidate) {
  let outlineWidth;
  const omit_props_names = ["color", "outline", "d", "data", "xIndex", "y0Index", "y1Index", "label", "parent"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $yGet, $$unsubscribe_yGet = noop, $$subscribe_yGet = () => ($$unsubscribe_yGet(), $$unsubscribe_yGet = subscribe(yGet, ($$value) => $$invalidate(15, $yGet = $$value)), yGet);
  let $xGet, $$unsubscribe_xGet = noop, $$subscribe_xGet = () => ($$unsubscribe_xGet(), $$unsubscribe_xGet = subscribe(xGet, ($$value) => $$invalidate(16, $xGet = $$value)), xGet);
  $$self.$$.on_destroy.push(() => $$unsubscribe_yGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xGet());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AreaY", slots, []);
  let { color = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { d = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { xIndex = 0 } = $$props;
  let { y0Index = 0 } = $$props;
  let { y1Index = 1 } = $$props;
  let { label = void 0 } = $$props;
  let { parent = void 0 } = $$props;
  const ctx = getContext("LayerCake");
  let xGet, yGet;
  let area;
  let friendly;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("outline" in $$new_props)
      $$invalidate(2, outline = $$new_props.outline);
    if ("d" in $$new_props)
      $$invalidate(0, d = $$new_props.d);
    if ("data" in $$new_props)
      $$invalidate(8, data = $$new_props.data);
    if ("xIndex" in $$new_props)
      $$invalidate(9, xIndex = $$new_props.xIndex);
    if ("y0Index" in $$new_props)
      $$invalidate(10, y0Index = $$new_props.y0Index);
    if ("y1Index" in $$new_props)
      $$invalidate(11, y1Index = $$new_props.y1Index);
    if ("label" in $$new_props)
      $$invalidate(12, label = $$new_props.label);
    if ("parent" in $$new_props)
      $$invalidate(13, parent = $$new_props.parent);
  };
  $$self.$capture_state = () => ({
    getContext,
    symbol,
    d3area,
    get,
    color,
    outline,
    d,
    data,
    xIndex,
    y0Index,
    y1Index,
    label,
    parent,
    ctx,
    xGet,
    yGet,
    area,
    friendly,
    outlineWidth,
    $yGet,
    $xGet
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(1, color = $$new_props.color);
    if ("outline" in $$props)
      $$invalidate(2, outline = $$new_props.outline);
    if ("d" in $$props)
      $$invalidate(0, d = $$new_props.d);
    if ("data" in $$props)
      $$invalidate(8, data = $$new_props.data);
    if ("xIndex" in $$props)
      $$invalidate(9, xIndex = $$new_props.xIndex);
    if ("y0Index" in $$props)
      $$invalidate(10, y0Index = $$new_props.y0Index);
    if ("y1Index" in $$props)
      $$invalidate(11, y1Index = $$new_props.y1Index);
    if ("label" in $$props)
      $$invalidate(12, label = $$new_props.label);
    if ("parent" in $$props)
      $$invalidate(13, parent = $$new_props.parent);
    if ("xGet" in $$props)
      $$subscribe_xGet($$invalidate(3, xGet = $$new_props.xGet));
    if ("yGet" in $$props)
      $$subscribe_yGet($$invalidate(4, yGet = $$new_props.yGet));
    if ("area" in $$props)
      $$invalidate(14, area = $$new_props.area);
    if ("friendly" in $$props)
      $$invalidate(5, friendly = $$new_props.friendly);
    if ("outlineWidth" in $$props)
      $$invalidate(6, outlineWidth = $$new_props.outlineWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(6, outlineWidth = $$restProps["outline-width"]);
    if ($$self.$$.dirty & 118528) {
      if (data != void 0 && ctx != void 0) {
        $$subscribe_xGet($$invalidate(3, xGet = ctx.xGet));
        $$subscribe_yGet($$invalidate(4, yGet = ctx.yGet));
        $$invalidate(14, area = d3area().x((d2) => get($xGet, d2, xIndex)).y0((d2) => get($yGet, d2, y0Index)).y1((d2) => get($yGet, d2, y1Index)));
        $$invalidate(0, d = area(data));
      }
    }
    if (label != void 0) {
      $$invalidate(5, friendly = {
        id: $$restProps.id,
        type: "area",
        label,
        parentId: parent
      });
    }
  };
  return [
    d,
    color,
    outline,
    xGet,
    yGet,
    friendly,
    outlineWidth,
    $$restProps,
    data,
    xIndex,
    y0Index,
    y1Index,
    label,
    parent,
    area,
    $yGet,
    $xGet
  ];
}
class AreaY extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$13, create_fragment$13, safe_not_equal, {
      color: 1,
      outline: 2,
      d: 0,
      data: 8,
      xIndex: 9,
      y0Index: 10,
      y1Index: 11,
      label: 12,
      parent: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AreaY",
      options,
      id: create_fragment$13.name
    });
  }
  get color() {
    throw new Error("<AreaY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<AreaY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<AreaY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<AreaY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get d() {
    throw new Error("<AreaY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set d(value) {
    throw new Error("<AreaY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<AreaY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<AreaY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xIndex() {
    throw new Error("<AreaY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xIndex(value) {
    throw new Error("<AreaY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y0Index() {
    throw new Error("<AreaY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y0Index(value) {
    throw new Error("<AreaY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y1Index() {
    throw new Error("<AreaY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y1Index(value) {
    throw new Error("<AreaY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<AreaY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<AreaY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<AreaY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<AreaY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Line_svelte_svelte_type_style_lang = "";
const file$Z = "src/lib/components/layercake/Line.svelte";
function create_if_block$o(ctx) {
  let line;
  let line_levels = [
    ctx[11],
    { x1: ctx[9] },
    { y1: ctx[8] },
    { x2: ctx[7] },
    { y2: ctx[6] }
  ];
  let line_data = {};
  for (let i = 0; i < line_levels.length; i += 1) {
    line_data = assign(line_data, line_levels[i]);
  }
  const block = {
    c: function create() {
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(line, line_data);
      toggle_class(line, "outline", true);
      toggle_class(line, "s-p8F5NyaCufjW", true);
      add_location(line, file$Z, 50, 4, 1349);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(line, line_data = get_spread_update(line_levels, [
        dirty & 2048 && ctx2[11],
        dirty & 512 && { x1: ctx2[9] },
        dirty & 256 && { y1: ctx2[8] },
        dirty & 128 && { x2: ctx2[7] },
        dirty & 64 && { y2: ctx2[6] }
      ]));
      toggle_class(line, "outline", true);
      toggle_class(line, "s-p8F5NyaCufjW", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$o.name,
    type: "if",
    source: "(50:2) {#if outline !== 'none'}",
    ctx
  });
  return block;
}
function create_fragment$12(ctx) {
  let g;
  let line;
  let symbol_action;
  let mounted;
  let dispose;
  let if_block = ctx[2] !== "none" && create_if_block$o(ctx);
  let line_levels = [
    ctx[11],
    { x1: ctx[9] },
    { y1: ctx[8] },
    { x2: ctx[7] },
    { y2: ctx[6] }
  ];
  let line_data = {};
  for (let i = 0; i < line_levels.length; i += 1) {
    line_data = assign(line_data, line_levels[i]);
  }
  const block = {
    c: function create() {
      g = svg_element("g");
      if (if_block)
        if_block.c();
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { class: true });
      var g_nodes = children(g);
      if (if_block)
        if_block.l(g_nodes);
      line = claim_svg_element(g_nodes, "line", { x1: true, y1: true, x2: true, y2: true });
      children(line).forEach(detach_dev);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(line, line_data);
      toggle_class(line, "s-p8F5NyaCufjW", true);
      add_location(line, file$Z, 52, 2, 1426);
      attr_dev(g, "class", "line s-p8F5NyaCufjW");
      set_style(g, "--_color", ctx[11].stroke || ctx[0] || "");
      set_style(g, "--_width", ctx[11]["stroke-width"] || ctx[1] || "");
      set_style(g, "--_outline", ctx[2] || "");
      set_style(g, "--_outline-width", ctx[10] || "");
      set_style(g, "--_opacity", ctx[11].opacity || "");
      add_location(g, file$Z, 40, 0, 1031);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      if (if_block)
        if_block.m(g, null);
      append_hydration_dev(g, line);
      if (!mounted) {
        dispose = action_destroyer(symbol_action = symbol.call(null, g, ctx[5]));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[2] !== "none") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$o(ctx2);
          if_block.c();
          if_block.m(g, line);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(line, line_data = get_spread_update(line_levels, [
        dirty & 2048 && ctx2[11],
        dirty & 512 && { x1: ctx2[9] },
        dirty & 256 && { y1: ctx2[8] },
        dirty & 128 && { x2: ctx2[7] },
        dirty & 64 && { y2: ctx2[6] }
      ]));
      toggle_class(line, "s-p8F5NyaCufjW", true);
      if (symbol_action && is_function(symbol_action.update) && dirty & 32)
        symbol_action.update.call(null, ctx2[5]);
      if (dirty & 2049) {
        set_style(g, "--_color", ctx2[11].stroke || ctx2[0] || "");
      }
      if (dirty & 2050) {
        set_style(g, "--_width", ctx2[11]["stroke-width"] || ctx2[1] || "");
      }
      if (dirty & 4) {
        set_style(g, "--_outline", ctx2[2] || "");
      }
      if (dirty & 1024) {
        set_style(g, "--_outline-width", ctx2[10] || "");
      }
      if (dirty & 2048) {
        set_style(g, "--_opacity", ctx2[11].opacity || "");
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$12($$self, $$props, $$invalidate) {
  let outlineWidth;
  let x1;
  let y1;
  let x2;
  let y2;
  const omit_props_names = ["color", "width", "outline", "data", "xIndex", "yIndex", "label", "parent"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $yGet, $$unsubscribe_yGet = noop, $$subscribe_yGet = () => ($$unsubscribe_yGet(), $$unsubscribe_yGet = subscribe(yGet, ($$value) => $$invalidate(17, $yGet = $$value)), yGet);
  let $xGet, $$unsubscribe_xGet = noop, $$subscribe_xGet = () => ($$unsubscribe_xGet(), $$unsubscribe_xGet = subscribe(xGet, ($$value) => $$invalidate(18, $xGet = $$value)), xGet);
  $$self.$$.on_destroy.push(() => $$unsubscribe_yGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xGet());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Line", slots, []);
  let { color = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { xIndex = 0 } = $$props;
  let { yIndex = 0 } = $$props;
  let { label = void 0 } = $$props;
  let { parent = void 0 } = $$props;
  const ctx = getContext("LayerCake");
  let xGet, yGet;
  let friendly;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(0, color = $$new_props.color);
    if ("width" in $$new_props)
      $$invalidate(1, width = $$new_props.width);
    if ("outline" in $$new_props)
      $$invalidate(2, outline = $$new_props.outline);
    if ("data" in $$new_props)
      $$invalidate(12, data = $$new_props.data);
    if ("xIndex" in $$new_props)
      $$invalidate(13, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$new_props)
      $$invalidate(14, yIndex = $$new_props.yIndex);
    if ("label" in $$new_props)
      $$invalidate(15, label = $$new_props.label);
    if ("parent" in $$new_props)
      $$invalidate(16, parent = $$new_props.parent);
  };
  $$self.$capture_state = () => ({
    getContext,
    symbol,
    get,
    color,
    width,
    outline,
    data,
    xIndex,
    yIndex,
    label,
    parent,
    ctx,
    xGet,
    yGet,
    friendly,
    y2,
    x2,
    y1,
    x1,
    outlineWidth,
    $yGet,
    $xGet
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(0, color = $$new_props.color);
    if ("width" in $$props)
      $$invalidate(1, width = $$new_props.width);
    if ("outline" in $$props)
      $$invalidate(2, outline = $$new_props.outline);
    if ("data" in $$props)
      $$invalidate(12, data = $$new_props.data);
    if ("xIndex" in $$props)
      $$invalidate(13, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$props)
      $$invalidate(14, yIndex = $$new_props.yIndex);
    if ("label" in $$props)
      $$invalidate(15, label = $$new_props.label);
    if ("parent" in $$props)
      $$invalidate(16, parent = $$new_props.parent);
    if ("xGet" in $$props)
      $$subscribe_xGet($$invalidate(3, xGet = $$new_props.xGet));
    if ("yGet" in $$props)
      $$subscribe_yGet($$invalidate(4, yGet = $$new_props.yGet));
    if ("friendly" in $$props)
      $$invalidate(5, friendly = $$new_props.friendly);
    if ("y2" in $$props)
      $$invalidate(6, y2 = $$new_props.y2);
    if ("x2" in $$props)
      $$invalidate(7, x2 = $$new_props.x2);
    if ("y1" in $$props)
      $$invalidate(8, y1 = $$new_props.y1);
    if ("x1" in $$props)
      $$invalidate(9, x1 = $$new_props.x1);
    if ("outlineWidth" in $$props)
      $$invalidate(10, outlineWidth = $$new_props.outlineWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(10, outlineWidth = $$restProps["outline-width"]);
    $$invalidate(9, x1 = $$restProps.x1 || 0);
    $$invalidate(8, y1 = $$restProps.y1 || 0);
    $$invalidate(7, x2 = $$restProps.x2 || 0);
    $$invalidate(6, y2 = $$restProps.y2 || 0);
    if ($$self.$$.dirty & 421888) {
      if (data != void 0 && ctx != void 0) {
        $$subscribe_xGet($$invalidate(3, xGet = ctx.xGet));
        $$subscribe_yGet($$invalidate(4, yGet = ctx.yGet));
        $$invalidate(9, x1 = get($xGet, data[0], xIndex));
        $$invalidate(8, y1 = get($yGet, data[0], yIndex));
        $$invalidate(7, x2 = get($xGet, data[1], xIndex));
        $$invalidate(6, y2 = get($yGet, data[1], yIndex));
      }
    }
    if (label != void 0) {
      $$invalidate(5, friendly = {
        id: $$restProps.id,
        type: "line",
        label,
        parentId: parent
      });
    }
  };
  return [
    color,
    width,
    outline,
    xGet,
    yGet,
    friendly,
    y2,
    x2,
    y1,
    x1,
    outlineWidth,
    $$restProps,
    data,
    xIndex,
    yIndex,
    label,
    parent,
    $yGet,
    $xGet
  ];
}
class Line extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$12, create_fragment$12, safe_not_equal, {
      color: 0,
      width: 1,
      outline: 2,
      data: 12,
      xIndex: 13,
      yIndex: 14,
      label: 15,
      parent: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Line",
      options,
      id: create_fragment$12.name
    });
  }
  get color() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xIndex() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xIndex(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yIndex() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yIndex(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const LineH_svelte_svelte_type_style_lang = "";
const file$Y = "src/lib/components/layercake/LineH.svelte";
function create_fragment$11(ctx) {
  let g;
  let line;
  let g_class_value;
  let current;
  const line_spread_levels = [
    ctx[7],
    { x1: ctx[4] },
    { y1: ctx[6] },
    { x2: ctx[3] },
    { y2: ctx[5] }
  ];
  let line_props = {};
  for (let i = 0; i < line_spread_levels.length; i += 1) {
    line_props = assign(line_props, line_spread_levels[i]);
  }
  line = new Line({ props: line_props, $$inline: true });
  const block = {
    c: function create() {
      g = svg_element("g");
      create_component(line.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { class: true });
      var g_nodes = children(g);
      claim_component(line.$$.fragment, g_nodes);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g, "class", g_class_value = null_to_empty(ctx[7].class) + " s--FKn-5YoU5e5");
      toggle_class(g, "horizontal-line", true);
      add_location(g, file$Y, 33, 0, 932);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      mount_component(line, g, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const line_changes = dirty & 248 ? get_spread_update(line_spread_levels, [
        dirty & 128 && get_spread_object(ctx2[7]),
        dirty & 16 && { x1: ctx2[4] },
        dirty & 64 && { y1: ctx2[6] },
        dirty & 8 && { x2: ctx2[3] },
        dirty & 32 && { y2: ctx2[5] }
      ]) : {};
      line.$set(line_changes);
      if (!current || dirty & 128 && g_class_value !== (g_class_value = null_to_empty(ctx2[7].class) + " s--FKn-5YoU5e5")) {
        attr_dev(g, "class", g_class_value);
      }
      if (!current || dirty & 128) {
        toggle_class(g, "horizontal-line", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(line.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(line.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      destroy_component(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$11($$self, $$props, $$invalidate) {
  let x1;
  let x2;
  let y1;
  let y2;
  const omit_props_names = ["y", "yData", "xData"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $xScale, $$unsubscribe_xScale = noop, $$subscribe_xScale = () => ($$unsubscribe_xScale(), $$unsubscribe_xScale = subscribe(xScale, ($$value) => $$invalidate(11, $xScale = $$value)), xScale);
  let $width, $$unsubscribe_width = noop, $$subscribe_width = () => ($$unsubscribe_width(), $$unsubscribe_width = subscribe(width, ($$value) => $$invalidate(12, $width = $$value)), width);
  let $yScale, $$unsubscribe_yScale = noop, $$subscribe_yScale = () => ($$unsubscribe_yScale(), $$unsubscribe_yScale = subscribe(yScale, ($$value) => $$invalidate(13, $yScale = $$value)), yScale);
  $$self.$$.on_destroy.push(() => $$unsubscribe_xScale());
  $$self.$$.on_destroy.push(() => $$unsubscribe_width());
  $$self.$$.on_destroy.push(() => $$unsubscribe_yScale());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineH", slots, []);
  let { y = void 0 } = $$props;
  let { yData = void 0 } = $$props;
  let { xData = void 0 } = $$props;
  const ctx = getContext("LayerCake");
  let xScale, yScale, width;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("y" in $$new_props)
      $$invalidate(8, y = $$new_props.y);
    if ("yData" in $$new_props)
      $$invalidate(9, yData = $$new_props.yData);
    if ("xData" in $$new_props)
      $$invalidate(10, xData = $$new_props.xData);
  };
  $$self.$capture_state = () => ({
    getContext,
    Line,
    y,
    yData,
    xData,
    ctx,
    xScale,
    yScale,
    width,
    x2,
    x1,
    y2,
    y1,
    $xScale,
    $width,
    $yScale
  });
  $$self.$inject_state = ($$new_props) => {
    if ("y" in $$props)
      $$invalidate(8, y = $$new_props.y);
    if ("yData" in $$props)
      $$invalidate(9, yData = $$new_props.yData);
    if ("xData" in $$props)
      $$invalidate(10, xData = $$new_props.xData);
    if ("xScale" in $$props)
      $$subscribe_xScale($$invalidate(0, xScale = $$new_props.xScale));
    if ("yScale" in $$props)
      $$subscribe_yScale($$invalidate(1, yScale = $$new_props.yScale));
    if ("width" in $$props)
      $$subscribe_width($$invalidate(2, width = $$new_props.width));
    if ("x2" in $$props)
      $$invalidate(3, x2 = $$new_props.x2);
    if ("x1" in $$props)
      $$invalidate(4, x1 = $$new_props.x1);
    if ("y2" in $$props)
      $$invalidate(5, y2 = $$new_props.y2);
    if ("y1" in $$props)
      $$invalidate(6, y1 = $$new_props.y1);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(4, x1 = $$restProps.x1 || 0);
    $$invalidate(3, x2 = $$restProps.x2 || 0);
    if ($$self.$$.dirty & 256) {
      $$invalidate(6, y1 = y || 0);
    }
    if ($$self.$$.dirty & 256) {
      $$invalidate(5, y2 = y || 0);
    }
    if (ctx != void 0) {
      $$subscribe_width($$invalidate(2, width = ctx.width));
      $$invalidate(3, x2 = $$restProps.x2 || $width);
      if (yData != void 0) {
        $$subscribe_yScale($$invalidate(1, yScale = ctx.yScale));
        $$invalidate(6, y1 = $$invalidate(5, y2 = $yScale(yData)));
      }
      if (xData != void 0) {
        $$subscribe_xScale($$invalidate(0, xScale = ctx.xScale));
        $$invalidate(4, x1 = xData[0] === null ? 0 : $xScale(xData[0]));
        $$invalidate(3, x2 = xData[1] === null ? $width : $xScale(xData[1]));
      }
    }
  };
  return [
    xScale,
    yScale,
    width,
    x2,
    x1,
    y2,
    y1,
    $$restProps,
    y,
    yData,
    xData,
    $xScale,
    $width,
    $yScale
  ];
}
class LineH extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$11, create_fragment$11, safe_not_equal, { y: 8, yData: 9, xData: 10 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineH",
      options,
      id: create_fragment$11.name
    });
  }
  get y() {
    throw new Error("<LineH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<LineH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yData() {
    throw new Error("<LineH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yData(value) {
    throw new Error("<LineH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xData() {
    throw new Error("<LineH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xData(value) {
    throw new Error("<LineH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const LineV_svelte_svelte_type_style_lang = "";
const file$X = "src/lib/components/layercake/LineV.svelte";
function create_fragment$10(ctx) {
  let g;
  let line;
  let g_class_value;
  let current;
  const line_spread_levels = [
    ctx[7],
    { x1: ctx[6] },
    { y1: ctx[4] },
    { x2: ctx[5] },
    { y2: ctx[3] }
  ];
  let line_props = {};
  for (let i = 0; i < line_spread_levels.length; i += 1) {
    line_props = assign(line_props, line_spread_levels[i]);
  }
  line = new Line({ props: line_props, $$inline: true });
  const block = {
    c: function create() {
      g = svg_element("g");
      create_component(line.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { class: true });
      var g_nodes = children(g);
      claim_component(line.$$.fragment, g_nodes);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g, "class", g_class_value = null_to_empty(ctx[7].class) + " s-F_yqQE35gONP");
      toggle_class(g, "vertical-line", true);
      add_location(g, file$X, 33, 0, 936);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      mount_component(line, g, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const line_changes = dirty & 248 ? get_spread_update(line_spread_levels, [
        dirty & 128 && get_spread_object(ctx2[7]),
        dirty & 64 && { x1: ctx2[6] },
        dirty & 16 && { y1: ctx2[4] },
        dirty & 32 && { x2: ctx2[5] },
        dirty & 8 && { y2: ctx2[3] }
      ]) : {};
      line.$set(line_changes);
      if (!current || dirty & 128 && g_class_value !== (g_class_value = null_to_empty(ctx2[7].class) + " s-F_yqQE35gONP")) {
        attr_dev(g, "class", g_class_value);
      }
      if (!current || dirty & 128) {
        toggle_class(g, "vertical-line", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(line.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(line.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      destroy_component(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$10($$self, $$props, $$invalidate) {
  let y1;
  let y2;
  let x1;
  let x2;
  const omit_props_names = ["x", "xData", "yData"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $yScale, $$unsubscribe_yScale = noop, $$subscribe_yScale = () => ($$unsubscribe_yScale(), $$unsubscribe_yScale = subscribe(yScale, ($$value) => $$invalidate(11, $yScale = $$value)), yScale);
  let $height, $$unsubscribe_height = noop, $$subscribe_height = () => ($$unsubscribe_height(), $$unsubscribe_height = subscribe(height, ($$value) => $$invalidate(12, $height = $$value)), height);
  let $xScale, $$unsubscribe_xScale = noop, $$subscribe_xScale = () => ($$unsubscribe_xScale(), $$unsubscribe_xScale = subscribe(xScale, ($$value) => $$invalidate(13, $xScale = $$value)), xScale);
  $$self.$$.on_destroy.push(() => $$unsubscribe_yScale());
  $$self.$$.on_destroy.push(() => $$unsubscribe_height());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xScale());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineV", slots, []);
  let { x = void 0 } = $$props;
  let { xData = void 0 } = $$props;
  let { yData = void 0 } = $$props;
  const ctx = getContext("LayerCake");
  let xScale, yScale, height;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("x" in $$new_props)
      $$invalidate(8, x = $$new_props.x);
    if ("xData" in $$new_props)
      $$invalidate(9, xData = $$new_props.xData);
    if ("yData" in $$new_props)
      $$invalidate(10, yData = $$new_props.yData);
  };
  $$self.$capture_state = () => ({
    getContext,
    Line,
    x,
    xData,
    yData,
    ctx,
    xScale,
    yScale,
    height,
    y2,
    y1,
    x2,
    x1,
    $yScale,
    $height,
    $xScale
  });
  $$self.$inject_state = ($$new_props) => {
    if ("x" in $$props)
      $$invalidate(8, x = $$new_props.x);
    if ("xData" in $$props)
      $$invalidate(9, xData = $$new_props.xData);
    if ("yData" in $$props)
      $$invalidate(10, yData = $$new_props.yData);
    if ("xScale" in $$props)
      $$subscribe_xScale($$invalidate(0, xScale = $$new_props.xScale));
    if ("yScale" in $$props)
      $$subscribe_yScale($$invalidate(1, yScale = $$new_props.yScale));
    if ("height" in $$props)
      $$subscribe_height($$invalidate(2, height = $$new_props.height));
    if ("y2" in $$props)
      $$invalidate(3, y2 = $$new_props.y2);
    if ("y1" in $$props)
      $$invalidate(4, y1 = $$new_props.y1);
    if ("x2" in $$props)
      $$invalidate(5, x2 = $$new_props.x2);
    if ("x1" in $$props)
      $$invalidate(6, x1 = $$new_props.x1);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(4, y1 = $$restProps.y1 || 0);
    $$invalidate(3, y2 = $$restProps.y2 || 0);
    if ($$self.$$.dirty & 256) {
      $$invalidate(6, x1 = x || 0);
    }
    if ($$self.$$.dirty & 256) {
      $$invalidate(5, x2 = x || 0);
    }
    if (ctx != void 0) {
      $$subscribe_height($$invalidate(2, height = ctx.height));
      $$invalidate(3, y2 = $$restProps.y2 || $height);
      if (xData != void 0) {
        $$subscribe_xScale($$invalidate(0, xScale = ctx.xScale));
        $$invalidate(6, x1 = $$invalidate(5, x2 = $xScale(xData)));
      }
      if (yData != void 0) {
        $$subscribe_yScale($$invalidate(1, yScale = ctx.yScale));
        $$invalidate(4, y1 = yData[0] === null ? 0 : $yScale(yData[0]));
        $$invalidate(3, y2 = yData[1] === null ? $height : $yScale(yData[1]));
      }
    }
  };
  return [
    xScale,
    yScale,
    height,
    y2,
    y1,
    x2,
    x1,
    $$restProps,
    x,
    xData,
    yData,
    $yScale,
    $height,
    $xScale
  ];
}
class LineV extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$10, create_fragment$10, safe_not_equal, { x: 8, xData: 9, yData: 10 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineV",
      options,
      id: create_fragment$10.name
    });
  }
  get x() {
    throw new Error("<LineV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<LineV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xData() {
    throw new Error("<LineV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xData(value) {
    throw new Error("<LineV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yData() {
    throw new Error("<LineV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yData(value) {
    throw new Error("<LineV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const SvgText_svelte_svelte_type_style_lang = "";
const file$W = "src/lib/components/layercake/SvgText.svelte";
function create_fragment$$(ctx) {
  let text_1;
  let text_1_text_anchor_value;
  let style_transform = `translate(${ctx[7]}, calc(${ctx[11][ctx[3]]} + ${ctx[6]}))`;
  let current;
  const default_slot_template = ctx[21].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[20], null);
  let text_1_levels = [
    {
      "text-anchor": text_1_text_anchor_value = ctx[10][ctx[2]]
    },
    ctx[12],
    { x: ctx[9] },
    { y: ctx[8] }
  ];
  let text_1_data = {};
  for (let i = 0; i < text_1_levels.length; i += 1) {
    text_1_data = assign(text_1_data, text_1_levels[i]);
  }
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      text_1 = claim_svg_element(nodes, "text", { "text-anchor": true, x: true, y: true });
      var text_1_nodes = children(text_1);
      if (default_slot)
        default_slot.l(text_1_nodes);
      text_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(text_1, text_1_data);
      set_style(text_1, "transform", style_transform);
      set_style(text_1, "--_color", ctx[12].fill || ctx[0] || "");
      set_style(text_1, "--_outline", ctx[12].stroke || ctx[1] || "");
      set_style(text_1, "--_opacity", ctx[12].opacity || "");
      toggle_class(text_1, "s-iCVW9LLkx0nx", true);
      add_location(text_1, file$W, 38, 0, 954);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, text_1, anchor);
      if (default_slot) {
        default_slot.m(text_1, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(default_slot_template, ctx2[20], dirty, null),
            null
          );
        }
      }
      set_svg_attributes(text_1, text_1_data = get_spread_update(text_1_levels, [
        (!current || dirty & 4 && text_1_text_anchor_value !== (text_1_text_anchor_value = ctx2[10][ctx2[2]])) && { "text-anchor": text_1_text_anchor_value },
        dirty & 4096 && ctx2[12],
        (!current || dirty & 512) && { x: ctx2[9] },
        (!current || dirty & 256) && { y: ctx2[8] }
      ]));
      set_style(text_1, "transform", style_transform);
      set_style(text_1, "--_color", ctx2[12].fill || ctx2[0] || "");
      set_style(text_1, "--_outline", ctx2[12].stroke || ctx2[1] || "");
      set_style(text_1, "--_opacity", ctx2[12].opacity || "");
      toggle_class(text_1, "s-iCVW9LLkx0nx", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(text_1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$$.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$$($$self, $$props, $$invalidate) {
  let x;
  let y;
  let _xOffset;
  let _yOffset;
  const omit_props_names = [
    "color",
    "outline",
    "data",
    "xIndex",
    "yIndex",
    "xAlign",
    "yAlign",
    "xOffset",
    "yOffset"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $yGet, $$unsubscribe_yGet = noop, $$subscribe_yGet = () => ($$unsubscribe_yGet(), $$unsubscribe_yGet = subscribe(yGet, ($$value) => $$invalidate(18, $yGet = $$value)), yGet);
  let $xGet, $$unsubscribe_xGet = noop, $$subscribe_xGet = () => ($$unsubscribe_xGet(), $$unsubscribe_xGet = subscribe(xGet, ($$value) => $$invalidate(19, $xGet = $$value)), xGet);
  $$self.$$.on_destroy.push(() => $$unsubscribe_yGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xGet());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvgText", slots, ["default"]);
  let { color = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { xIndex = 0 } = $$props;
  let { yIndex = 0 } = $$props;
  let { xAlign = "left" } = $$props;
  let { yAlign = "bottom" } = $$props;
  let { xOffset = 0 } = $$props;
  let { yOffset = 0 } = $$props;
  const textAnchor = {
    left: "start",
    center: "middle",
    right: "end"
  };
  const yTranslate = {
    top: "1em",
    center: "0.33em",
    bottom: "0px"
  };
  const ctx = getContext("LayerCake");
  let xGet, yGet;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$new_props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$new_props)
      $$invalidate(13, data = $$new_props.data);
    if ("xIndex" in $$new_props)
      $$invalidate(14, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$new_props)
      $$invalidate(15, yIndex = $$new_props.yIndex);
    if ("xAlign" in $$new_props)
      $$invalidate(2, xAlign = $$new_props.xAlign);
    if ("yAlign" in $$new_props)
      $$invalidate(3, yAlign = $$new_props.yAlign);
    if ("xOffset" in $$new_props)
      $$invalidate(16, xOffset = $$new_props.xOffset);
    if ("yOffset" in $$new_props)
      $$invalidate(17, yOffset = $$new_props.yOffset);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get,
    color,
    outline,
    data,
    xIndex,
    yIndex,
    xAlign,
    yAlign,
    xOffset,
    yOffset,
    textAnchor,
    yTranslate,
    ctx,
    xGet,
    yGet,
    _yOffset,
    _xOffset,
    y,
    x,
    $yGet,
    $xGet
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$props)
      $$invalidate(13, data = $$new_props.data);
    if ("xIndex" in $$props)
      $$invalidate(14, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$props)
      $$invalidate(15, yIndex = $$new_props.yIndex);
    if ("xAlign" in $$props)
      $$invalidate(2, xAlign = $$new_props.xAlign);
    if ("yAlign" in $$props)
      $$invalidate(3, yAlign = $$new_props.yAlign);
    if ("xOffset" in $$props)
      $$invalidate(16, xOffset = $$new_props.xOffset);
    if ("yOffset" in $$props)
      $$invalidate(17, yOffset = $$new_props.yOffset);
    if ("xGet" in $$props)
      $$subscribe_xGet($$invalidate(4, xGet = $$new_props.xGet));
    if ("yGet" in $$props)
      $$subscribe_yGet($$invalidate(5, yGet = $$new_props.yGet));
    if ("_yOffset" in $$props)
      $$invalidate(6, _yOffset = $$new_props._yOffset);
    if ("_xOffset" in $$props)
      $$invalidate(7, _xOffset = $$new_props._xOffset);
    if ("y" in $$props)
      $$invalidate(8, y = $$new_props.y);
    if ("x" in $$props)
      $$invalidate(9, x = $$new_props.x);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(9, x = $$restProps.x || 0);
    $$invalidate(8, y = $$restProps.y || 0);
    if ($$self.$$.dirty & 843776) {
      if (data != void 0 && ctx != void 0) {
        $$subscribe_xGet($$invalidate(4, xGet = ctx.xGet));
        $$subscribe_yGet($$invalidate(5, yGet = ctx.yGet));
        $$invalidate(9, x = get($xGet, data, xIndex));
        $$invalidate(8, y = get($yGet, data, yIndex));
      }
    }
    if ($$self.$$.dirty & 65536) {
      $$invalidate(7, _xOffset = typeof xOffset === "number" ? `${xOffset}px` : xOffset);
    }
    if ($$self.$$.dirty & 131072) {
      $$invalidate(6, _yOffset = typeof yOffset === "number" ? `${yOffset}px` : yOffset);
    }
  };
  return [
    color,
    outline,
    xAlign,
    yAlign,
    xGet,
    yGet,
    _yOffset,
    _xOffset,
    y,
    x,
    textAnchor,
    yTranslate,
    $$restProps,
    data,
    xIndex,
    yIndex,
    xOffset,
    yOffset,
    $yGet,
    $xGet,
    $$scope,
    slots
  ];
}
class SvgText extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$$, create_fragment$$, safe_not_equal, {
      color: 0,
      outline: 1,
      data: 13,
      xIndex: 14,
      yIndex: 15,
      xAlign: 2,
      yAlign: 3,
      xOffset: 16,
      yOffset: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvgText",
      options,
      id: create_fragment$$.name
    });
  }
  get color() {
    throw new Error("<SvgText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<SvgText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<SvgText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<SvgText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<SvgText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<SvgText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xIndex() {
    throw new Error("<SvgText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xIndex(value) {
    throw new Error("<SvgText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yIndex() {
    throw new Error("<SvgText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yIndex(value) {
    throw new Error("<SvgText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAlign() {
    throw new Error("<SvgText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAlign(value) {
    throw new Error("<SvgText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAlign() {
    throw new Error("<SvgText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAlign(value) {
    throw new Error("<SvgText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xOffset() {
    throw new Error("<SvgText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xOffset(value) {
    throw new Error("<SvgText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yOffset() {
    throw new Error("<SvgText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yOffset(value) {
    throw new Error("<SvgText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const file$V = "src/lib/components/layercake/AxisX.svelte";
function get_each_context$f(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  const constants_0 = child_ctx[9](child_ctx[19]) + (child_ctx[9].bandwidth != void 0 ? child_ctx[9].bandwidth() / 2 : 0);
  child_ctx[20] = constants_0;
  return child_ctx;
}
const get_default_slot_changes$a = (dirty) => ({ tick: dirty & 1 });
const get_default_slot_context$a = (ctx) => ({ tick: ctx[19] });
function get_each_context_1$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_if_block_2$b(ctx) {
  let linev;
  let current;
  linev = new LineV({
    props: { class: "grid-line" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(linev.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(linev.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(linev, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(linev.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linev.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(linev, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$b.name,
    type: "if",
    source: "(42:6) {#if showGridLines}",
    ctx
  });
  return block;
}
function create_each_block_1$4(ctx) {
  let g;
  let g_transform_value;
  let current;
  let if_block = ctx[2] && create_if_block_2$b(ctx);
  const block = {
    c: function create() {
      g = svg_element("g");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { transform: true });
      var g_nodes = children(g);
      if (if_block)
        if_block.l(g_nodes);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g, "transform", g_transform_value = "translate(" + ctx[9](ctx[19]) + ", 0)");
      add_location(g, file$V, 40, 4, 1136);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      if (if_block)
        if_block.m(g, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$b(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(g, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 513 && g_transform_value !== (g_transform_value = "translate(" + ctx2[9](ctx2[19]) + ", 0)")) {
        attr_dev(g, "transform", g_transform_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1$4.name,
    type: "each",
    source: "(40:2) {#each ticks as tick}",
    ctx
  });
  return block;
}
function create_if_block_1$b(ctx) {
  let lineh;
  let current;
  lineh = new LineH({
    props: { class: "domain-line" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(lineh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lineh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lineh, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lineh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$b.name,
    type: "if",
    source: "(48:4) {#if showDomainLine}",
    ctx
  });
  return block;
}
function create_if_block$n(ctx) {
  let linev;
  let current;
  linev = new LineV({
    props: {
      class: ctx[1] ? "domain-line" : "tick-line",
      y2: ctx[8] * ctx[5]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(linev.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(linev.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(linev, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const linev_changes = {};
      if (dirty & 2)
        linev_changes.class = ctx2[1] ? "domain-line" : "tick-line";
      if (dirty & 288)
        linev_changes.y2 = ctx2[8] * ctx2[5];
      linev.$set(linev_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(linev.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linev.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(linev, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$n.name,
    type: "if",
    source: "(57:8) {#if showTickLines}",
    ctx
  });
  return block;
}
function fallback_block$e(ctx) {
  let t_value = ctx[19] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[19] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$e.name,
    type: "fallback",
    source: "(71:23)              ",
    ctx
  });
  return block;
}
function create_default_slot$B(ctx) {
  let t;
  let current;
  const default_slot_template = ctx[17].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[18], get_default_slot_context$a);
  const default_slot_or_fallback = default_slot || fallback_block$e(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 262145)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(default_slot_template, ctx2[18], dirty, get_default_slot_changes$a),
            get_default_slot_context$a
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 1)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$B.name,
    type: "slot",
    source: `(63:8) <SvgText           class={isCategorical ? 'category-tick' : 'tick'}           xAlign=\\"center\\"           yAlign={onTop ? 'bottom' : 'top'}           yOffset={direction *             (tickLabelPadding + (showTickLines ? tickLength : 0))}           outline=\\"none\\"         >`,
    ctx
  });
  return block;
}
function create_each_block$f(ctx) {
  let g;
  let if_block_anchor;
  let svgtext;
  let g_transform_value;
  let current;
  let if_block = ctx[3] && create_if_block$n(ctx);
  svgtext = new SvgText({
    props: {
      class: ctx[13] ? "category-tick" : "tick",
      xAlign: "center",
      yAlign: ctx[4] ? "bottom" : "top",
      yOffset: ctx[8] * (ctx[6] + (ctx[3] ? ctx[5] : 0)),
      outline: "none",
      $$slots: { default: [create_default_slot$B] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      g = svg_element("g");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      create_component(svgtext.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { transform: true });
      var g_nodes = children(g);
      if (if_block)
        if_block.l(g_nodes);
      if_block_anchor = empty();
      claim_component(svgtext.$$.fragment, g_nodes);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g, "transform", g_transform_value = "translate(" + ctx[20] + ", 0)");
      add_location(g, file$V, 55, 6, 1547);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      if (if_block)
        if_block.m(g, null);
      append_hydration_dev(g, if_block_anchor);
      mount_component(svgtext, g, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$n(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(g, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const svgtext_changes = {};
      if (dirty & 16)
        svgtext_changes.yAlign = ctx2[4] ? "bottom" : "top";
      if (dirty & 360)
        svgtext_changes.yOffset = ctx2[8] * (ctx2[6] + (ctx2[3] ? ctx2[5] : 0));
      if (dirty & 262145) {
        svgtext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext.$set(svgtext_changes);
      if (!current || dirty & 513 && g_transform_value !== (g_transform_value = "translate(" + ctx2[20] + ", 0)")) {
        attr_dev(g, "transform", g_transform_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(svgtext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(svgtext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      if (if_block)
        if_block.d();
      destroy_component(svgtext);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$f.name,
    type: "each",
    source: "(51:4) {#each ticks as tick}",
    ctx
  });
  return block;
}
function create_fragment$_(ctx) {
  let g1;
  let g0;
  let if_block_anchor;
  let g0_transform_value;
  let g1_class_value;
  let g1_style_value;
  let axis_action;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ctx[0];
  validate_each_argument(each_value_1);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let if_block = ctx[1] && create_if_block_1$b(ctx);
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      g1 = svg_element("g");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      g0 = svg_element("g");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      g1 = claim_svg_element(nodes, "g", { class: true, style: true });
      var g1_nodes = children(g1);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(g1_nodes);
      }
      g0 = claim_svg_element(g1_nodes, "g", { transform: true });
      var g0_nodes = children(g0);
      if (if_block)
        if_block.l(g0_nodes);
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(g0_nodes);
      }
      g0_nodes.forEach(detach_dev);
      g1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g0, "transform", g0_transform_value = "translate(0, " + (ctx[4] ? 0 : ctx[10]) + ")");
      add_location(g0, file$V, 46, 2, 1277);
      attr_dev(g1, "class", g1_class_value = ctx[14].class);
      attr_dev(g1, "style", g1_style_value = ctx[14].style);
      toggle_class(g1, "axis-x", true);
      add_location(g1, file$V, 33, 0, 1003);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g1, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(g1, null);
      }
      append_hydration_dev(g1, g0);
      if (if_block)
        if_block.m(g0, null);
      append_hydration_dev(g0, if_block_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(g0, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(axis_action = axis.call(null, g1, ctx[7]));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 517) {
        each_value_1 = ctx2[0];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$4(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_1$4(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(g1, g0);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block) {
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$b(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(g0, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 271227) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$f(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$f(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(g0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
      if (!current || dirty & 1040 && g0_transform_value !== (g0_transform_value = "translate(0, " + (ctx2[4] ? 0 : ctx2[10]) + ")")) {
        attr_dev(g0, "transform", g0_transform_value);
      }
      if (!current || dirty & 16384 && g1_class_value !== (g1_class_value = ctx2[14].class)) {
        attr_dev(g1, "class", g1_class_value);
      }
      if (!current || dirty & 16384 && g1_style_value !== (g1_style_value = ctx2[14].style)) {
        attr_dev(g1, "style", g1_style_value);
      }
      if (axis_action && is_function(axis_action.update) && dirty & 128)
        axis_action.update.call(null, ctx2[7]);
      if (!current || dirty & 16384) {
        toggle_class(g1, "axis-x", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g1);
      destroy_each(each_blocks_1, detaching);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$_.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$_($$self, $$props, $$invalidate) {
  let direction;
  const omit_props_names = [
    "n",
    "ticks",
    "showDomainLine",
    "showGridLines",
    "showTickLines",
    "onTop",
    "tickLength",
    "tickLabelPadding",
    "label"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $xScale;
  let $height;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AxisX", slots, ["default"]);
  const { xScale, height } = getContext("LayerCake");
  validate_store(xScale, "xScale");
  component_subscribe($$self, xScale, (value) => $$invalidate(9, $xScale = value));
  validate_store(height, "height");
  component_subscribe($$self, height, (value) => $$invalidate(10, $height = value));
  const isCategorical = $xScale.bandwidth != void 0;
  let { n = void 0 } = $$props;
  let { ticks = isCategorical ? $xScale.domain() : $xScale.ticks(n) } = $$props;
  let { showDomainLine = true } = $$props;
  let { showGridLines = false } = $$props;
  let { showTickLines = true } = $$props;
  let { onTop = false } = $$props;
  let { tickLength = 6 } = $$props;
  let { tickLabelPadding = 6 } = $$props;
  let { label = void 0 } = $$props;
  let friendly;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("n" in $$new_props)
      $$invalidate(15, n = $$new_props.n);
    if ("ticks" in $$new_props)
      $$invalidate(0, ticks = $$new_props.ticks);
    if ("showDomainLine" in $$new_props)
      $$invalidate(1, showDomainLine = $$new_props.showDomainLine);
    if ("showGridLines" in $$new_props)
      $$invalidate(2, showGridLines = $$new_props.showGridLines);
    if ("showTickLines" in $$new_props)
      $$invalidate(3, showTickLines = $$new_props.showTickLines);
    if ("onTop" in $$new_props)
      $$invalidate(4, onTop = $$new_props.onTop);
    if ("tickLength" in $$new_props)
      $$invalidate(5, tickLength = $$new_props.tickLength);
    if ("tickLabelPadding" in $$new_props)
      $$invalidate(6, tickLabelPadding = $$new_props.tickLabelPadding);
    if ("label" in $$new_props)
      $$invalidate(16, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    axis,
    LineH,
    LineV,
    SvgText,
    xScale,
    height,
    isCategorical,
    n,
    ticks,
    showDomainLine,
    showGridLines,
    showTickLines,
    onTop,
    tickLength,
    tickLabelPadding,
    label,
    friendly,
    direction,
    $xScale,
    $height
  });
  $$self.$inject_state = ($$new_props) => {
    if ("n" in $$props)
      $$invalidate(15, n = $$new_props.n);
    if ("ticks" in $$props)
      $$invalidate(0, ticks = $$new_props.ticks);
    if ("showDomainLine" in $$props)
      $$invalidate(1, showDomainLine = $$new_props.showDomainLine);
    if ("showGridLines" in $$props)
      $$invalidate(2, showGridLines = $$new_props.showGridLines);
    if ("showTickLines" in $$props)
      $$invalidate(3, showTickLines = $$new_props.showTickLines);
    if ("onTop" in $$props)
      $$invalidate(4, onTop = $$new_props.onTop);
    if ("tickLength" in $$props)
      $$invalidate(5, tickLength = $$new_props.tickLength);
    if ("tickLabelPadding" in $$props)
      $$invalidate(6, tickLabelPadding = $$new_props.tickLabelPadding);
    if ("label" in $$props)
      $$invalidate(16, label = $$new_props.label);
    if ("friendly" in $$props)
      $$invalidate(7, friendly = $$new_props.friendly);
    if ("direction" in $$props)
      $$invalidate(8, direction = $$new_props.direction);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $$invalidate(8, direction = onTop ? -1 : 1);
    }
    if ($$self.$$.dirty & 65536) {
      if (label != void 0) {
        $$invalidate(7, friendly = {
          label,
          direction: "x",
          type: isCategorical ? "categorical" : "continuous",
          ticks: isCategorical ? "text.category-tick" : "text.tick"
        });
      }
    }
  };
  return [
    ticks,
    showDomainLine,
    showGridLines,
    showTickLines,
    onTop,
    tickLength,
    tickLabelPadding,
    friendly,
    direction,
    $xScale,
    $height,
    xScale,
    height,
    isCategorical,
    $$restProps,
    n,
    label,
    slots,
    $$scope
  ];
}
class AxisX extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$_, create_fragment$_, safe_not_equal, {
      n: 15,
      ticks: 0,
      showDomainLine: 1,
      showGridLines: 2,
      showTickLines: 3,
      onTop: 4,
      tickLength: 5,
      tickLabelPadding: 6,
      label: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AxisX",
      options,
      id: create_fragment$_.name
    });
  }
  get n() {
    throw new Error("<AxisX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set n(value) {
    throw new Error("<AxisX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticks() {
    throw new Error("<AxisX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticks(value) {
    throw new Error("<AxisX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showDomainLine() {
    throw new Error("<AxisX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showDomainLine(value) {
    throw new Error("<AxisX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showGridLines() {
    throw new Error("<AxisX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showGridLines(value) {
    throw new Error("<AxisX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showTickLines() {
    throw new Error("<AxisX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showTickLines(value) {
    throw new Error("<AxisX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTop() {
    throw new Error("<AxisX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTop(value) {
    throw new Error("<AxisX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickLength() {
    throw new Error("<AxisX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickLength(value) {
    throw new Error("<AxisX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickLabelPadding() {
    throw new Error("<AxisX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickLabelPadding(value) {
    throw new Error("<AxisX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<AxisX>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<AxisX>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const file$U = "src/lib/components/layercake/AxisY.svelte";
function get_each_context$e(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  const constants_0 = child_ctx[7](child_ctx[15]) + (child_ctx[7].bandwidth != void 0 ? child_ctx[7].bandwidth() / 2 : 0);
  child_ctx[16] = constants_0;
  return child_ctx;
}
const get_default_slot_changes$9 = (dirty) => ({ tick: dirty & 1 });
const get_default_slot_context$9 = (ctx) => ({ tick: ctx[15] });
function create_if_block_2$a(ctx) {
  let linev;
  let current;
  linev = new LineV({
    props: { class: "domain-line" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(linev.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(linev.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(linev, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(linev.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linev.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(linev, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$a.name,
    type: "if",
    source: "(38:2) {#if showDomainLine}",
    ctx
  });
  return block;
}
function create_if_block_1$a(ctx) {
  let lineh;
  let current;
  lineh = new LineH({
    props: { class: "grid-line" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(lineh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lineh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lineh, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lineh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$a.name,
    type: "if",
    source: "(47:6) {#if showGridLines}",
    ctx
  });
  return block;
}
function create_if_block$m(ctx) {
  let lineh;
  let current;
  lineh = new LineH({
    props: {
      class: ctx[1] ? "domain-line" : "tick-line",
      x2: -ctx[4]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(lineh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lineh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lineh, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const lineh_changes = {};
      if (dirty & 2)
        lineh_changes.class = ctx2[1] ? "domain-line" : "tick-line";
      if (dirty & 16)
        lineh_changes.x2 = -ctx2[4];
      lineh.$set(lineh_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lineh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$m.name,
    type: "if",
    source: "(50:6) {#if showTickLines}",
    ctx
  });
  return block;
}
function fallback_block$d(ctx) {
  let t_value = ctx[15] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[15] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$d.name,
    type: "fallback",
    source: "(63:21)            ",
    ctx
  });
  return block;
}
function create_default_slot$A(ctx) {
  let t;
  let current;
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], get_default_slot_context$9);
  const default_slot_or_fallback = default_slot || fallback_block$d(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16385)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(default_slot_template, ctx2[14], dirty, get_default_slot_changes$9),
            get_default_slot_context$9
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 1)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$A.name,
    type: "slot",
    source: `(56:6) <SvgText         class={isCategorical ? 'category-tick' : 'tick'}         xAlign=\\"right\\"         yAlign=\\"center\\"         xOffset={-tickLabelPadding - (showTickLines ? tickLength : 0)}         outline=\\"none\\"       >`,
    ctx
  });
  return block;
}
function create_each_block$e(ctx) {
  let g;
  let if_block0_anchor;
  let if_block1_anchor;
  let svgtext;
  let g_transform_value;
  let current;
  let if_block0 = ctx[2] && create_if_block_1$a(ctx);
  let if_block1 = ctx[3] && create_if_block$m(ctx);
  svgtext = new SvgText({
    props: {
      class: ctx[9] ? "category-tick" : "tick",
      xAlign: "right",
      yAlign: "center",
      xOffset: -ctx[5] - (ctx[3] ? ctx[4] : 0),
      outline: "none",
      $$slots: { default: [create_default_slot$A] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      g = svg_element("g");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      create_component(svgtext.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { transform: true });
      var g_nodes = children(g);
      if (if_block0)
        if_block0.l(g_nodes);
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.l(g_nodes);
      if_block1_anchor = empty();
      claim_component(svgtext.$$.fragment, g_nodes);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g, "transform", g_transform_value = "translate(0, " + ctx[16] + ")");
      add_location(g, file$U, 45, 4, 1256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      if (if_block0)
        if_block0.m(g, null);
      append_hydration_dev(g, if_block0_anchor);
      if (if_block1)
        if_block1.m(g, null);
      append_hydration_dev(g, if_block1_anchor);
      mount_component(svgtext, g, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block0) {
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$a(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(g, if_block0_anchor);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$m(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(g, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const svgtext_changes = {};
      if (dirty & 56)
        svgtext_changes.xOffset = -ctx2[5] - (ctx2[3] ? ctx2[4] : 0);
      if (dirty & 16385) {
        svgtext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext.$set(svgtext_changes);
      if (!current || dirty & 129 && g_transform_value !== (g_transform_value = "translate(0, " + ctx2[16] + ")")) {
        attr_dev(g, "transform", g_transform_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(svgtext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(svgtext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(svgtext);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$e.name,
    type: "each",
    source: "(41:2) {#each ticks as tick}",
    ctx
  });
  return block;
}
function create_fragment$Z(ctx) {
  let g;
  let if_block_anchor;
  let g_class_value;
  let g_style_value;
  let axis_action;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block_2$a(ctx);
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      g = svg_element("g");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { class: true, style: true });
      var g_nodes = children(g);
      if (if_block)
        if_block.l(g_nodes);
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(g_nodes);
      }
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g, "class", g_class_value = ctx[10].class);
      attr_dev(g, "style", g_style_value = ctx[10].style);
      toggle_class(g, "axis-y", true);
      add_location(g, file$U, 31, 0, 949);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      if (if_block)
        if_block.m(g, null);
      append_hydration_dev(g, if_block_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(g, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(axis_action = axis.call(null, g, ctx[6]));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$a(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(g, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 17087) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$e(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$e(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(g, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 1024 && g_class_value !== (g_class_value = ctx2[10].class)) {
        attr_dev(g, "class", g_class_value);
      }
      if (!current || dirty & 1024 && g_style_value !== (g_style_value = ctx2[10].style)) {
        attr_dev(g, "style", g_style_value);
      }
      if (axis_action && is_function(axis_action.update) && dirty & 64)
        axis_action.update.call(null, ctx2[6]);
      if (!current || dirty & 1024) {
        toggle_class(g, "axis-y", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$Z.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$Z($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "n",
    "ticks",
    "showDomainLine",
    "showGridLines",
    "showTickLines",
    "tickLength",
    "tickLabelPadding",
    "label"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $yScale;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AxisY", slots, ["default"]);
  const { yScale } = getContext("LayerCake");
  validate_store(yScale, "yScale");
  component_subscribe($$self, yScale, (value) => $$invalidate(7, $yScale = value));
  const isCategorical = $yScale.bandwidth != void 0;
  let { n = void 0 } = $$props;
  let { ticks = isCategorical ? $yScale.domain() : $yScale.ticks(n) } = $$props;
  let { showDomainLine = false } = $$props;
  let { showGridLines = !isCategorical } = $$props;
  let { showTickLines = false } = $$props;
  let { tickLength = 6 } = $$props;
  let { tickLabelPadding = 8 } = $$props;
  let { label = void 0 } = $$props;
  let friendly;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("n" in $$new_props)
      $$invalidate(11, n = $$new_props.n);
    if ("ticks" in $$new_props)
      $$invalidate(0, ticks = $$new_props.ticks);
    if ("showDomainLine" in $$new_props)
      $$invalidate(1, showDomainLine = $$new_props.showDomainLine);
    if ("showGridLines" in $$new_props)
      $$invalidate(2, showGridLines = $$new_props.showGridLines);
    if ("showTickLines" in $$new_props)
      $$invalidate(3, showTickLines = $$new_props.showTickLines);
    if ("tickLength" in $$new_props)
      $$invalidate(4, tickLength = $$new_props.tickLength);
    if ("tickLabelPadding" in $$new_props)
      $$invalidate(5, tickLabelPadding = $$new_props.tickLabelPadding);
    if ("label" in $$new_props)
      $$invalidate(12, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    axis,
    LineH,
    LineV,
    SvgText,
    yScale,
    isCategorical,
    n,
    ticks,
    showDomainLine,
    showGridLines,
    showTickLines,
    tickLength,
    tickLabelPadding,
    label,
    friendly,
    $yScale
  });
  $$self.$inject_state = ($$new_props) => {
    if ("n" in $$props)
      $$invalidate(11, n = $$new_props.n);
    if ("ticks" in $$props)
      $$invalidate(0, ticks = $$new_props.ticks);
    if ("showDomainLine" in $$props)
      $$invalidate(1, showDomainLine = $$new_props.showDomainLine);
    if ("showGridLines" in $$props)
      $$invalidate(2, showGridLines = $$new_props.showGridLines);
    if ("showTickLines" in $$props)
      $$invalidate(3, showTickLines = $$new_props.showTickLines);
    if ("tickLength" in $$props)
      $$invalidate(4, tickLength = $$new_props.tickLength);
    if ("tickLabelPadding" in $$props)
      $$invalidate(5, tickLabelPadding = $$new_props.tickLabelPadding);
    if ("label" in $$props)
      $$invalidate(12, label = $$new_props.label);
    if ("friendly" in $$props)
      $$invalidate(6, friendly = $$new_props.friendly);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4096) {
      if (label != void 0) {
        $$invalidate(6, friendly = {
          label,
          direction: "y",
          type: isCategorical ? "categorical" : "continuous",
          ticks: isCategorical ? "text.category-tick" : "text.tick"
        });
      }
    }
  };
  return [
    ticks,
    showDomainLine,
    showGridLines,
    showTickLines,
    tickLength,
    tickLabelPadding,
    friendly,
    $yScale,
    yScale,
    isCategorical,
    $$restProps,
    n,
    label,
    slots,
    $$scope
  ];
}
class AxisY extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
      n: 11,
      ticks: 0,
      showDomainLine: 1,
      showGridLines: 2,
      showTickLines: 3,
      tickLength: 4,
      tickLabelPadding: 5,
      label: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AxisY",
      options,
      id: create_fragment$Z.name
    });
  }
  get n() {
    throw new Error("<AxisY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set n(value) {
    throw new Error("<AxisY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticks() {
    throw new Error("<AxisY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticks(value) {
    throw new Error("<AxisY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showDomainLine() {
    throw new Error("<AxisY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showDomainLine(value) {
    throw new Error("<AxisY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showGridLines() {
    throw new Error("<AxisY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showGridLines(value) {
    throw new Error("<AxisY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showTickLines() {
    throw new Error("<AxisY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showTickLines(value) {
    throw new Error("<AxisY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickLength() {
    throw new Error("<AxisY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickLength(value) {
    throw new Error("<AxisY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickLabelPadding() {
    throw new Error("<AxisY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickLabelPadding(value) {
    throw new Error("<AxisY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<AxisY>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<AxisY>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Path_svelte_svelte_type_style_lang = "";
const file$T = "src/lib/components/layercake/Path.svelte";
function create_if_block$l(ctx) {
  let path;
  let path_levels = [ctx[10], { d: ctx[0] }];
  let path_data = {};
  for (let i = 0; i < path_levels.length; i += 1) {
    path_data = assign(path_data, path_levels[i]);
  }
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(path, path_data);
      toggle_class(path, "outline", true);
      toggle_class(path, "s-b3VkDFTxFMeD", true);
      add_location(path, file$T, 66, 4, 1720);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: function update(ctx2, dirty) {
      set_svg_attributes(path, path_data = get_spread_update(path_levels, [
        dirty & 1024 && ctx2[10],
        dirty & 1 && { d: ctx2[0] }
      ]));
      toggle_class(path, "outline", true);
      toggle_class(path, "s-b3VkDFTxFMeD", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$l.name,
    type: "if",
    source: "(66:2) {#if outline !== 'none'}",
    ctx
  });
  return block;
}
function create_fragment$Y(ctx) {
  let g;
  let path;
  let symbol_action;
  let fGroup_action;
  let mounted;
  let dispose;
  let if_block = ctx[3] !== "none" && create_if_block$l(ctx);
  let path_levels = [ctx[10], { d: ctx[0] }];
  let path_data = {};
  for (let i = 0; i < path_levels.length; i += 1) {
    path_data = assign(path_data, path_levels[i]);
  }
  const block = {
    c: function create() {
      g = svg_element("g");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { class: true });
      var g_nodes = children(g);
      if (if_block)
        if_block.l(g_nodes);
      path = claim_svg_element(g_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(path, path_data);
      toggle_class(path, "s-b3VkDFTxFMeD", true);
      add_location(path, file$T, 68, 2, 1781);
      attr_dev(g, "class", "path s-b3VkDFTxFMeD");
      set_style(g, "--_color", ctx[10].stroke || ctx[1] || "");
      set_style(g, "--_width", ctx[10]["stroke-width"] || ctx[2] || "");
      set_style(g, "--_outline", ctx[3] || "");
      set_style(g, "--_outline-width", ctx[9] || "");
      set_style(g, "--_opacity", ctx[10].opacity || "");
      add_location(g, file$T, 55, 0, 1376);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      if (if_block)
        if_block.m(g, null);
      append_hydration_dev(g, path);
      if (!mounted) {
        dispose = [
          action_destroyer(symbol_action = symbol.call(null, g, ctx[7])),
          action_destroyer(fGroup_action = group.call(null, g, ctx[8]))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[3] !== "none") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$l(ctx2);
          if_block.c();
          if_block.m(g, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_svg_attributes(path, path_data = get_spread_update(path_levels, [
        dirty & 1024 && ctx2[10],
        dirty & 1 && { d: ctx2[0] }
      ]));
      toggle_class(path, "s-b3VkDFTxFMeD", true);
      if (symbol_action && is_function(symbol_action.update) && dirty & 128)
        symbol_action.update.call(null, ctx2[7]);
      if (fGroup_action && is_function(fGroup_action.update) && dirty & 256)
        fGroup_action.update.call(null, ctx2[8]);
      if (dirty & 1026) {
        set_style(g, "--_color", ctx2[10].stroke || ctx2[1] || "");
      }
      if (dirty & 1028) {
        set_style(g, "--_width", ctx2[10]["stroke-width"] || ctx2[2] || "");
      }
      if (dirty & 8) {
        set_style(g, "--_outline", ctx2[3] || "");
      }
      if (dirty & 512) {
        set_style(g, "--_outline-width", ctx2[9] || "");
      }
      if (dirty & 1024) {
        set_style(g, "--_opacity", ctx2[10].opacity || "");
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$Y.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$Y($$self, $$props, $$invalidate) {
  let outlineWidth;
  const omit_props_names = [
    "color",
    "width",
    "outline",
    "d",
    "data",
    "xIndex",
    "yIndex",
    "group",
    "label",
    "parent"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $yGet, $$unsubscribe_yGet = noop, $$subscribe_yGet = () => ($$unsubscribe_yGet(), $$unsubscribe_yGet = subscribe(yGet, ($$value) => $$invalidate(17, $yGet = $$value)), yGet);
  let $xGet, $$unsubscribe_xGet = noop, $$subscribe_xGet = () => ($$unsubscribe_xGet(), $$unsubscribe_xGet = subscribe(xGet, ($$value) => $$invalidate(18, $xGet = $$value)), xGet);
  let $ctxData, $$unsubscribe_ctxData = noop, $$subscribe_ctxData = () => ($$unsubscribe_ctxData(), $$unsubscribe_ctxData = subscribe(ctxData, ($$value) => $$invalidate(19, $ctxData = $$value)), ctxData);
  $$self.$$.on_destroy.push(() => $$unsubscribe_yGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_ctxData());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Path", slots, []);
  let { color = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { d = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { xIndex = 0 } = $$props;
  let { yIndex = 0 } = $$props;
  let { group: group$1 = false } = $$props;
  let { label = void 0 } = $$props;
  let { parent = void 0 } = $$props;
  const ctx = getContext("LayerCake");
  let ctxData, xGet, yGet;
  let friendlyS;
  let friendlyG;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("width" in $$new_props)
      $$invalidate(2, width = $$new_props.width);
    if ("outline" in $$new_props)
      $$invalidate(3, outline = $$new_props.outline);
    if ("d" in $$new_props)
      $$invalidate(0, d = $$new_props.d);
    if ("data" in $$new_props)
      $$invalidate(11, data = $$new_props.data);
    if ("xIndex" in $$new_props)
      $$invalidate(12, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$new_props)
      $$invalidate(13, yIndex = $$new_props.yIndex);
    if ("group" in $$new_props)
      $$invalidate(14, group$1 = $$new_props.group);
    if ("label" in $$new_props)
      $$invalidate(15, label = $$new_props.label);
    if ("parent" in $$new_props)
      $$invalidate(16, parent = $$new_props.parent);
  };
  $$self.$capture_state = () => ({
    getContext,
    symbol,
    fGroup: group,
    d3line,
    get,
    color,
    width,
    outline,
    d,
    data,
    xIndex,
    yIndex,
    group: group$1,
    label,
    parent,
    ctx,
    ctxData,
    xGet,
    yGet,
    friendlyS,
    friendlyG,
    outlineWidth,
    $yGet,
    $xGet,
    $ctxData
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(1, color = $$new_props.color);
    if ("width" in $$props)
      $$invalidate(2, width = $$new_props.width);
    if ("outline" in $$props)
      $$invalidate(3, outline = $$new_props.outline);
    if ("d" in $$props)
      $$invalidate(0, d = $$new_props.d);
    if ("data" in $$props)
      $$invalidate(11, data = $$new_props.data);
    if ("xIndex" in $$props)
      $$invalidate(12, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$props)
      $$invalidate(13, yIndex = $$new_props.yIndex);
    if ("group" in $$props)
      $$invalidate(14, group$1 = $$new_props.group);
    if ("label" in $$props)
      $$invalidate(15, label = $$new_props.label);
    if ("parent" in $$props)
      $$invalidate(16, parent = $$new_props.parent);
    if ("ctxData" in $$props)
      $$subscribe_ctxData($$invalidate(4, ctxData = $$new_props.ctxData));
    if ("xGet" in $$props)
      $$subscribe_xGet($$invalidate(5, xGet = $$new_props.xGet));
    if ("yGet" in $$props)
      $$subscribe_yGet($$invalidate(6, yGet = $$new_props.yGet));
    if ("friendlyS" in $$props)
      $$invalidate(7, friendlyS = $$new_props.friendlyS);
    if ("friendlyG" in $$props)
      $$invalidate(8, friendlyG = $$new_props.friendlyG);
    if ("outlineWidth" in $$props)
      $$invalidate(9, outlineWidth = $$new_props.outlineWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(9, outlineWidth = $$restProps["outline-width"]);
    if ($$self.$$.dirty & 931840) {
      if (ctx != void 0) {
        if (data == void 0) {
          $$subscribe_ctxData($$invalidate(4, ctxData = ctx.data));
          $$invalidate(11, data = $ctxData);
        }
        $$subscribe_xGet($$invalidate(5, xGet = ctx.xGet));
        $$subscribe_yGet($$invalidate(6, yGet = ctx.yGet));
        $$invalidate(0, d = d3line().x((d2) => get($xGet, d2, xIndex)).y((d2) => get($yGet, d2, yIndex))(data));
      }
    }
    if (label != void 0) {
      if (group$1) {
        if ($$restProps.id == void 0) {
          console.warn(`Specify an id for line with label "${label}"`);
        }
        $$invalidate(8, friendlyG = { id: $$restProps.id, type: "line", label });
      } else {
        $$invalidate(7, friendlyS = {
          id: $$restProps.id,
          type: "line",
          label,
          parentId: parent
        });
      }
    }
  };
  return [
    d,
    color,
    width,
    outline,
    ctxData,
    xGet,
    yGet,
    friendlyS,
    friendlyG,
    outlineWidth,
    $$restProps,
    data,
    xIndex,
    yIndex,
    group$1,
    label,
    parent,
    $yGet,
    $xGet,
    $ctxData
  ];
}
class Path extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {
      color: 1,
      width: 2,
      outline: 3,
      d: 0,
      data: 11,
      xIndex: 12,
      yIndex: 13,
      group: 14,
      label: 15,
      parent: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Path",
      options,
      id: create_fragment$Y.name
    });
  }
  get color() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get d() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set d(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xIndex() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xIndex(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yIndex() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yIndex(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<Path>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<Path>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const AreaY_story_svelte_svelte_type_style_lang = "";
const file$S = "src/lib/components/layercake/AreaY.story.svelte";
function create_default_slot_6$e(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let areay;
  let t2;
  let path0;
  let t3;
  let path1;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  areay = new AreaY({
    props: { data: ctx[1] },
    $$inline: true
  });
  path0 = new Path({
    props: { outline: "none" },
    $$inline: true
  });
  path1 = new Path({
    props: { yIndex: 1, outline: "none" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      create_component(areay.$$.fragment);
      t2 = space();
      create_component(path0.$$.fragment);
      t3 = space();
      create_component(path1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(areay.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(path0.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(path1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(areay, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(path0, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(path1, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      transition_in(areay.$$.fragment, local);
      transition_in(path0.$$.fragment, local);
      transition_in(path1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      transition_out(areay.$$.fragment, local);
      transition_out(path0.$$.fragment, local);
      transition_out(path1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(areay, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(path0, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(path1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$e.name,
    type: "slot",
    source: "(30:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_5$o(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_6$e] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 4) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$o.name,
    type: "slot",
    source: `(24:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y={['y1', 'y2']}       >`,
    ctx
  });
  return block;
}
function create_default_slot_4$p(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: ["y1", "y2"],
      $$slots: { default: [create_default_slot_5$o] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-XPhbm_Rsj7wq");
      add_location(div, file$S, 22, 4, 659);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 4) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$p.name,
    type: "slot",
    source: '(22:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$t(ctx) {
  let areay;
  let current;
  areay = new AreaY({
    props: { data: ctx[1] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(areay.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(areay.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(areay, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(areay.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(areay.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(areay, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$t.name,
    type: "slot",
    source: "(49:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$u(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$t] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 4) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$u.name,
    type: "slot",
    source: `(43:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y={['y1', 'y2']}       >`,
    ctx
  });
  return block;
}
function create_default_slot_1$x(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: ["y1", "y2"],
      $$slots: { default: [create_default_slot_2$u] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-XPhbm_Rsj7wq");
      add_location(div, file$S, 41, 4, 1085);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 4) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$x.name,
    type: "slot",
    source: '(41:2) <Hst.Variant title=\\"Shape only\\">',
    ctx
  });
  return block;
}
function create_default_slot$z(ctx) {
  let hst_variant0;
  let t;
  let hst_variant1;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_4$p] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Shape only",
      $$slots: { default: [create_default_slot_1$x] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t = space();
      create_component(hst_variant1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(hst_variant1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 4) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 4) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(hst_variant1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$z.name,
    type: "slot",
    source: `(17:0) <Hst.Story   group=\\"layercake\\"   title=\\"AreaY\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$X(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "AreaY",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$z] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 4) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$X.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$X($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AreaY_story", slots, []);
  let { Hst } = $$props;
  let data = [
    { x: 0, y1: 10, y2: 5 },
    { x: 10, y1: 30, y2: 10 },
    { x: 20, y1: 25, y2: 25 },
    { x: 30, y1: 50, y2: 40 },
    { x: 40, y1: 10, y2: 25 },
    { x: 50, y1: 0, y2: 15 }
  ];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<AreaY_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AreaY_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    AreaY,
    AxisX,
    AxisY,
    Path,
    data
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data];
}
class AreaY_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$X, create_fragment$X, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AreaY_story",
      options,
      id: create_fragment$X.name
    });
  }
  get Hst() {
    throw new Error("<AreaY_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<AreaY_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const AreaY0_svelte_svelte_type_style_lang = "";
const file$R = "src/lib/components/layercake/AreaY0.svelte";
function create_fragment$W(ctx) {
  let g;
  let path;
  let symbol_action;
  let mounted;
  let dispose;
  let path_levels = [ctx[8], { d: ctx[0] }];
  let path_data = {};
  for (let i = 0; i < path_levels.length; i += 1) {
    path_data = assign(path_data, path_levels[i]);
  }
  const block = {
    c: function create() {
      g = svg_element("g");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { class: true });
      var g_nodes = children(g);
      path = claim_svg_element(g_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(path, path_data);
      toggle_class(path, "area", true);
      toggle_class(path, "s-ujhbZJwvSerx", true);
      add_location(path, file$R, 48, 2, 1250);
      attr_dev(g, "class", "area-y0 s-ujhbZJwvSerx");
      set_style(g, "--_color", ctx[8].stroke || ctx[1] || "");
      set_style(g, "--_outline", ctx[2] || "");
      set_style(g, "--_outline-width", ctx[7] || "");
      set_style(g, "--_opacity", ctx[8].opacity || "");
      add_location(g, file$R, 40, 0, 1020);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      append_hydration_dev(g, path);
      if (!mounted) {
        dispose = action_destroyer(symbol_action = symbol.call(null, g, ctx[6]));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(path, path_data = get_spread_update(path_levels, [
        dirty & 256 && ctx2[8],
        dirty & 1 && { d: ctx2[0] }
      ]));
      toggle_class(path, "area", true);
      toggle_class(path, "s-ujhbZJwvSerx", true);
      if (symbol_action && is_function(symbol_action.update) && dirty & 64)
        symbol_action.update.call(null, ctx2[6]);
      if (dirty & 258) {
        set_style(g, "--_color", ctx2[8].stroke || ctx2[1] || "");
      }
      if (dirty & 4) {
        set_style(g, "--_outline", ctx2[2] || "");
      }
      if (dirty & 128) {
        set_style(g, "--_outline-width", ctx2[7] || "");
      }
      if (dirty & 256) {
        set_style(g, "--_opacity", ctx2[8].opacity || "");
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$W.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$W($$self, $$props, $$invalidate) {
  let outlineWidth;
  const omit_props_names = ["color", "outline", "d", "data", "xIndex", "yIndex", "label", "parent"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $yGet, $$unsubscribe_yGet = noop, $$subscribe_yGet = () => ($$unsubscribe_yGet(), $$unsubscribe_yGet = subscribe(yGet, ($$value) => $$invalidate(15, $yGet = $$value)), yGet);
  let $yScale, $$unsubscribe_yScale = noop, $$subscribe_yScale = () => ($$unsubscribe_yScale(), $$unsubscribe_yScale = subscribe(yScale, ($$value) => $$invalidate(16, $yScale = $$value)), yScale);
  let $xGet, $$unsubscribe_xGet = noop, $$subscribe_xGet = () => ($$unsubscribe_xGet(), $$unsubscribe_xGet = subscribe(xGet, ($$value) => $$invalidate(17, $xGet = $$value)), xGet);
  $$self.$$.on_destroy.push(() => $$unsubscribe_yGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_yScale());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xGet());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AreaY0", slots, []);
  let { color = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { d = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { xIndex = 0 } = $$props;
  let { yIndex = 0 } = $$props;
  let { label = void 0 } = $$props;
  let { parent = void 0 } = $$props;
  const ctx = getContext("LayerCake");
  let xGet, yGet, yScale;
  let area;
  let friendly;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("outline" in $$new_props)
      $$invalidate(2, outline = $$new_props.outline);
    if ("d" in $$new_props)
      $$invalidate(0, d = $$new_props.d);
    if ("data" in $$new_props)
      $$invalidate(9, data = $$new_props.data);
    if ("xIndex" in $$new_props)
      $$invalidate(10, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$new_props)
      $$invalidate(11, yIndex = $$new_props.yIndex);
    if ("label" in $$new_props)
      $$invalidate(12, label = $$new_props.label);
    if ("parent" in $$new_props)
      $$invalidate(13, parent = $$new_props.parent);
  };
  $$self.$capture_state = () => ({
    getContext,
    symbol,
    d3area,
    get,
    color,
    outline,
    d,
    data,
    xIndex,
    yIndex,
    label,
    parent,
    ctx,
    xGet,
    yGet,
    yScale,
    area,
    friendly,
    outlineWidth,
    $yGet,
    $yScale,
    $xGet
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(1, color = $$new_props.color);
    if ("outline" in $$props)
      $$invalidate(2, outline = $$new_props.outline);
    if ("d" in $$props)
      $$invalidate(0, d = $$new_props.d);
    if ("data" in $$props)
      $$invalidate(9, data = $$new_props.data);
    if ("xIndex" in $$props)
      $$invalidate(10, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$props)
      $$invalidate(11, yIndex = $$new_props.yIndex);
    if ("label" in $$props)
      $$invalidate(12, label = $$new_props.label);
    if ("parent" in $$props)
      $$invalidate(13, parent = $$new_props.parent);
    if ("xGet" in $$props)
      $$subscribe_xGet($$invalidate(3, xGet = $$new_props.xGet));
    if ("yGet" in $$props)
      $$subscribe_yGet($$invalidate(4, yGet = $$new_props.yGet));
    if ("yScale" in $$props)
      $$subscribe_yScale($$invalidate(5, yScale = $$new_props.yScale));
    if ("area" in $$props)
      $$invalidate(14, area = $$new_props.area);
    if ("friendly" in $$props)
      $$invalidate(6, friendly = $$new_props.friendly);
    if ("outlineWidth" in $$props)
      $$invalidate(7, outlineWidth = $$new_props.outlineWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(7, outlineWidth = $$restProps["outline-width"]);
    if ($$self.$$.dirty & 249344) {
      if (data != void 0 && ctx != void 0) {
        $$subscribe_xGet($$invalidate(3, xGet = ctx.xGet));
        $$subscribe_yGet($$invalidate(4, yGet = ctx.yGet));
        $$subscribe_yScale($$invalidate(5, yScale = ctx.yScale));
        $$invalidate(14, area = d3area().x((d2) => get($xGet, d2, xIndex)).y0(() => $yScale(0)).y1((d2) => get($yGet, d2, yIndex)));
        $$invalidate(0, d = area(data));
      }
    }
    if (label != void 0) {
      $$invalidate(6, friendly = {
        id: $$restProps.id,
        type: "area",
        label,
        parentId: parent
      });
    }
  };
  return [
    d,
    color,
    outline,
    xGet,
    yGet,
    yScale,
    friendly,
    outlineWidth,
    $$restProps,
    data,
    xIndex,
    yIndex,
    label,
    parent,
    area,
    $yGet,
    $yScale,
    $xGet
  ];
}
class AreaY0 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$W, create_fragment$W, safe_not_equal, {
      color: 1,
      outline: 2,
      d: 0,
      data: 9,
      xIndex: 10,
      yIndex: 11,
      label: 12,
      parent: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AreaY0",
      options,
      id: create_fragment$W.name
    });
  }
  get color() {
    throw new Error("<AreaY0>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<AreaY0>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<AreaY0>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<AreaY0>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get d() {
    throw new Error("<AreaY0>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set d(value) {
    throw new Error("<AreaY0>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<AreaY0>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<AreaY0>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xIndex() {
    throw new Error("<AreaY0>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xIndex(value) {
    throw new Error("<AreaY0>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yIndex() {
    throw new Error("<AreaY0>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yIndex(value) {
    throw new Error("<AreaY0>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<AreaY0>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<AreaY0>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<AreaY0>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<AreaY0>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const AreaY0_story_svelte_svelte_type_style_lang = "";
const file$Q = "src/lib/components/layercake/AreaY0.story.svelte";
function create_default_slot_6$d(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let areay0;
  let t2;
  let path;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  areay0 = new AreaY0({
    props: { data: ctx[1] },
    $$inline: true
  });
  path = new Path({
    props: { outline: "none" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      create_component(areay0.$$.fragment);
      t2 = space();
      create_component(path.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(areay0.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(path.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(areay0, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(path, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      transition_in(areay0.$$.fragment, local);
      transition_in(path.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      transition_out(areay0.$$.fragment, local);
      transition_out(path.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(areay0, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(path, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$d.name,
    type: "slot",
    source: "(30:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_5$n(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_6$d] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 4) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$n.name,
    type: "slot",
    source: `(24:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y={['y1', 'y2']}       >`,
    ctx
  });
  return block;
}
function create_default_slot_4$o(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: ["y1", "y2"],
      $$slots: { default: [create_default_slot_5$n] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-v8X4CaTycAdo");
      add_location(div, file$Q, 22, 4, 662);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 4) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$o.name,
    type: "slot",
    source: '(22:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$s(ctx) {
  let areay0;
  let current;
  areay0 = new AreaY0({
    props: { data: ctx[1] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(areay0.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(areay0.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(areay0, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(areay0.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(areay0.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(areay0, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$s.name,
    type: "slot",
    source: "(48:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$t(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$s] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 4) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$t.name,
    type: "slot",
    source: `(42:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y={['y1', 'y2']}       >`,
    ctx
  });
  return block;
}
function create_default_slot_1$w(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: ["y1", "y2"],
      $$slots: { default: [create_default_slot_2$t] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-v8X4CaTycAdo");
      add_location(div, file$Q, 40, 4, 1044);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 4) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$w.name,
    type: "slot",
    source: '(40:2) <Hst.Variant title=\\"Shape only\\">',
    ctx
  });
  return block;
}
function create_default_slot$y(ctx) {
  let hst_variant0;
  let t;
  let hst_variant1;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_4$o] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Shape only",
      $$slots: { default: [create_default_slot_1$w] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t = space();
      create_component(hst_variant1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(hst_variant1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 4) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 4) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(hst_variant1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$y.name,
    type: "slot",
    source: `(17:0) <Hst.Story   group=\\"layercake\\"   title=\\"AreaY0\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$V(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "AreaY0",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$y] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 4) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$V.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$V($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AreaY0_story", slots, []);
  let { Hst } = $$props;
  let data = [
    { x: 0, y1: 10, y2: 5 },
    { x: 10, y1: 30, y2: 10 },
    { x: 20, y1: 25, y2: 25 },
    { x: 30, y1: 50, y2: 40 },
    { x: 40, y1: 10, y2: 25 },
    { x: 50, y1: 0, y2: 15 }
  ];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<AreaY0_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AreaY0_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    AreaY0,
    AxisX,
    AxisY,
    Path,
    data
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data];
}
class AreaY0_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$V, create_fragment$V, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AreaY0_story",
      options,
      id: create_fragment$V.name
    });
  }
  get Hst() {
    throw new Error("<AreaY0_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<AreaY0_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Arrow_svelte_svelte_type_style_lang = "";
const file$P = "src/lib/components/layercake/Arrow.svelte";
function get_each_context$d(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i][0];
  child_ctx[34] = list[i][1];
  return child_ctx;
}
function get_each_context_1$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  return child_ctx;
}
function create_if_block$k(ctx) {
  let g;
  let each0_anchor;
  let each_value_1 = [ctx[13], ctx[12]];
  validate_each_argument(each_value_1);
  let each_blocks_1 = [];
  for (let i = 0; i < 2; i += 1) {
    each_blocks_1[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
  }
  let each_value = [
    [ctx[0], ctx[13]],
    [ctx[1], ctx[12]]
  ];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < 2; i += 1) {
    each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      g = svg_element("g");
      for (let i = 0; i < 2; i += 1) {
        each_blocks_1[i].c();
      }
      each0_anchor = empty();
      for (let i = 0; i < 2; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { class: true });
      var g_nodes = children(g);
      for (let i = 0; i < 2; i += 1) {
        each_blocks_1[i].l(g_nodes);
      }
      each0_anchor = empty();
      for (let i = 0; i < 2; i += 1) {
        each_blocks[i].l(g_nodes);
      }
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g, "class", "debug s-fD7A1cEJ8nYd");
      add_location(g, file$P, 120, 4, 4216);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      for (let i = 0; i < 2; i += 1) {
        each_blocks_1[i].m(g, null);
      }
      append_hydration_dev(g, each0_anchor);
      for (let i = 0; i < 2; i += 1) {
        each_blocks[i].m(g, null);
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 12288) {
        each_value_1 = [ctx2[13], ctx2[12]];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < 2; i += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1$3(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(g, each0_anchor);
          }
        }
        for (; i < 2; i += 1) {
          each_blocks_1[i].d(1);
        }
      }
      if (dirty[0] & 12291) {
        each_value = [
          [ctx2[0], ctx2[13]],
          [ctx2[1], ctx2[12]]
        ];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < 2; i += 1) {
          const child_ctx = get_each_context$d(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$d(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(g, null);
          }
        }
        for (; i < 2; i += 1) {
          each_blocks[i].d(1);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$k.name,
    type: "if",
    source: "(120:2) {#if debug}",
    ctx
  });
  return block;
}
function create_each_block_1$3(ctx) {
  let circle;
  let circle_cx_value;
  let circle_cy_value;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true, class: true });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", circle_cx_value = ctx[37][0]);
      attr_dev(circle, "cy", circle_cy_value = ctx[37][1]);
      attr_dev(circle, "r", "5");
      attr_dev(circle, "class", "s-fD7A1cEJ8nYd");
      add_location(circle, file$P, 122, 8, 4293);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 12288 && circle_cx_value !== (circle_cx_value = ctx2[37][0])) {
        attr_dev(circle, "cx", circle_cx_value);
      }
      if (dirty[0] & 12288 && circle_cy_value !== (circle_cy_value = ctx2[37][1])) {
        attr_dev(circle, "cy", circle_cy_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1$3.name,
    type: "each",
    source: "(122:6) {#each [_startHandle, _endHandle] as coords}",
    ctx
  });
  return block;
}
function create_each_block$d(ctx) {
  let line;
  let line_x__value;
  let line_y__value;
  let line_x__value_1;
  let line_y__value_1;
  const block = {
    c: function create() {
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true,
        class: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", line_x__value = ctx[33][0]);
      attr_dev(line, "y1", line_y__value = ctx[33][1]);
      attr_dev(line, "x2", line_x__value_1 = ctx[34][0]);
      attr_dev(line, "y2", line_y__value_1 = ctx[34][1]);
      attr_dev(line, "class", "s-fD7A1cEJ8nYd");
      add_location(line, file$P, 125, 8, 4429);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 12291 && line_x__value !== (line_x__value = ctx2[33][0])) {
        attr_dev(line, "x1", line_x__value);
      }
      if (dirty[0] & 12291 && line_y__value !== (line_y__value = ctx2[33][1])) {
        attr_dev(line, "y1", line_y__value);
      }
      if (dirty[0] & 12291 && line_x__value_1 !== (line_x__value_1 = ctx2[34][0])) {
        attr_dev(line, "x2", line_x__value_1);
      }
      if (dirty[0] & 12291 && line_y__value_1 !== (line_y__value_1 = ctx2[34][1])) {
        attr_dev(line, "y2", line_y__value_1);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$d.name,
    type: "each",
    source: "(125:6) {#each [[start, _startHandle], [end, _endHandle]] as [s, e]}",
    ctx
  });
  return block;
}
function create_fragment$U(ctx) {
  let g;
  let path;
  let path_d_value;
  let g_class_value;
  let g_style_value;
  let if_block = ctx[6] && create_if_block$k(ctx);
  const block = {
    c: function create() {
      g = svg_element("g");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { class: true, style: true });
      var g_nodes = children(g);
      if (if_block)
        if_block.l(g_nodes);
      path = claim_svg_element(g_nodes, "path", { class: true, d: true });
      children(path).forEach(detach_dev);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "class", "arrow__shape s-fD7A1cEJ8nYd");
      attr_dev(path, "d", path_d_value = ctx[14](ctx[8], ctx[7], ctx[13], ctx[12], ctx[2], ctx[11]));
      add_location(path, file$P, 130, 2, 4512);
      attr_dev(g, "class", g_class_value = null_to_empty(ctx[15].class) + " s-fD7A1cEJ8nYd");
      attr_dev(g, "style", g_style_value = ctx[15].style);
      toggle_class(g, "arrow", true);
      set_style(g, "--_color", ctx[4] || "");
      set_style(g, "--_width", ctx[3] || "");
      set_style(g, "--_opacity", ctx[5] || "");
      add_location(g, file$P, 111, 0, 4019);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      if (if_block)
        if_block.m(g, null);
      append_hydration_dev(g, path);
    },
    p: function update(ctx2, dirty) {
      if (ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$k(ctx2);
          if_block.c();
          if_block.m(g, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & 14724 && path_d_value !== (path_d_value = ctx2[14](ctx2[8], ctx2[7], ctx2[13], ctx2[12], ctx2[2], ctx2[11]))) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty[0] & 32768 && g_class_value !== (g_class_value = null_to_empty(ctx2[15].class) + " s-fD7A1cEJ8nYd")) {
        attr_dev(g, "class", g_class_value);
      }
      if (dirty[0] & 32768 && g_style_value !== (g_style_value = ctx2[15].style)) {
        attr_dev(g, "style", g_style_value);
      }
      if (dirty[0] & 32768) {
        toggle_class(g, "arrow", true);
      }
      if (dirty[0] & 16) {
        set_style(g, "--_color", ctx2[4] || "");
      }
      if (dirty[0] & 8) {
        set_style(g, "--_width", ctx2[3] || "");
      }
      if (dirty[0] & 32) {
        set_style(g, "--_opacity", ctx2[5] || "");
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$U.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function arrowHead(point, handle, { length = 4, theta = 45 } = {}) {
  const xLen = handle[0] - point[0];
  const yLen = handle[1] - point[1];
  const distance = Math.sqrt(Math.pow(xLen, 2) + Math.pow(yLen, 2));
  const ratio = length / distance;
  const mid = [point[0] + xLen * ratio, point[1] + yLen * ratio];
  function rotate(p, pivot, theta2) {
    const thetaRad = theta2 * Math.PI / 180;
    return [
      pivot[0] + (p[0] - pivot[0]) * Math.cos(thetaRad) - (p[1] - pivot[1]) * Math.sin(thetaRad),
      pivot[1] + (p[0] - pivot[0]) * Math.sin(thetaRad) + (p[1] - pivot[1]) * Math.cos(thetaRad)
    ];
  }
  return ["M", rotate(mid, point, theta), "L", point, "L", rotate(mid, point, -theta)].join(" ");
}
function instance$U($$self, $$props, $$invalidate) {
  let _start;
  let _end;
  let _startHandle;
  let _endHandle;
  let headOptions;
  const omit_props_names = [
    "start",
    "end",
    "data",
    "xIndex",
    "yIndex",
    "startHandleOffset",
    "endHandleOffset",
    "startHandle",
    "endHandle",
    "headAnchor",
    "headLength",
    "headAngle",
    "width",
    "color",
    "opacity",
    "debug"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $yGet, $$unsubscribe_yGet = noop, $$subscribe_yGet = () => ($$unsubscribe_yGet(), $$unsubscribe_yGet = subscribe(yGet, ($$value) => $$invalidate(25, $yGet = $$value)), yGet);
  let $xGet, $$unsubscribe_xGet = noop, $$subscribe_xGet = () => ($$unsubscribe_xGet(), $$unsubscribe_xGet = subscribe(xGet, ($$value) => $$invalidate(26, $xGet = $$value)), xGet);
  $$self.$$.on_destroy.push(() => $$unsubscribe_yGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xGet());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Arrow", slots, []);
  let { start = [0, 0] } = $$props;
  let { end = [50, 0] } = $$props;
  let { data = void 0 } = $$props;
  let { xIndex = 0 } = $$props;
  let { yIndex = 0 } = $$props;
  let { startHandleOffset = [0, 0] } = $$props;
  let { endHandleOffset = [0, 0] } = $$props;
  let { startHandle = void 0 } = $$props;
  let { endHandle = void 0 } = $$props;
  let { headAnchor = "end" } = $$props;
  let { headLength = void 0 } = $$props;
  let { headAngle = 55 } = $$props;
  let { width = void 0 } = $$props;
  let { color = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { debug = false } = $$props;
  const dist = (p1, p2) => Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2));
  const clamp = (n, min = 0, max = 1) => Math.min(Math.max(n, min), max);
  const equals = (p1, p2) => p1[0] === p2[0] && p1[1] === p2[1];
  const addOffset = (p, o) => [p[0] + o[0], p[1] + o[1]];
  const bezierCurve = (start2, end2, startHandle2, endHandle2) => ["M", start2, "C", startHandle2, endHandle2, end2].join(" ");
  function arrow(start2, end2, startHandle2, endHandle2, _headAnchor, _headOptions) {
    let d = bezierCurve(start2, end2, startHandle2, endHandle2);
    if (_headAnchor === "start" || _headAnchor === "both") {
      const handle = equals(start2, startHandle2) ? end2 : startHandle2;
      d += arrowHead(start2, handle, _headOptions);
    }
    if (_headAnchor === "end" || _headAnchor === "both") {
      const handle = equals(end2, endHandle2) ? start2 : endHandle2;
      d += arrowHead(end2, handle, _headOptions);
    }
    return d;
  }
  const ctx = getContext("LayerCake");
  let xGet, yGet;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("start" in $$new_props)
      $$invalidate(0, start = $$new_props.start);
    if ("end" in $$new_props)
      $$invalidate(1, end = $$new_props.end);
    if ("data" in $$new_props)
      $$invalidate(16, data = $$new_props.data);
    if ("xIndex" in $$new_props)
      $$invalidate(17, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$new_props)
      $$invalidate(18, yIndex = $$new_props.yIndex);
    if ("startHandleOffset" in $$new_props)
      $$invalidate(19, startHandleOffset = $$new_props.startHandleOffset);
    if ("endHandleOffset" in $$new_props)
      $$invalidate(20, endHandleOffset = $$new_props.endHandleOffset);
    if ("startHandle" in $$new_props)
      $$invalidate(21, startHandle = $$new_props.startHandle);
    if ("endHandle" in $$new_props)
      $$invalidate(22, endHandle = $$new_props.endHandle);
    if ("headAnchor" in $$new_props)
      $$invalidate(2, headAnchor = $$new_props.headAnchor);
    if ("headLength" in $$new_props)
      $$invalidate(23, headLength = $$new_props.headLength);
    if ("headAngle" in $$new_props)
      $$invalidate(24, headAngle = $$new_props.headAngle);
    if ("width" in $$new_props)
      $$invalidate(3, width = $$new_props.width);
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("opacity" in $$new_props)
      $$invalidate(5, opacity = $$new_props.opacity);
    if ("debug" in $$new_props)
      $$invalidate(6, debug = $$new_props.debug);
  };
  $$self.$capture_state = () => ({
    getContext,
    get,
    start,
    end,
    data,
    xIndex,
    yIndex,
    startHandleOffset,
    endHandleOffset,
    startHandle,
    endHandle,
    headAnchor,
    headLength,
    headAngle,
    width,
    color,
    opacity,
    debug,
    dist,
    clamp,
    equals,
    addOffset,
    bezierCurve,
    arrowHead,
    arrow,
    ctx,
    xGet,
    yGet,
    _end,
    _start,
    headOptions,
    _endHandle,
    _startHandle,
    $yGet,
    $xGet
  });
  $$self.$inject_state = ($$new_props) => {
    if ("start" in $$props)
      $$invalidate(0, start = $$new_props.start);
    if ("end" in $$props)
      $$invalidate(1, end = $$new_props.end);
    if ("data" in $$props)
      $$invalidate(16, data = $$new_props.data);
    if ("xIndex" in $$props)
      $$invalidate(17, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$props)
      $$invalidate(18, yIndex = $$new_props.yIndex);
    if ("startHandleOffset" in $$props)
      $$invalidate(19, startHandleOffset = $$new_props.startHandleOffset);
    if ("endHandleOffset" in $$props)
      $$invalidate(20, endHandleOffset = $$new_props.endHandleOffset);
    if ("startHandle" in $$props)
      $$invalidate(21, startHandle = $$new_props.startHandle);
    if ("endHandle" in $$props)
      $$invalidate(22, endHandle = $$new_props.endHandle);
    if ("headAnchor" in $$props)
      $$invalidate(2, headAnchor = $$new_props.headAnchor);
    if ("headLength" in $$props)
      $$invalidate(23, headLength = $$new_props.headLength);
    if ("headAngle" in $$props)
      $$invalidate(24, headAngle = $$new_props.headAngle);
    if ("width" in $$props)
      $$invalidate(3, width = $$new_props.width);
    if ("color" in $$props)
      $$invalidate(4, color = $$new_props.color);
    if ("opacity" in $$props)
      $$invalidate(5, opacity = $$new_props.opacity);
    if ("debug" in $$props)
      $$invalidate(6, debug = $$new_props.debug);
    if ("xGet" in $$props)
      $$subscribe_xGet($$invalidate(9, xGet = $$new_props.xGet));
    if ("yGet" in $$props)
      $$subscribe_yGet($$invalidate(10, yGet = $$new_props.yGet));
    if ("_end" in $$props)
      $$invalidate(7, _end = $$new_props._end);
    if ("_start" in $$props)
      $$invalidate(8, _start = $$new_props._start);
    if ("headOptions" in $$props)
      $$invalidate(11, headOptions = $$new_props.headOptions);
    if ("_endHandle" in $$props)
      $$invalidate(12, _endHandle = $$new_props._endHandle);
    if ("_startHandle" in $$props)
      $$invalidate(13, _startHandle = $$new_props._startHandle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1) {
      $$invalidate(8, _start = start);
    }
    if ($$self.$$.dirty[0] & 2) {
      $$invalidate(7, _end = end);
    }
    if ($$self.$$.dirty[0] & 101122048) {
      if (data != void 0 && ctx != void 0) {
        $$subscribe_xGet($$invalidate(9, xGet = ctx.xGet));
        $$subscribe_yGet($$invalidate(10, yGet = ctx.yGet));
        $$invalidate(8, _start = [get($xGet, data[0], xIndex), get($yGet, data[0], yIndex)]);
        $$invalidate(7, _end = [get($xGet, data[1], xIndex), get($yGet, data[1], yIndex)]);
      }
    }
    if ($$self.$$.dirty[0] & 2621696) {
      $$invalidate(13, _startHandle = startHandle || addOffset(_start, startHandleOffset));
    }
    if ($$self.$$.dirty[0] & 5243008) {
      $$invalidate(12, _endHandle = endHandle || addOffset(_end, endHandleOffset));
    }
    if ($$self.$$.dirty[0] & 25165827) {
      $$invalidate(11, headOptions = {
        length: headLength || clamp(0.08 * dist(start, end), 4, 8),
        theta: headAngle
      });
    }
  };
  return [
    start,
    end,
    headAnchor,
    width,
    color,
    opacity,
    debug,
    _end,
    _start,
    xGet,
    yGet,
    headOptions,
    _endHandle,
    _startHandle,
    arrow,
    $$restProps,
    data,
    xIndex,
    yIndex,
    startHandleOffset,
    endHandleOffset,
    startHandle,
    endHandle,
    headLength,
    headAngle,
    $yGet,
    $xGet
  ];
}
class Arrow extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance$U,
      create_fragment$U,
      safe_not_equal,
      {
        start: 0,
        end: 1,
        data: 16,
        xIndex: 17,
        yIndex: 18,
        startHandleOffset: 19,
        endHandleOffset: 20,
        startHandle: 21,
        endHandle: 22,
        headAnchor: 2,
        headLength: 23,
        headAngle: 24,
        width: 3,
        color: 4,
        opacity: 5,
        debug: 6
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Arrow",
      options,
      id: create_fragment$U.name
    });
  }
  get start() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set start(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get end() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set end(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xIndex() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xIndex(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yIndex() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yIndex(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startHandleOffset() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set startHandleOffset(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get endHandleOffset() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set endHandleOffset(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startHandle() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set startHandle(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get endHandle() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set endHandle(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headAnchor() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headAnchor(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headLength() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headLength(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get headAngle() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headAngle(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get debug() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set debug(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Circle_svelte_svelte_type_style_lang = "";
const file$O = "src/lib/components/layercake/Circle.svelte";
function create_fragment$T(ctx) {
  let circle;
  let symbol_action;
  let mounted;
  let dispose;
  let circle_levels = [
    ctx[10],
    { cx: ctx[8] },
    { cy: ctx[7] },
    { r: ctx[6] }
  ];
  let circle_data = {};
  for (let i = 0; i < circle_levels.length; i += 1) {
    circle_data = assign(circle_data, circle_levels[i]);
  }
  const block = {
    c: function create() {
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(circle, circle_data);
      toggle_class(circle, "no-outline", ctx[1] === "none");
      set_style(circle, "--_color", ctx[10].fill || ctx[0] || "");
      set_style(circle, "--_outline", ctx[10].stroke || ctx[1] || "");
      set_style(circle, "--_outline-width", ctx[10]["stroke-width"] || ctx[9] || "");
      set_style(circle, "--_opacity", ctx[10].opacity || "");
      toggle_class(circle, "s-xaXKuEj0jS9d", true);
      add_location(circle, file$O, 43, 0, 1054);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      if (!mounted) {
        dispose = action_destroyer(symbol_action = symbol.call(null, circle, ctx[5]));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(circle, circle_data = get_spread_update(circle_levels, [
        dirty & 1024 && ctx2[10],
        dirty & 256 && { cx: ctx2[8] },
        dirty & 128 && { cy: ctx2[7] },
        dirty & 64 && { r: ctx2[6] }
      ]));
      if (symbol_action && is_function(symbol_action.update) && dirty & 32)
        symbol_action.update.call(null, ctx2[5]);
      toggle_class(circle, "no-outline", ctx2[1] === "none");
      set_style(circle, "--_color", ctx2[10].fill || ctx2[0] || "");
      set_style(circle, "--_outline", ctx2[10].stroke || ctx2[1] || "");
      set_style(circle, "--_outline-width", ctx2[10]["stroke-width"] || ctx2[9] || "");
      set_style(circle, "--_opacity", ctx2[10].opacity || "");
      toggle_class(circle, "s-xaXKuEj0jS9d", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(circle);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$T.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$T($$self, $$props, $$invalidate) {
  let outlineWidth;
  let cx;
  let cy;
  let r2;
  const omit_props_names = ["color", "outline", "data", "xIndex", "yIndex", "rIndex", "label", "parent"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $rGet, $$unsubscribe_rGet = noop, $$subscribe_rGet = () => ($$unsubscribe_rGet(), $$unsubscribe_rGet = subscribe(rGet, ($$value) => $$invalidate(17, $rGet = $$value)), rGet);
  let $yGet, $$unsubscribe_yGet = noop, $$subscribe_yGet = () => ($$unsubscribe_yGet(), $$unsubscribe_yGet = subscribe(yGet, ($$value) => $$invalidate(18, $yGet = $$value)), yGet);
  let $xGet, $$unsubscribe_xGet = noop, $$subscribe_xGet = () => ($$unsubscribe_xGet(), $$unsubscribe_xGet = subscribe(xGet, ($$value) => $$invalidate(19, $xGet = $$value)), xGet);
  $$self.$$.on_destroy.push(() => $$unsubscribe_rGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_yGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xGet());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Circle", slots, []);
  let { color = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { xIndex = 0 } = $$props;
  let { yIndex = 0 } = $$props;
  let { rIndex = 0 } = $$props;
  let { label = void 0 } = $$props;
  let { parent = void 0 } = $$props;
  const ctx = getContext("LayerCake");
  let xGet, yGet, rGet;
  let friendly;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$new_props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$new_props)
      $$invalidate(11, data = $$new_props.data);
    if ("xIndex" in $$new_props)
      $$invalidate(12, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$new_props)
      $$invalidate(13, yIndex = $$new_props.yIndex);
    if ("rIndex" in $$new_props)
      $$invalidate(14, rIndex = $$new_props.rIndex);
    if ("label" in $$new_props)
      $$invalidate(15, label = $$new_props.label);
    if ("parent" in $$new_props)
      $$invalidate(16, parent = $$new_props.parent);
  };
  $$self.$capture_state = () => ({
    getContext,
    symbol,
    get,
    color,
    outline,
    data,
    xIndex,
    yIndex,
    rIndex,
    label,
    parent,
    ctx,
    xGet,
    yGet,
    rGet,
    friendly,
    r: r2,
    cy,
    cx,
    outlineWidth,
    $rGet,
    $yGet,
    $xGet
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$props)
      $$invalidate(11, data = $$new_props.data);
    if ("xIndex" in $$props)
      $$invalidate(12, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$props)
      $$invalidate(13, yIndex = $$new_props.yIndex);
    if ("rIndex" in $$props)
      $$invalidate(14, rIndex = $$new_props.rIndex);
    if ("label" in $$props)
      $$invalidate(15, label = $$new_props.label);
    if ("parent" in $$props)
      $$invalidate(16, parent = $$new_props.parent);
    if ("xGet" in $$props)
      $$subscribe_xGet($$invalidate(2, xGet = $$new_props.xGet));
    if ("yGet" in $$props)
      $$subscribe_yGet($$invalidate(3, yGet = $$new_props.yGet));
    if ("rGet" in $$props)
      $$subscribe_rGet($$invalidate(4, rGet = $$new_props.rGet));
    if ("friendly" in $$props)
      $$invalidate(5, friendly = $$new_props.friendly);
    if ("r" in $$props)
      $$invalidate(6, r2 = $$new_props.r);
    if ("cy" in $$props)
      $$invalidate(7, cy = $$new_props.cy);
    if ("cx" in $$props)
      $$invalidate(8, cx = $$new_props.cx);
    if ("outlineWidth" in $$props)
      $$invalidate(9, outlineWidth = $$new_props.outlineWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(9, outlineWidth = $$restProps["outline-width"]);
    $$invalidate(8, cx = $$restProps.cx || 0);
    $$invalidate(7, cy = $$restProps.cy || 0);
    $$invalidate(6, r2 = $$restProps.r || 4);
    if ($$self.$$.dirty & 948224) {
      if (data != void 0 && ctx != void 0) {
        $$subscribe_xGet($$invalidate(2, xGet = ctx.xGet));
        $$subscribe_yGet($$invalidate(3, yGet = ctx.yGet));
        $$subscribe_rGet($$invalidate(4, rGet = ctx.rGet));
        $$invalidate(8, cx = get($xGet, data, xIndex));
        $$invalidate(7, cy = get($yGet, data, yIndex));
        try {
          $$invalidate(6, r2 = get($rGet, data, rIndex));
        } catch (e) {
        }
      }
    }
    if (label != void 0) {
      $$invalidate(5, friendly = {
        id: $$restProps.id,
        type: "point",
        label,
        parentId: parent
      });
    }
  };
  return [
    color,
    outline,
    xGet,
    yGet,
    rGet,
    friendly,
    r2,
    cy,
    cx,
    outlineWidth,
    $$restProps,
    data,
    xIndex,
    yIndex,
    rIndex,
    label,
    parent,
    $rGet,
    $yGet,
    $xGet
  ];
}
class Circle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$T, create_fragment$T, safe_not_equal, {
      color: 0,
      outline: 1,
      data: 11,
      xIndex: 12,
      yIndex: 13,
      rIndex: 14,
      label: 15,
      parent: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Circle",
      options,
      id: create_fragment$T.name
    });
  }
  get color() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xIndex() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xIndex(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yIndex() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yIndex(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rIndex() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rIndex(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Arrow_story_svelte_svelte_type_style_lang = "";
const file$N = "src/lib/components/layercake/Arrow.story.svelte";
function create_default_slot_5$m(ctx) {
  let svg;
  let arrow;
  let current;
  arrow = new Arrow({
    props: {
      start: [ctx[1], ctx[2]],
      end: [ctx[3], ctx[4]],
      headAnchor: ctx[9],
      headLength: ctx[10],
      headAngle: ctx[11],
      debug: ctx[12]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(arrow.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(arrow.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "100");
      attr_dev(svg, "height", "100");
      add_location(svg, file$N, 34, 4, 857);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(arrow, svg, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const arrow_changes = {};
      if (dirty & 6)
        arrow_changes.start = [ctx2[1], ctx2[2]];
      if (dirty & 24)
        arrow_changes.end = [ctx2[3], ctx2[4]];
      if (dirty & 512)
        arrow_changes.headAnchor = ctx2[9];
      if (dirty & 1024)
        arrow_changes.headLength = ctx2[10];
      if (dirty & 2048)
        arrow_changes.headAngle = ctx2[11];
      if (dirty & 4096)
        arrow_changes.debug = ctx2[12];
      arrow.$set(arrow_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(arrow.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(arrow.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(arrow);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$m.name,
    type: "slot",
    source: '(34:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$n(ctx) {
  let svg;
  let arrow;
  let current;
  arrow = new Arrow({
    props: {
      start: [ctx[1], ctx[2]],
      end: [ctx[3], ctx[4]],
      startHandleOffset: [ctx[5], ctx[6]],
      endHandleOffset: [ctx[7], ctx[8]],
      headAnchor: ctx[9],
      headLength: ctx[10],
      headAngle: ctx[11],
      debug: ctx[12]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(arrow.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(arrow.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "100");
      attr_dev(svg, "height", "100");
      add_location(svg, file$N, 47, 4, 1111);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(arrow, svg, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const arrow_changes = {};
      if (dirty & 6)
        arrow_changes.start = [ctx2[1], ctx2[2]];
      if (dirty & 24)
        arrow_changes.end = [ctx2[3], ctx2[4]];
      if (dirty & 96)
        arrow_changes.startHandleOffset = [ctx2[5], ctx2[6]];
      if (dirty & 384)
        arrow_changes.endHandleOffset = [ctx2[7], ctx2[8]];
      if (dirty & 512)
        arrow_changes.headAnchor = ctx2[9];
      if (dirty & 1024)
        arrow_changes.headLength = ctx2[10];
      if (dirty & 2048)
        arrow_changes.headAngle = ctx2[11];
      if (dirty & 4096)
        arrow_changes.debug = ctx2[12];
      arrow.$set(arrow_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(arrow.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(arrow.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(arrow);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$n.name,
    type: "slot",
    source: '(47:2) <Hst.Variant title=\\"Curve\\">',
    ctx
  });
  return block;
}
function create_controls_slot_1$4(ctx) {
  let hst_number0;
  let updating_value;
  let t0;
  let hst_number1;
  let updating_value_1;
  let t1;
  let hst_number2;
  let updating_value_2;
  let t2;
  let hst_number3;
  let updating_value_3;
  let current;
  function hst_number0_value_binding_1(value) {
    ctx[22](value);
  }
  let hst_number0_props = { title: "Start handle offset (x-coord)" };
  if (ctx[5] !== void 0) {
    hst_number0_props.value = ctx[5];
  }
  hst_number0 = new ctx[0].Number({ props: hst_number0_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_number0, "value", hst_number0_value_binding_1, ctx[5]));
  function hst_number1_value_binding_1(value) {
    ctx[23](value);
  }
  let hst_number1_props = { title: "Start handle offset (y-coord)" };
  if (ctx[6] !== void 0) {
    hst_number1_props.value = ctx[6];
  }
  hst_number1 = new ctx[0].Number({ props: hst_number1_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_number1, "value", hst_number1_value_binding_1, ctx[6]));
  function hst_number2_value_binding_1(value) {
    ctx[24](value);
  }
  let hst_number2_props = { title: "End handle offset (x-coord)" };
  if (ctx[7] !== void 0) {
    hst_number2_props.value = ctx[7];
  }
  hst_number2 = new ctx[0].Number({ props: hst_number2_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_number2, "value", hst_number2_value_binding_1, ctx[7]));
  function hst_number3_value_binding_1(value) {
    ctx[25](value);
  }
  let hst_number3_props = { title: "End handle offset (y-coord)" };
  if (ctx[8] !== void 0) {
    hst_number3_props.value = ctx[8];
  }
  hst_number3 = new ctx[0].Number({ props: hst_number3_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_number3, "value", hst_number3_value_binding_1, ctx[8]));
  const block = {
    c: function create() {
      create_component(hst_number0.$$.fragment);
      t0 = space();
      create_component(hst_number1.$$.fragment);
      t1 = space();
      create_component(hst_number2.$$.fragment);
      t2 = space();
      create_component(hst_number3.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_number0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_number1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_number2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_number3.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_number0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_number1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_number2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_number3, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_number0_changes = {};
      if (!updating_value && dirty & 32) {
        updating_value = true;
        hst_number0_changes.value = ctx2[5];
        add_flush_callback(() => updating_value = false);
      }
      hst_number0.$set(hst_number0_changes);
      const hst_number1_changes = {};
      if (!updating_value_1 && dirty & 64) {
        updating_value_1 = true;
        hst_number1_changes.value = ctx2[6];
        add_flush_callback(() => updating_value_1 = false);
      }
      hst_number1.$set(hst_number1_changes);
      const hst_number2_changes = {};
      if (!updating_value_2 && dirty & 128) {
        updating_value_2 = true;
        hst_number2_changes.value = ctx2[7];
        add_flush_callback(() => updating_value_2 = false);
      }
      hst_number2.$set(hst_number2_changes);
      const hst_number3_changes = {};
      if (!updating_value_3 && dirty & 256) {
        updating_value_3 = true;
        hst_number3_changes.value = ctx2[8];
        add_flush_callback(() => updating_value_3 = false);
      }
      hst_number3.$set(hst_number3_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_number0.$$.fragment, local);
      transition_in(hst_number1.$$.fragment, local);
      transition_in(hst_number2.$$.fragment, local);
      transition_in(hst_number3.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_number0.$$.fragment, local);
      transition_out(hst_number1.$$.fragment, local);
      transition_out(hst_number2.$$.fragment, local);
      transition_out(hst_number3.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_number0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_number1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_number2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_number3, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot_1$4.name,
    type: "slot",
    source: '(61:4) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$r(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let circle0;
  let t2;
  let circle1;
  let t3;
  let arrow;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  circle0 = new Circle({
    props: { data: ctx[13][0], r: "5" },
    $$inline: true
  });
  circle1 = new Circle({
    props: { data: ctx[13][1], r: "5" },
    $$inline: true
  });
  arrow = new Arrow({
    props: {
      data: [ctx[13][0], ctx[13][1]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      create_component(circle0.$$.fragment);
      t2 = space();
      create_component(circle1.$$.fragment);
      t3 = space();
      create_component(arrow.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(circle0.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(circle1.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(arrow.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(circle0, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(circle1, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(arrow, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      transition_in(circle0.$$.fragment, local);
      transition_in(circle1.$$.fragment, local);
      transition_in(arrow.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      transition_out(circle0.$$.fragment, local);
      transition_out(circle1.$$.fragment, local);
      transition_out(arrow.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(circle0, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(circle1, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(arrow, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$r.name,
    type: "slot",
    source: "(89:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$s(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$r] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 67108864) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$s.name,
    type: "slot",
    source: '(83:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$v(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[13],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_2$s] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-R29c0YpYqwAK");
      add_location(div, file$N, 81, 4, 2010);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 67108864) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$v.name,
    type: "slot",
    source: '(81:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot$x(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_5$m] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Curve",
      $$slots: {
        controls: [create_controls_slot_1$4],
        default: [create_default_slot_4$n]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_1$v] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 67116574) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 67117054) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 67108864) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$x.name,
    type: "slot",
    source: `(29:0) <Hst.Story   group=\\"layercake\\"   title=\\"Arrow\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_controls_slot$b(ctx) {
  let hst_number0;
  let updating_value;
  let t0;
  let hst_number1;
  let updating_value_1;
  let t1;
  let hst_number2;
  let updating_value_2;
  let t2;
  let hst_number3;
  let updating_value_3;
  let t3;
  let hst_radio;
  let updating_value_4;
  let t4;
  let hst_number4;
  let updating_value_5;
  let t5;
  let hst_number5;
  let updating_value_6;
  let t6;
  let hst_checkbox;
  let updating_value_7;
  let current;
  function hst_number0_value_binding(value) {
    ctx[14](value);
  }
  let hst_number0_props = { title: "Start (x-coord)" };
  if (ctx[1] !== void 0) {
    hst_number0_props.value = ctx[1];
  }
  hst_number0 = new ctx[0].Number({ props: hst_number0_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_number0, "value", hst_number0_value_binding, ctx[1]));
  function hst_number1_value_binding(value) {
    ctx[15](value);
  }
  let hst_number1_props = { title: "Start (y-coord)" };
  if (ctx[2] !== void 0) {
    hst_number1_props.value = ctx[2];
  }
  hst_number1 = new ctx[0].Number({ props: hst_number1_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_number1, "value", hst_number1_value_binding, ctx[2]));
  function hst_number2_value_binding(value) {
    ctx[16](value);
  }
  let hst_number2_props = { title: "End (x-coord)" };
  if (ctx[3] !== void 0) {
    hst_number2_props.value = ctx[3];
  }
  hst_number2 = new ctx[0].Number({ props: hst_number2_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_number2, "value", hst_number2_value_binding, ctx[3]));
  function hst_number3_value_binding(value) {
    ctx[17](value);
  }
  let hst_number3_props = { title: "End (y-coord)" };
  if (ctx[4] !== void 0) {
    hst_number3_props.value = ctx[4];
  }
  hst_number3 = new ctx[0].Number({ props: hst_number3_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_number3, "value", hst_number3_value_binding, ctx[4]));
  function hst_radio_value_binding(value) {
    ctx[18](value);
  }
  let hst_radio_props = {
    title: "Head anchor",
    options: [
      { label: "Start", value: "start" },
      { label: "End", value: "end" },
      { label: "Both", value: "both" }
    ]
  };
  if (ctx[9] !== void 0) {
    hst_radio_props.value = ctx[9];
  }
  hst_radio = new ctx[0].Radio({ props: hst_radio_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_radio, "value", hst_radio_value_binding, ctx[9]));
  function hst_number4_value_binding(value) {
    ctx[19](value);
  }
  let hst_number4_props = { title: "Head length" };
  if (ctx[10] !== void 0) {
    hst_number4_props.value = ctx[10];
  }
  hst_number4 = new ctx[0].Number({ props: hst_number4_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_number4, "value", hst_number4_value_binding, ctx[10]));
  function hst_number5_value_binding(value) {
    ctx[20](value);
  }
  let hst_number5_props = { title: "Head angle" };
  if (ctx[11] !== void 0) {
    hst_number5_props.value = ctx[11];
  }
  hst_number5 = new ctx[0].Number({ props: hst_number5_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_number5, "value", hst_number5_value_binding, ctx[11]));
  function hst_checkbox_value_binding(value) {
    ctx[21](value);
  }
  let hst_checkbox_props = { title: "Debug" };
  if (ctx[12] !== void 0) {
    hst_checkbox_props.value = ctx[12];
  }
  hst_checkbox = new ctx[0].Checkbox({
    props: hst_checkbox_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hst_checkbox, "value", hst_checkbox_value_binding, ctx[12]));
  const block = {
    c: function create() {
      create_component(hst_number0.$$.fragment);
      t0 = space();
      create_component(hst_number1.$$.fragment);
      t1 = space();
      create_component(hst_number2.$$.fragment);
      t2 = space();
      create_component(hst_number3.$$.fragment);
      t3 = space();
      create_component(hst_radio.$$.fragment);
      t4 = space();
      create_component(hst_number4.$$.fragment);
      t5 = space();
      create_component(hst_number5.$$.fragment);
      t6 = space();
      create_component(hst_checkbox.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_number0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_number1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_number2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_number3.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(hst_radio.$$.fragment, nodes);
      t4 = claim_space(nodes);
      claim_component(hst_number4.$$.fragment, nodes);
      t5 = claim_space(nodes);
      claim_component(hst_number5.$$.fragment, nodes);
      t6 = claim_space(nodes);
      claim_component(hst_checkbox.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_number0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_number1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_number2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_number3, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(hst_radio, target, anchor);
      insert_hydration_dev(target, t4, anchor);
      mount_component(hst_number4, target, anchor);
      insert_hydration_dev(target, t5, anchor);
      mount_component(hst_number5, target, anchor);
      insert_hydration_dev(target, t6, anchor);
      mount_component(hst_checkbox, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_number0_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_number0_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_number0.$set(hst_number0_changes);
      const hst_number1_changes = {};
      if (!updating_value_1 && dirty & 4) {
        updating_value_1 = true;
        hst_number1_changes.value = ctx2[2];
        add_flush_callback(() => updating_value_1 = false);
      }
      hst_number1.$set(hst_number1_changes);
      const hst_number2_changes = {};
      if (!updating_value_2 && dirty & 8) {
        updating_value_2 = true;
        hst_number2_changes.value = ctx2[3];
        add_flush_callback(() => updating_value_2 = false);
      }
      hst_number2.$set(hst_number2_changes);
      const hst_number3_changes = {};
      if (!updating_value_3 && dirty & 16) {
        updating_value_3 = true;
        hst_number3_changes.value = ctx2[4];
        add_flush_callback(() => updating_value_3 = false);
      }
      hst_number3.$set(hst_number3_changes);
      const hst_radio_changes = {};
      if (!updating_value_4 && dirty & 512) {
        updating_value_4 = true;
        hst_radio_changes.value = ctx2[9];
        add_flush_callback(() => updating_value_4 = false);
      }
      hst_radio.$set(hst_radio_changes);
      const hst_number4_changes = {};
      if (!updating_value_5 && dirty & 1024) {
        updating_value_5 = true;
        hst_number4_changes.value = ctx2[10];
        add_flush_callback(() => updating_value_5 = false);
      }
      hst_number4.$set(hst_number4_changes);
      const hst_number5_changes = {};
      if (!updating_value_6 && dirty & 2048) {
        updating_value_6 = true;
        hst_number5_changes.value = ctx2[11];
        add_flush_callback(() => updating_value_6 = false);
      }
      hst_number5.$set(hst_number5_changes);
      const hst_checkbox_changes = {};
      if (!updating_value_7 && dirty & 4096) {
        updating_value_7 = true;
        hst_checkbox_changes.value = ctx2[12];
        add_flush_callback(() => updating_value_7 = false);
      }
      hst_checkbox.$set(hst_checkbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_number0.$$.fragment, local);
      transition_in(hst_number1.$$.fragment, local);
      transition_in(hst_number2.$$.fragment, local);
      transition_in(hst_number3.$$.fragment, local);
      transition_in(hst_radio.$$.fragment, local);
      transition_in(hst_number4.$$.fragment, local);
      transition_in(hst_number5.$$.fragment, local);
      transition_in(hst_checkbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_number0.$$.fragment, local);
      transition_out(hst_number1.$$.fragment, local);
      transition_out(hst_number2.$$.fragment, local);
      transition_out(hst_number3.$$.fragment, local);
      transition_out(hst_radio.$$.fragment, local);
      transition_out(hst_number4.$$.fragment, local);
      transition_out(hst_number5.$$.fragment, local);
      transition_out(hst_checkbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_number0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_number1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_number2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_number3, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(hst_radio, detaching);
      if (detaching)
        detach_dev(t4);
      destroy_component(hst_number4, detaching);
      if (detaching)
        detach_dev(t5);
      destroy_component(hst_number5, detaching);
      if (detaching)
        detach_dev(t6);
      destroy_component(hst_checkbox, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot$b.name,
    type: "slot",
    source: '(102:2) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_fragment$S(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "Arrow",
      layout: { type: "grid", width: "100%" },
      $$slots: {
        controls: [create_controls_slot$b],
        default: [create_default_slot$x]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 67117054) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$S.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$S($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Arrow_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  let startX = 0;
  let startY = 50;
  let endX = 80;
  let endY = 50;
  let startHandleOffsetX = 20;
  let startHandleOffsetY = -20;
  let endHandleOffsetX = -20;
  let endHandleOffsetY = -20;
  let headAnchor = "end";
  let headLength;
  let headAngle;
  let debug = false;
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Arrow_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Arrow_story> was created with unknown prop '${key}'`);
  });
  function hst_number0_value_binding(value) {
    startX = value;
    $$invalidate(1, startX);
  }
  function hst_number1_value_binding(value) {
    startY = value;
    $$invalidate(2, startY);
  }
  function hst_number2_value_binding(value) {
    endX = value;
    $$invalidate(3, endX);
  }
  function hst_number3_value_binding(value) {
    endY = value;
    $$invalidate(4, endY);
  }
  function hst_radio_value_binding(value) {
    headAnchor = value;
    $$invalidate(9, headAnchor);
  }
  function hst_number4_value_binding(value) {
    headLength = value;
    $$invalidate(10, headLength);
  }
  function hst_number5_value_binding(value) {
    headAngle = value;
    $$invalidate(11, headAngle);
  }
  function hst_checkbox_value_binding(value) {
    debug = value;
    $$invalidate(12, debug);
  }
  function hst_number0_value_binding_1(value) {
    startHandleOffsetX = value;
    $$invalidate(5, startHandleOffsetX);
  }
  function hst_number1_value_binding_1(value) {
    startHandleOffsetY = value;
    $$invalidate(6, startHandleOffsetY);
  }
  function hst_number2_value_binding_1(value) {
    endHandleOffsetX = value;
    $$invalidate(7, endHandleOffsetX);
  }
  function hst_number3_value_binding_1(value) {
    endHandleOffsetY = value;
    $$invalidate(8, endHandleOffsetY);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    Arrow,
    Circle,
    AxisX,
    AxisY,
    data,
    startX,
    startY,
    endX,
    endY,
    startHandleOffsetX,
    startHandleOffsetY,
    endHandleOffsetX,
    endHandleOffsetY,
    headAnchor,
    headLength,
    headAngle,
    debug
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("startX" in $$props2)
      $$invalidate(1, startX = $$props2.startX);
    if ("startY" in $$props2)
      $$invalidate(2, startY = $$props2.startY);
    if ("endX" in $$props2)
      $$invalidate(3, endX = $$props2.endX);
    if ("endY" in $$props2)
      $$invalidate(4, endY = $$props2.endY);
    if ("startHandleOffsetX" in $$props2)
      $$invalidate(5, startHandleOffsetX = $$props2.startHandleOffsetX);
    if ("startHandleOffsetY" in $$props2)
      $$invalidate(6, startHandleOffsetY = $$props2.startHandleOffsetY);
    if ("endHandleOffsetX" in $$props2)
      $$invalidate(7, endHandleOffsetX = $$props2.endHandleOffsetX);
    if ("endHandleOffsetY" in $$props2)
      $$invalidate(8, endHandleOffsetY = $$props2.endHandleOffsetY);
    if ("headAnchor" in $$props2)
      $$invalidate(9, headAnchor = $$props2.headAnchor);
    if ("headLength" in $$props2)
      $$invalidate(10, headLength = $$props2.headLength);
    if ("headAngle" in $$props2)
      $$invalidate(11, headAngle = $$props2.headAngle);
    if ("debug" in $$props2)
      $$invalidate(12, debug = $$props2.debug);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    startX,
    startY,
    endX,
    endY,
    startHandleOffsetX,
    startHandleOffsetY,
    endHandleOffsetX,
    endHandleOffsetY,
    headAnchor,
    headLength,
    headAngle,
    debug,
    data,
    hst_number0_value_binding,
    hst_number1_value_binding,
    hst_number2_value_binding,
    hst_number3_value_binding,
    hst_radio_value_binding,
    hst_number4_value_binding,
    hst_number5_value_binding,
    hst_checkbox_value_binding,
    hst_number0_value_binding_1,
    hst_number1_value_binding_1,
    hst_number2_value_binding_1,
    hst_number3_value_binding_1
  ];
}
class Arrow_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$S, create_fragment$S, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Arrow_story",
      options,
      id: create_fragment$S.name
    });
  }
  get Hst() {
    throw new Error("<Arrow_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Arrow_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
function fallback_block$c(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Label missing");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Label missing");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$c.name,
    type: "fallback",
    source: "(17:8) Label missing",
    ctx
  });
  return block;
}
function create_default_slot$w(ctx) {
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  const default_slot_or_fallback = default_slot || fallback_block$c(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$w.name,
    type: "slot",
    source: `(9:0) <SvgText   x={$width}   y={$height}   yOffset={$padding.bottom}   xAlign=\\"right\\"   {...$$restProps}   class=\\"label {$$restProps.class || ''}\\" >`,
    ctx
  });
  return block;
}
function create_fragment$R(ctx) {
  let svgtext;
  let current;
  const svgtext_spread_levels = [
    { x: ctx[0] },
    { y: ctx[1] },
    { yOffset: ctx[2].bottom },
    { xAlign: "right" },
    ctx[6],
    {
      class: "label " + (ctx[6].class || "")
    }
  ];
  let svgtext_props = {
    $$slots: { default: [create_default_slot$w] },
    $$scope: { ctx }
  };
  for (let i = 0; i < svgtext_spread_levels.length; i += 1) {
    svgtext_props = assign(svgtext_props, svgtext_spread_levels[i]);
  }
  svgtext = new SvgText({ props: svgtext_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(svgtext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svgtext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svgtext, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const svgtext_changes = dirty & 71 ? get_spread_update(svgtext_spread_levels, [
        dirty & 1 && { x: ctx2[0] },
        dirty & 2 && { y: ctx2[1] },
        dirty & 4 && { yOffset: ctx2[2].bottom },
        svgtext_spread_levels[3],
        dirty & 64 && get_spread_object(ctx2[6]),
        dirty & 64 && {
          class: "label " + (ctx2[6].class || "")
        }
      ]) : {};
      if (dirty & 256) {
        svgtext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext.$set(svgtext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svgtext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svgtext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svgtext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$R.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$R($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $width;
  let $height;
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AxisLabelX", slots, ["default"]);
  const { width, height, padding } = getContext("LayerCake");
  validate_store(width, "width");
  component_subscribe($$self, width, (value) => $$invalidate(0, $width = value));
  validate_store(height, "height");
  component_subscribe($$self, height, (value) => $$invalidate(1, $height = value));
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(2, $padding = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    SvgText,
    width,
    height,
    padding,
    $width,
    $height,
    $padding
  });
  return [$width, $height, $padding, width, height, padding, $$restProps, slots, $$scope];
}
class AxisLabelX extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$R, create_fragment$R, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AxisLabelX",
      options,
      id: create_fragment$R.name
    });
  }
}
const AxisLabelX_story_svelte_svelte_type_style_lang = "";
const file$M = "src/lib/components/layercake/AxisLabelX.story.svelte";
function create_default_slot_3$q(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$q.name,
    type: "slot",
    source: "(30:8) <AxisLabelX>",
    ctx
  });
  return block;
}
function create_default_slot_2$r(ctx) {
  let axisx;
  let t;
  let axislabelx;
  let current;
  axisx = new AxisX({ $$inline: true });
  axislabelx = new AxisLabelX({
    props: {
      $$slots: { default: [create_default_slot_3$q] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t = space();
      create_component(axislabelx.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(axislabelx.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(axislabelx, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const axislabelx_changes = {};
      if (dirty & 18) {
        axislabelx_changes.$$scope = { dirty, ctx: ctx2 };
      }
      axislabelx.$set(axislabelx_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axislabelx.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axislabelx.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(axislabelx, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$r.name,
    type: "slot",
    source: "(28:6) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_1$u(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_2$r] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 18) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$u.name,
    type: "slot",
    source: '(22:4) <LayerCake       {data}       padding={{ top: 6, right: 8, bottom: 38, left: 24 }}       x=\\"x\\"       y=\\"y\\"     >',
    ctx
  });
  return block;
}
function create_default_slot$v(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { top: 6, right: 8, bottom: 38, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_1$u] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s--ekVyrMjE8Bh");
      add_location(div, file$M, 20, 2, 488);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 18) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$v.name,
    type: "slot",
    source: `(16:0) <Hst.Story   group=\\"layercake\\"   title=\\"AxisLabelX\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_controls_slot$a(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding(value) {
    ctx[3](value);
  }
  let hst_text_props = { title: "Label" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot$a.name,
    type: "slot",
    source: '(35:2) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_fragment$Q(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "AxisLabelX",
      layout: { type: "grid", width: "100%" },
      $$slots: {
        controls: [create_controls_slot$a],
        default: [create_default_slot$v]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 18) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$Q.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$Q($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AxisLabelX_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  let label = "X-Axis";
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<AxisLabelX_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AxisLabelX_story> was created with unknown prop '${key}'`);
  });
  function hst_text_value_binding(value) {
    label = value;
    $$invalidate(1, label);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    AxisLabelX,
    AxisX,
    data,
    label
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, label, data, hst_text_value_binding];
}
class AxisLabelX_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AxisLabelX_story",
      options,
      id: create_fragment$Q.name
    });
  }
  get Hst() {
    throw new Error("<AxisLabelX_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<AxisLabelX_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
function fallback_block$b(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Label missing");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Label missing");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$b.name,
    type: "fallback",
    source: "(17:8) Label missing",
    ctx
  });
  return block;
}
function create_default_slot$u(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  const default_slot_or_fallback = default_slot || fallback_block$b(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$u.name,
    type: "slot",
    source: `(9:0) <SvgText   xOffset={-$padding.left}   yOffset={-$padding.top}   xAlign=\\"left\\"   yAlign=\\"top\\"   {...$$restProps}   class=\\"label {$$restProps.class || ''}\\" >`,
    ctx
  });
  return block;
}
function create_fragment$P(ctx) {
  let svgtext;
  let current;
  const svgtext_spread_levels = [
    { xOffset: -ctx[0].left },
    { yOffset: -ctx[0].top },
    { xAlign: "left" },
    { yAlign: "top" },
    ctx[2],
    {
      class: "label " + (ctx[2].class || "")
    }
  ];
  let svgtext_props = {
    $$slots: { default: [create_default_slot$u] },
    $$scope: { ctx }
  };
  for (let i = 0; i < svgtext_spread_levels.length; i += 1) {
    svgtext_props = assign(svgtext_props, svgtext_spread_levels[i]);
  }
  svgtext = new SvgText({ props: svgtext_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(svgtext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svgtext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svgtext, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const svgtext_changes = dirty & 5 ? get_spread_update(svgtext_spread_levels, [
        dirty & 1 && { xOffset: -ctx2[0].left },
        dirty & 1 && { yOffset: -ctx2[0].top },
        svgtext_spread_levels[2],
        svgtext_spread_levels[3],
        dirty & 4 && get_spread_object(ctx2[2]),
        dirty & 4 && {
          class: "label " + (ctx2[2].class || "")
        }
      ]) : {};
      if (dirty & 16) {
        svgtext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext.$set(svgtext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svgtext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svgtext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svgtext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$P.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$P($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $padding;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AxisLabelY", slots, ["default"]);
  const { padding } = getContext("LayerCake");
  validate_store(padding, "padding");
  component_subscribe($$self, padding, (value) => $$invalidate(0, $padding = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ getContext, SvgText, padding, $padding });
  return [$padding, padding, $$restProps, slots, $$scope];
}
class AxisLabelY extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$P, create_fragment$P, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AxisLabelY",
      options,
      id: create_fragment$P.name
    });
  }
}
const AxisLabelY_story_svelte_svelte_type_style_lang = "";
const file$L = "src/lib/components/layercake/AxisLabelY.story.svelte";
function create_default_slot_3$p(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$p.name,
    type: "slot",
    source: "(30:8) <AxisLabelY>",
    ctx
  });
  return block;
}
function create_default_slot_2$q(ctx) {
  let axisy;
  let t;
  let axislabely;
  let current;
  axisy = new AxisY({ $$inline: true });
  axislabely = new AxisLabelY({
    props: {
      $$slots: { default: [create_default_slot_3$p] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisy.$$.fragment);
      t = space();
      create_component(axislabely.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisy.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(axislabely.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(axislabely, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const axislabely_changes = {};
      if (dirty & 18) {
        axislabely_changes.$$scope = { dirty, ctx: ctx2 };
      }
      axislabely.$set(axislabely_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisy.$$.fragment, local);
      transition_in(axislabely.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisy.$$.fragment, local);
      transition_out(axislabely.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(axislabely, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$q.name,
    type: "slot",
    source: "(28:6) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_1$t(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_2$q] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 18) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$t.name,
    type: "slot",
    source: '(22:4) <LayerCake       {data}       padding={{ top: 28, right: 8, bottom: 24, left: 24 }}       x=\\"x\\"       y=\\"y\\"     >',
    ctx
  });
  return block;
}
function create_default_slot$t(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { top: 28, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_1$t] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-Rpp17ZT5IT5w");
      add_location(div, file$L, 20, 2, 488);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 18) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$t.name,
    type: "slot",
    source: `(16:0) <Hst.Story   group=\\"layercake\\"   title=\\"AxisLabelY\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_controls_slot$9(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding(value) {
    ctx[3](value);
  }
  let hst_text_props = { title: "Label" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot$9.name,
    type: "slot",
    source: '(35:2) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_fragment$O(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "AxisLabelY",
      layout: { type: "grid", width: "100%" },
      $$slots: {
        controls: [create_controls_slot$9],
        default: [create_default_slot$t]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 18) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$O.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$O($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AxisLabelY_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  let label = "Y-Axis";
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<AxisLabelY_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AxisLabelY_story> was created with unknown prop '${key}'`);
  });
  function hst_text_value_binding(value) {
    label = value;
    $$invalidate(1, label);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    AxisLabelY,
    AxisY,
    data,
    label
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, label, data, hst_text_value_binding];
}
class AxisLabelY_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$O, create_fragment$O, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AxisLabelY_story",
      options,
      id: create_fragment$O.name
    });
  }
  get Hst() {
    throw new Error("<AxisLabelY_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<AxisLabelY_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const AxisX_story_svelte_svelte_type_style_lang = "";
const file$K = "src/lib/components/layercake/AxisX.story.svelte";
function create_default_slot_6$c(ctx) {
  let axisx;
  let current;
  axisx = new AxisX({
    props: {
      showDomainLine: ctx[1],
      showGridLines: ctx[2],
      showTickLines: ctx[3]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const axisx_changes = {};
      if (dirty & 2)
        axisx_changes.showDomainLine = ctx2[1];
      if (dirty & 4)
        axisx_changes.showGridLines = ctx2[2];
      if (dirty & 8)
        axisx_changes.showTickLines = ctx2[3];
      axisx.$set(axisx_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$c.name,
    type: "slot",
    source: "(30:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_5$l(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_6$c] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 270) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$l.name,
    type: "slot",
    source: '(24:6) <LayerCake         {data}         padding={{ top: 24, right: 12, bottom: 24, left: 12 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_4$m(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[4],
      padding: { top: 24, right: 12, bottom: 24, left: 12 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_5$l] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-3neMMq9evH7X");
      add_location(div, file$K, 22, 4, 503);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 270) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$m.name,
    type: "slot",
    source: '(22:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$o(ctx) {
  let axisx;
  let current;
  axisx = new AxisX({
    props: {
      showDomainLine: ctx[1],
      showGridLines: ctx[2],
      showTickLines: ctx[3],
      onTop: true
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const axisx_changes = {};
      if (dirty & 2)
        axisx_changes.showDomainLine = ctx2[1];
      if (dirty & 4)
        axisx_changes.showGridLines = ctx2[2];
      if (dirty & 8)
        axisx_changes.showTickLines = ctx2[3];
      axisx.$set(axisx_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$o.name,
    type: "slot",
    source: "(45:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$p(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$o] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 270) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$p.name,
    type: "slot",
    source: '(39:6) <LayerCake         {data}         padding={{ top: 24, right: 12, bottom: 24, left: 12 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$s(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[4],
      padding: { top: 24, right: 12, bottom: 24, left: 12 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_2$p] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-3neMMq9evH7X");
      add_location(div, file$K, 37, 4, 839);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 270) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$s.name,
    type: "slot",
    source: '(37:2) <Hst.Variant title=\\"On top\\">',
    ctx
  });
  return block;
}
function create_default_slot$s(ctx) {
  let hst_variant0;
  let t;
  let hst_variant1;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_4$m] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "On top",
      $$slots: { default: [create_default_slot_1$s] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t = space();
      create_component(hst_variant1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(hst_variant1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 270) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 270) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(hst_variant1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$s.name,
    type: "slot",
    source: `(17:0) <Hst.Story   group=\\"layercake\\"   title=\\"AxisX\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_controls_slot$8(ctx) {
  let hst_checkbox0;
  let updating_value;
  let t0;
  let hst_checkbox1;
  let updating_value_1;
  let t1;
  let hst_checkbox2;
  let updating_value_2;
  let current;
  function hst_checkbox0_value_binding(value) {
    ctx[5](value);
  }
  let hst_checkbox0_props = { title: "Show domain line" };
  if (ctx[1] !== void 0) {
    hst_checkbox0_props.value = ctx[1];
  }
  hst_checkbox0 = new ctx[0].Checkbox({
    props: hst_checkbox0_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hst_checkbox0, "value", hst_checkbox0_value_binding, ctx[1]));
  function hst_checkbox1_value_binding(value) {
    ctx[6](value);
  }
  let hst_checkbox1_props = { title: "Show grid lines" };
  if (ctx[2] !== void 0) {
    hst_checkbox1_props.value = ctx[2];
  }
  hst_checkbox1 = new ctx[0].Checkbox({
    props: hst_checkbox1_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hst_checkbox1, "value", hst_checkbox1_value_binding, ctx[2]));
  function hst_checkbox2_value_binding(value) {
    ctx[7](value);
  }
  let hst_checkbox2_props = { title: "Show tick lines" };
  if (ctx[3] !== void 0) {
    hst_checkbox2_props.value = ctx[3];
  }
  hst_checkbox2 = new ctx[0].Checkbox({
    props: hst_checkbox2_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hst_checkbox2, "value", hst_checkbox2_value_binding, ctx[3]));
  const block = {
    c: function create() {
      create_component(hst_checkbox0.$$.fragment);
      t0 = space();
      create_component(hst_checkbox1.$$.fragment);
      t1 = space();
      create_component(hst_checkbox2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_checkbox0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_checkbox1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_checkbox2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_checkbox0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_checkbox1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_checkbox2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_checkbox0_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_checkbox0_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_checkbox0.$set(hst_checkbox0_changes);
      const hst_checkbox1_changes = {};
      if (!updating_value_1 && dirty & 4) {
        updating_value_1 = true;
        hst_checkbox1_changes.value = ctx2[2];
        add_flush_callback(() => updating_value_1 = false);
      }
      hst_checkbox1.$set(hst_checkbox1_changes);
      const hst_checkbox2_changes = {};
      if (!updating_value_2 && dirty & 8) {
        updating_value_2 = true;
        hst_checkbox2_changes.value = ctx2[3];
        add_flush_callback(() => updating_value_2 = false);
      }
      hst_checkbox2.$set(hst_checkbox2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_checkbox0.$$.fragment, local);
      transition_in(hst_checkbox1.$$.fragment, local);
      transition_in(hst_checkbox2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_checkbox0.$$.fragment, local);
      transition_out(hst_checkbox1.$$.fragment, local);
      transition_out(hst_checkbox2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_checkbox0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_checkbox1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_checkbox2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot$8.name,
    type: "slot",
    source: '(52:2) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_fragment$N(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "AxisX",
      layout: { type: "grid", width: "100%" },
      $$slots: {
        controls: [create_controls_slot$8],
        default: [create_default_slot$s]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 270) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$N.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$N($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AxisX_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  let showDomainLine = true;
  let showGridLines = false;
  let showTickLines = true;
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<AxisX_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AxisX_story> was created with unknown prop '${key}'`);
  });
  function hst_checkbox0_value_binding(value) {
    showDomainLine = value;
    $$invalidate(1, showDomainLine);
  }
  function hst_checkbox1_value_binding(value) {
    showGridLines = value;
    $$invalidate(2, showGridLines);
  }
  function hst_checkbox2_value_binding(value) {
    showTickLines = value;
    $$invalidate(3, showTickLines);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    AxisX,
    data,
    showDomainLine,
    showGridLines,
    showTickLines
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("showDomainLine" in $$props2)
      $$invalidate(1, showDomainLine = $$props2.showDomainLine);
    if ("showGridLines" in $$props2)
      $$invalidate(2, showGridLines = $$props2.showGridLines);
    if ("showTickLines" in $$props2)
      $$invalidate(3, showTickLines = $$props2.showTickLines);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    showDomainLine,
    showGridLines,
    showTickLines,
    data,
    hst_checkbox0_value_binding,
    hst_checkbox1_value_binding,
    hst_checkbox2_value_binding
  ];
}
class AxisX_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$N, create_fragment$N, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AxisX_story",
      options,
      id: create_fragment$N.name
    });
  }
  get Hst() {
    throw new Error("<AxisX_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<AxisX_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const AxisY_story_svelte_svelte_type_style_lang = "";
const file$J = "src/lib/components/layercake/AxisY.story.svelte";
function create_default_slot_2$o(ctx) {
  let axisy;
  let current;
  axisy = new AxisY({
    props: {
      showDomainLine: ctx[1],
      showGridLines: ctx[2],
      showTickLines: ctx[3]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisy.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisy.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisy, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const axisy_changes = {};
      if (dirty & 2)
        axisy_changes.showDomainLine = ctx2[1];
      if (dirty & 4)
        axisy_changes.showGridLines = ctx2[2];
      if (dirty & 8)
        axisy_changes.showTickLines = ctx2[3];
      axisy.$set(axisy_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisy.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisy.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisy, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$o.name,
    type: "slot",
    source: "(29:6) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_1$r(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_2$o] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 270) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$r.name,
    type: "slot",
    source: '(23:4) <LayerCake       {data}       padding={{ top: 24, right: 12, bottom: 24, left: 24 }}       x=\\"x\\"       y=\\"y\\"     >',
    ctx
  });
  return block;
}
function create_default_slot$r(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[4],
      padding: { top: 24, right: 12, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_1$r] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-MHmsU0JJoRzH");
      add_location(div, file$J, 21, 2, 472);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 270) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$r.name,
    type: "slot",
    source: `(17:0) <Hst.Story   group=\\"layercake\\"   title=\\"AxisY\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_controls_slot$7(ctx) {
  let hst_checkbox0;
  let updating_value;
  let t0;
  let hst_checkbox1;
  let updating_value_1;
  let t1;
  let hst_checkbox2;
  let updating_value_2;
  let current;
  function hst_checkbox0_value_binding(value) {
    ctx[5](value);
  }
  let hst_checkbox0_props = { title: "Show domain line" };
  if (ctx[1] !== void 0) {
    hst_checkbox0_props.value = ctx[1];
  }
  hst_checkbox0 = new ctx[0].Checkbox({
    props: hst_checkbox0_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hst_checkbox0, "value", hst_checkbox0_value_binding, ctx[1]));
  function hst_checkbox1_value_binding(value) {
    ctx[6](value);
  }
  let hst_checkbox1_props = { title: "Show grid lines" };
  if (ctx[2] !== void 0) {
    hst_checkbox1_props.value = ctx[2];
  }
  hst_checkbox1 = new ctx[0].Checkbox({
    props: hst_checkbox1_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hst_checkbox1, "value", hst_checkbox1_value_binding, ctx[2]));
  function hst_checkbox2_value_binding(value) {
    ctx[7](value);
  }
  let hst_checkbox2_props = { title: "Show tick lines" };
  if (ctx[3] !== void 0) {
    hst_checkbox2_props.value = ctx[3];
  }
  hst_checkbox2 = new ctx[0].Checkbox({
    props: hst_checkbox2_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hst_checkbox2, "value", hst_checkbox2_value_binding, ctx[3]));
  const block = {
    c: function create() {
      create_component(hst_checkbox0.$$.fragment);
      t0 = space();
      create_component(hst_checkbox1.$$.fragment);
      t1 = space();
      create_component(hst_checkbox2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_checkbox0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_checkbox1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_checkbox2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_checkbox0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_checkbox1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_checkbox2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_checkbox0_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_checkbox0_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_checkbox0.$set(hst_checkbox0_changes);
      const hst_checkbox1_changes = {};
      if (!updating_value_1 && dirty & 4) {
        updating_value_1 = true;
        hst_checkbox1_changes.value = ctx2[2];
        add_flush_callback(() => updating_value_1 = false);
      }
      hst_checkbox1.$set(hst_checkbox1_changes);
      const hst_checkbox2_changes = {};
      if (!updating_value_2 && dirty & 8) {
        updating_value_2 = true;
        hst_checkbox2_changes.value = ctx2[3];
        add_flush_callback(() => updating_value_2 = false);
      }
      hst_checkbox2.$set(hst_checkbox2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_checkbox0.$$.fragment, local);
      transition_in(hst_checkbox1.$$.fragment, local);
      transition_in(hst_checkbox2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_checkbox0.$$.fragment, local);
      transition_out(hst_checkbox1.$$.fragment, local);
      transition_out(hst_checkbox2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_checkbox0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_checkbox1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_checkbox2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot$7.name,
    type: "slot",
    source: '(35:2) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_fragment$M(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "AxisY",
      layout: { type: "grid", width: "100%" },
      $$slots: {
        controls: [create_controls_slot$7],
        default: [create_default_slot$r]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 270) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$M.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$M($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AxisY_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  let showDomainLine = false;
  let showGridLines = true;
  let showTickLines = false;
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<AxisY_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AxisY_story> was created with unknown prop '${key}'`);
  });
  function hst_checkbox0_value_binding(value) {
    showDomainLine = value;
    $$invalidate(1, showDomainLine);
  }
  function hst_checkbox1_value_binding(value) {
    showGridLines = value;
    $$invalidate(2, showGridLines);
  }
  function hst_checkbox2_value_binding(value) {
    showTickLines = value;
    $$invalidate(3, showTickLines);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    AxisY,
    data,
    showDomainLine,
    showGridLines,
    showTickLines
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("showDomainLine" in $$props2)
      $$invalidate(1, showDomainLine = $$props2.showDomainLine);
    if ("showGridLines" in $$props2)
      $$invalidate(2, showGridLines = $$props2.showGridLines);
    if ("showTickLines" in $$props2)
      $$invalidate(3, showTickLines = $$props2.showTickLines);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    showDomainLine,
    showGridLines,
    showTickLines,
    data,
    hst_checkbox0_value_binding,
    hst_checkbox1_value_binding,
    hst_checkbox2_value_binding
  ];
}
class AxisY_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$M, create_fragment$M, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AxisY_story",
      options,
      id: create_fragment$M.name
    });
  }
  get Hst() {
    throw new Error("<AxisY_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<AxisY_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
function getHighestContrastColor(color, options = ["black", "white"]) {
  const contrastList = options.map((o) => chroma.contrast(color, o));
  const index = maxIndex(contrastList);
  return options[index];
}
function fuzzysearch(query, data, { key, limit = 5 } = {}) {
  const results = fuzzysort.go(query, data, { key, limit });
  const suggestions = [];
  for (let i = 0; i < results.length; i++) {
    const result = results[i];
    suggestions.push(key ? result.obj : result.target);
  }
  return suggestions;
}
const bpXs = 370;
const bpSm = 480;
const bpMd = 640;
const sPx1 = 4;
const sPx2 = 8;
const sPx3 = 12;
const sPx4 = 16;
const sPx5 = 24;
const sPx6 = 32;
const sPx7 = 48;
const sPx8 = 64;
const sRem1 = 0.25;
const sRem2 = 0.5;
const sRem3 = 0.75;
const sRem4 = 1;
const sRem5 = 1.5;
const sRem6 = 2;
const sRem7 = 3;
const sRem8 = 4;
const fontSizeXs = 0.75;
const fontSizeSm = 0.875;
const fontSizeBase = 1;
const fontSizeLg = 1.125;
const lineHeightTight = 1.15;
const lineHeightSnug = 1.35;
const lineHeightNormal = 1.5;
const fontWeightRegular = 400;
const fontWeightSemiBold = 500;
const fontWeightBold = 700;
const fontWeightBlack = 900;
const cRbbRed = "#E61A1A";
const cRbbBurgundy = "#821423";
const cRbbNeutral = "#DFDED2";
const cRbbBeige100 = "#DFDED2";
const cRbbBeige200 = "#AAA493";
const cRbbBeige300 = "#585858";
const cRbbBeige400 = "#333333";
const cRbbBeige500 = "#000000";
const cBlue100 = "#D6E6F5";
const cBlue200 = "#8CC3F2";
const cBlue300 = "#4AA0D9";
const cBlue400 = "#1479B8";
const cBlue500 = "#005580";
const cTurquoise100 = "#D3EEEC";
const cTurquoise200 = "#9DD8D6";
const cTurquoise300 = "#5FBABA";
const cTurquoise400 = "#399DA2";
const cTurquoise500 = "#1F767A";
const cGreen100 = "#D1F0D9";
const cGreen200 = "#98CDAA";
const cGreen300 = "#6DAC87";
const cGreen400 = "#4F8D6E";
const cGreen500 = "#396A56";
const cBeige100 = "#EAEAEA";
const cBeige200 = "#DFDED2";
const cBeige300 = "#AAA493";
const cBeige400 = "#7B746B";
const cBeige500 = "#333333";
const cPurple100 = "#D4D4ED";
const cPurple200 = "#AFA7D9";
const cPurple300 = "#8C79C3";
const cPurple400 = "#7050A5";
const cPurple500 = "#4C3562";
const cRed100 = "#F3DACE";
const cRed200 = "#F0A385";
const cRed300 = "#EA693E";
const cRed400 = "#BD3C28";
const cRed500 = "#821423";
const cYellow100 = "#FBEDD0";
const cYellow200 = "#F9C986";
const cYellow300 = "#F2A335";
const cYellow400 = "#D6841F";
const cYellow500 = "#AC6115";
const cTurquoiseBlue100 = "#DFDED2";
const cTurquoiseBlue200 = "#98C9CD";
const cTurquoiseBlue300 = "#70ADC1";
const cTurquoiseBlue400 = "#4A8EAC";
const cTurquoiseBlue500 = "#2C7396";
const cTurquoiseBlue600 = "#005580";
const cTurquoiseBlue700 = "#00334D";
const cYellowGreen100 = "#DFDED2";
const cYellowGreen200 = "#D9C68C";
const cYellowGreen300 = "#ADB082";
const cYellowGreen400 = "#7E9975";
const cYellowGreen500 = "#558665";
const cYellowGreen600 = "#396A56";
const cYellowGreen700 = "#1F4736";
const cRedOrangePurple100 = "#DFDED2";
const cRedOrangePurple200 = "#F0B375";
const cRedOrangePurple300 = "#DE9364";
const cRedOrangePurple400 = "#C67053";
const cRedOrangePurple500 = "#B0574F";
const cRedOrangePurple600 = "#894351";
const cRedOrangePurple700 = "#4C3562";
const cRedToBlue100 = "#821423";
const cRedToBlue200 = "#BD3C28";
const cRedToBlue300 = "#EA693E";
const cRedToBlue400 = "#F0A385";
const cRedToBlue500 = "#DFDED2";
const cRedToBlue600 = "#8CC3F2";
const cRedToBlue700 = "#4AA0D9";
const cRedToBlue800 = "#1479B8";
const cRedToBlue900 = "#005580";
const cYellowToTurquoise100 = "#AC6115";
const cYellowToTurquoise200 = "#D6841F";
const cYellowToTurquoise300 = "#F2A335";
const cYellowToTurquoise400 = "#F9C986";
const cYellowToTurquoise500 = "#DFDED2";
const cYellowToTurquoise600 = "#9DD8D6";
const cYellowToTurquoise700 = "#5FBABA";
const cYellowToTurquoise800 = "#399DA2";
const cYellowToTurquoise900 = "#1F767A";
const cMaleToFemale100 = "#1F767A";
const cMaleToFemale200 = "#399DA2";
const cMaleToFemale300 = "#5FBABA";
const cMaleToFemale400 = "#9DD8D6";
const cMaleToFemale500 = "#DFDED2";
const cMaleToFemale600 = "#AFA7D9";
const cMaleToFemale700 = "#8C79C3";
const cMaleToFemale800 = "#7050A5";
const cMaleToFemale900 = "#4C3562";
const cCategoryBlue = "#4AA0D9";
const cCategoryTurquoise = "#1F767A";
const cCategoryGreen = "#98CDAA";
const cCategoryBeige = "#AAA493";
const cCategoryYellow = "#F2A335";
const cCategoryRed = "#EA693E";
const cCategoryPurple = "#4C3562";
const cUiBlack = "#000000";
const cUiGray100 = "#EBEBEB";
const cUiGray200 = "#C0C0C0";
const cUiGray300 = "#8C8C8C";
const cUiGray400 = "#595959";
const cUiGray500 = "#000000";
const cUiAccentBlue = "#1479B8";
const cUiAccentBlack = "#333333";
const cUiAccentTurquoise = "#1F767A";
const cUiAccentPurple = "#7050A5";
const cUiAccentYellow = "#AC6115";
const cUiAccentRed = "#E61A1A";
const cGenderMale = "#5FBABA";
const cGenderFemale = "#7050A5";
const cGenderDiverse = "#F9C986";
const cChangeDecrease = "#4AA0D9";
const cChangeNeutral = "#DFDED2";
const cChangeIncrease = "#F2A335";
const cQualityNegative = "#BD3C28";
const cQualityPositive = "#98CDAA";
const cPartyCdu = "#000000";
const cPartySpd = "#E61A1A";
const cPartyLinke = "#AA0967";
const cPartyGruene = "#29A35C";
const cPartyAfd = "#1479B8";
const cPartyFdp = "#F3D124";
const cPartySonstige = "#AAA493";
const tokens = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bpMd,
  bpSm,
  bpXs,
  cBeige100,
  cBeige200,
  cBeige300,
  cBeige400,
  cBeige500,
  cBlue100,
  cBlue200,
  cBlue300,
  cBlue400,
  cBlue500,
  cCategoryBeige,
  cCategoryBlue,
  cCategoryGreen,
  cCategoryPurple,
  cCategoryRed,
  cCategoryTurquoise,
  cCategoryYellow,
  cChangeDecrease,
  cChangeIncrease,
  cChangeNeutral,
  cGenderDiverse,
  cGenderFemale,
  cGenderMale,
  cGreen100,
  cGreen200,
  cGreen300,
  cGreen400,
  cGreen500,
  cMaleToFemale100,
  cMaleToFemale200,
  cMaleToFemale300,
  cMaleToFemale400,
  cMaleToFemale500,
  cMaleToFemale600,
  cMaleToFemale700,
  cMaleToFemale800,
  cMaleToFemale900,
  cPartyAfd,
  cPartyCdu,
  cPartyFdp,
  cPartyGruene,
  cPartyLinke,
  cPartySonstige,
  cPartySpd,
  cPurple100,
  cPurple200,
  cPurple300,
  cPurple400,
  cPurple500,
  cQualityNegative,
  cQualityPositive,
  cRbbBeige100,
  cRbbBeige200,
  cRbbBeige300,
  cRbbBeige400,
  cRbbBeige500,
  cRbbBurgundy,
  cRbbNeutral,
  cRbbRed,
  cRed100,
  cRed200,
  cRed300,
  cRed400,
  cRed500,
  cRedOrangePurple100,
  cRedOrangePurple200,
  cRedOrangePurple300,
  cRedOrangePurple400,
  cRedOrangePurple500,
  cRedOrangePurple600,
  cRedOrangePurple700,
  cRedToBlue100,
  cRedToBlue200,
  cRedToBlue300,
  cRedToBlue400,
  cRedToBlue500,
  cRedToBlue600,
  cRedToBlue700,
  cRedToBlue800,
  cRedToBlue900,
  cTurquoise100,
  cTurquoise200,
  cTurquoise300,
  cTurquoise400,
  cTurquoise500,
  cTurquoiseBlue100,
  cTurquoiseBlue200,
  cTurquoiseBlue300,
  cTurquoiseBlue400,
  cTurquoiseBlue500,
  cTurquoiseBlue600,
  cTurquoiseBlue700,
  cUiAccentBlack,
  cUiAccentBlue,
  cUiAccentPurple,
  cUiAccentRed,
  cUiAccentTurquoise,
  cUiAccentYellow,
  cUiBlack,
  cUiGray100,
  cUiGray200,
  cUiGray300,
  cUiGray400,
  cUiGray500,
  cYellow100,
  cYellow200,
  cYellow300,
  cYellow400,
  cYellow500,
  cYellowGreen100,
  cYellowGreen200,
  cYellowGreen300,
  cYellowGreen400,
  cYellowGreen500,
  cYellowGreen600,
  cYellowGreen700,
  cYellowToTurquoise100,
  cYellowToTurquoise200,
  cYellowToTurquoise300,
  cYellowToTurquoise400,
  cYellowToTurquoise500,
  cYellowToTurquoise600,
  cYellowToTurquoise700,
  cYellowToTurquoise800,
  cYellowToTurquoise900,
  fontSizeBase,
  fontSizeLg,
  fontSizeSm,
  fontSizeXs,
  fontWeightBlack,
  fontWeightBold,
  fontWeightRegular,
  fontWeightSemiBold,
  lineHeightNormal,
  lineHeightSnug,
  lineHeightTight,
  sPx1,
  sPx2,
  sPx3,
  sPx4,
  sPx5,
  sPx6,
  sPx7,
  sPx8,
  sRem1,
  sRem2,
  sRem3,
  sRem4,
  sRem5,
  sRem6,
  sRem7,
  sRem8
}, Symbol.toStringTag, { value: "Module" }));
const BarH_svelte_svelte_type_style_lang = "";
const file$I = "src/lib/components/layercake/BarH.svelte";
const get_end_slot_changes$1 = (dirty) => ({});
const get_end_slot_context$1 = (ctx) => ({});
const get_start_slot_changes$1 = (dirty) => ({});
const get_start_slot_context$1 = (ctx) => ({});
function create_if_block$j(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (ctx[16].default || ctx[16].start) && create_if_block_2$9(ctx);
  let if_block1 = ctx[16].end && create_if_block_1$9(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[16].default || ctx2[16].start) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 65536) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$9(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[16].end) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 65536) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$j.name,
    type: "if",
    source: "(73:0) {#if data != undefined && ctx != undefined}",
    ctx
  });
  return block;
}
function create_if_block_2$9(ctx) {
  let svgtext;
  let current;
  svgtext = new SvgText({
    props: {
      class: "font-regular",
      x: ctx[10],
      y: ctx[12] + ctx[9] / 2,
      yAlign: "center",
      xOffset: 4,
      outline: "none",
      color: getHighestContrastColor(ctx[15].fill || ctx[0] || cCategoryBlue),
      $$slots: { default: [create_default_slot_1$q] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svgtext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svgtext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svgtext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svgtext_changes = {};
      if (dirty & 1024)
        svgtext_changes.x = ctx2[10];
      if (dirty & 4608)
        svgtext_changes.y = ctx2[12] + ctx2[9] / 2;
      if (dirty & 32769)
        svgtext_changes.color = getHighestContrastColor(ctx2[15].fill || ctx2[0] || cCategoryBlue);
      if (dirty & 134283264) {
        svgtext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext.$set(svgtext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svgtext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svgtext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svgtext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$9.name,
    type: "if",
    source: "(74:2) {#if $$slots.default || $$slots.start}",
    ctx
  });
  return block;
}
function create_if_block_4$7(ctx) {
  let current;
  const default_slot_template = ctx[26].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[27], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(default_slot_template, ctx2[27], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4$7.name,
    type: "if",
    source: "(86:6) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_3$7(ctx) {
  let current;
  const start_slot_template = ctx[26].start;
  const start_slot = create_slot(start_slot_template, ctx, ctx[27], get_start_slot_context$1);
  const block = {
    c: function create() {
      if (start_slot)
        start_slot.c();
    },
    l: function claim(nodes) {
      if (start_slot)
        start_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (start_slot) {
        start_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (start_slot) {
        if (start_slot.p && (!current || dirty & 134217728)) {
          update_slot_base(
            start_slot,
            start_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(start_slot_template, ctx2[27], dirty, get_start_slot_changes$1),
            get_start_slot_context$1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(start_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(start_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (start_slot)
        start_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3$7.name,
    type: "if",
    source: "(89:6) {#if $$slots.start}",
    ctx
  });
  return block;
}
function create_default_slot_1$q(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[16].default && create_if_block_4$7(ctx);
  let if_block1 = ctx[16].start && create_if_block_3$7(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[16].default) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 65536) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[16].start) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 65536) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$7(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$q.name,
    type: "slot",
    source: '(75:4) <SvgText       class=\\"font-regular\\"       {x}       y={y + height / 2}       yAlign=\\"center\\"       xOffset={4}       outline=\\"none\\"       color={getHighestContrastColor(         $$restProps.fill || color || tokens.cCategoryBlue       )}     >',
    ctx
  });
  return block;
}
function create_if_block_1$9(ctx) {
  let svgtext;
  let current;
  svgtext = new SvgText({
    props: {
      class: "font-regular",
      y: ctx[12] + ctx[9] / 2,
      x: ctx[10] + ctx[11],
      yAlign: "center",
      xOffset: 4,
      outline: "none",
      $$slots: { default: [create_default_slot$q] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svgtext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svgtext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svgtext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svgtext_changes = {};
      if (dirty & 4608)
        svgtext_changes.y = ctx2[12] + ctx2[9] / 2;
      if (dirty & 3072)
        svgtext_changes.x = ctx2[10] + ctx2[11];
      if (dirty & 134217728) {
        svgtext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext.$set(svgtext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svgtext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svgtext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svgtext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$9.name,
    type: "if",
    source: "(95:2) {#if $$slots.end}",
    ctx
  });
  return block;
}
function create_default_slot$q(ctx) {
  let current;
  const end_slot_template = ctx[26].end;
  const end_slot = create_slot(end_slot_template, ctx, ctx[27], get_end_slot_context$1);
  const block = {
    c: function create() {
      if (end_slot)
        end_slot.c();
    },
    l: function claim(nodes) {
      if (end_slot)
        end_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (end_slot) {
        end_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (end_slot) {
        if (end_slot.p && (!current || dirty & 134217728)) {
          update_slot_base(
            end_slot,
            end_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(end_slot_template, ctx2[27], dirty, get_end_slot_changes$1),
            get_end_slot_context$1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (end_slot)
        end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$q.name,
    type: "slot",
    source: '(96:4) <SvgText       class=\\"font-regular\\"       y={y + height / 2}       x={x + width}       yAlign=\\"center\\"       xOffset={4}       outline=\\"none\\"     >',
    ctx
  });
  return block;
}
function create_fragment$L(ctx) {
  let rect;
  let symbol_action;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let rect_levels = [
    ctx[15],
    { x: ctx[10] },
    { y: ctx[12] },
    { width: ctx[11] },
    { height: ctx[9] }
  ];
  let rect_data = {};
  for (let i = 0; i < rect_levels.length; i += 1) {
    rect_data = assign(rect_data, rect_levels[i]);
  }
  let if_block = ctx[2] != void 0 && ctx[14] != void 0 && create_if_block$j(ctx);
  const block = {
    c: function create() {
      rect = svg_element("rect");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(rect, rect_data);
      toggle_class(rect, "no-outline", ctx[1] === "none");
      set_style(rect, "--_color", ctx[15].fill || ctx[0] || "");
      set_style(rect, "--_outline", ctx[15].stroke || ctx[1] || "");
      set_style(rect, "--_outline-width", ctx[15]["stroke-width"] || ctx[13] || "");
      set_style(rect, "--_opacity", ctx[15].opacity || "");
      toggle_class(rect, "s-5FVHh1tgjlLo", true);
      add_location(rect, file$I, 58, 0, 1474);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(symbol_action = symbol.call(null, rect, ctx[8]));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(rect, rect_data = get_spread_update(rect_levels, [
        dirty & 32768 && ctx2[15],
        (!current || dirty & 1024) && { x: ctx2[10] },
        (!current || dirty & 4096) && { y: ctx2[12] },
        (!current || dirty & 2048) && { width: ctx2[11] },
        (!current || dirty & 512) && { height: ctx2[9] }
      ]));
      if (symbol_action && is_function(symbol_action.update) && dirty & 256)
        symbol_action.update.call(null, ctx2[8]);
      toggle_class(rect, "no-outline", ctx2[1] === "none");
      set_style(rect, "--_color", ctx2[15].fill || ctx2[0] || "");
      set_style(rect, "--_outline", ctx2[15].stroke || ctx2[1] || "");
      set_style(rect, "--_outline-width", ctx2[15]["stroke-width"] || ctx2[13] || "");
      set_style(rect, "--_opacity", ctx2[15].opacity || "");
      toggle_class(rect, "s-5FVHh1tgjlLo", true);
      if (ctx2[2] != void 0 && ctx2[14] != void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$j(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(rect);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$L.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$L($$self, $$props, $$invalidate) {
  let outlineWidth;
  let x;
  let y;
  let width;
  let height;
  const omit_props_names = ["color", "outline", "data", "xIndex", "yIndex", "label", "parent"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $yScale, $$unsubscribe_yScale = noop, $$subscribe_yScale = () => ($$unsubscribe_yScale(), $$unsubscribe_yScale = subscribe(yScale, ($$value) => $$invalidate(21, $yScale = $$value)), yScale);
  let $xGet, $$unsubscribe_xGet = noop, $$subscribe_xGet = () => ($$unsubscribe_xGet(), $$unsubscribe_xGet = subscribe(xGet, ($$value) => $$invalidate(22, $xGet = $$value)), xGet);
  let $xScale, $$unsubscribe_xScale = noop, $$subscribe_xScale = () => ($$unsubscribe_xScale(), $$unsubscribe_xScale = subscribe(xScale, ($$value) => $$invalidate(23, $xScale = $$value)), xScale);
  let $ctxData, $$unsubscribe_ctxData = noop, $$subscribe_ctxData = () => ($$unsubscribe_ctxData(), $$unsubscribe_ctxData = subscribe(ctxData, ($$value) => $$invalidate(24, $ctxData = $$value)), ctxData);
  let $yGet, $$unsubscribe_yGet = noop, $$subscribe_yGet = () => ($$unsubscribe_yGet(), $$unsubscribe_yGet = subscribe(yGet, ($$value) => $$invalidate(25, $yGet = $$value)), yGet);
  $$self.$$.on_destroy.push(() => $$unsubscribe_yScale());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xScale());
  $$self.$$.on_destroy.push(() => $$unsubscribe_ctxData());
  $$self.$$.on_destroy.push(() => $$unsubscribe_yGet());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarH", slots, ["default", "start", "end"]);
  const $$slots = compute_slots(slots);
  let { color = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { xIndex = 0 } = $$props;
  let { yIndex = 0 } = $$props;
  let { label = void 0 } = $$props;
  let { parent = void 0 } = $$props;
  const ctx = getContext("LayerCake");
  let ctxData, xGet, yGet, xScale, yScale;
  let friendly;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$new_props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$new_props)
      $$invalidate(2, data = $$new_props.data);
    if ("xIndex" in $$new_props)
      $$invalidate(17, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$new_props)
      $$invalidate(18, yIndex = $$new_props.yIndex);
    if ("label" in $$new_props)
      $$invalidate(19, label = $$new_props.label);
    if ("parent" in $$new_props)
      $$invalidate(20, parent = $$new_props.parent);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    symbol,
    SvgText,
    getHighestContrastColor,
    get,
    isStacked,
    tokens,
    color,
    outline,
    data,
    xIndex,
    yIndex,
    label,
    parent,
    ctx,
    ctxData,
    xGet,
    yGet,
    xScale,
    yScale,
    friendly,
    height,
    x,
    width,
    y,
    outlineWidth,
    $yScale,
    $xGet,
    $xScale,
    $ctxData,
    $yGet
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$props)
      $$invalidate(2, data = $$new_props.data);
    if ("xIndex" in $$props)
      $$invalidate(17, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$props)
      $$invalidate(18, yIndex = $$new_props.yIndex);
    if ("label" in $$props)
      $$invalidate(19, label = $$new_props.label);
    if ("parent" in $$props)
      $$invalidate(20, parent = $$new_props.parent);
    if ("ctxData" in $$props)
      $$subscribe_ctxData($$invalidate(3, ctxData = $$new_props.ctxData));
    if ("xGet" in $$props)
      $$subscribe_xGet($$invalidate(4, xGet = $$new_props.xGet));
    if ("yGet" in $$props)
      $$subscribe_yGet($$invalidate(5, yGet = $$new_props.yGet));
    if ("xScale" in $$props)
      $$subscribe_xScale($$invalidate(6, xScale = $$new_props.xScale));
    if ("yScale" in $$props)
      $$subscribe_yScale($$invalidate(7, yScale = $$new_props.yScale));
    if ("friendly" in $$props)
      $$invalidate(8, friendly = $$new_props.friendly);
    if ("height" in $$props)
      $$invalidate(9, height = $$new_props.height);
    if ("x" in $$props)
      $$invalidate(10, x = $$new_props.x);
    if ("width" in $$props)
      $$invalidate(11, width = $$new_props.width);
    if ("y" in $$props)
      $$invalidate(12, y = $$new_props.y);
    if ("outlineWidth" in $$props)
      $$invalidate(13, outlineWidth = $$new_props.outlineWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(13, outlineWidth = $$restProps["outline-width"]);
    $$invalidate(10, x = $$restProps.x || 0);
    $$invalidate(12, y = $$restProps.y || 0);
    $$invalidate(11, width = $$restProps.width || 100);
    $$invalidate(9, height = $$restProps.height || 20);
    if ($$self.$$.dirty & 65404932) {
      if (data != void 0 && ctx != void 0) {
        $$subscribe_ctxData($$invalidate(3, ctxData = ctx.data));
        $$subscribe_xGet($$invalidate(4, xGet = ctx.xGet));
        $$subscribe_yGet($$invalidate(5, yGet = ctx.yGet));
        $$subscribe_xScale($$invalidate(6, xScale = ctx.xScale));
        $$subscribe_yScale($$invalidate(7, yScale = ctx.yScale));
        $$invalidate(12, y = get($yGet, data, yIndex));
        let x0;
        let x1;
        if (isStacked($ctxData)) {
          const xVals = $xGet(data);
          x0 = xVals[0];
          x1 = xVals[1];
        } else {
          x0 = $xScale(0);
          x1 = get($xGet, data, xIndex);
        }
        $$invalidate(11, width = Math.abs(x1 - x0));
        $$invalidate(10, x = Math.min(x0, x1));
        if ($yScale.bandwidth) {
          $$invalidate(9, height = $yScale.bandwidth());
        }
      }
    }
    if (label != void 0) {
      $$invalidate(8, friendly = {
        id: $$restProps.id,
        type: "bar",
        label,
        parentId: parent
      });
    }
  };
  return [
    color,
    outline,
    data,
    ctxData,
    xGet,
    yGet,
    xScale,
    yScale,
    friendly,
    height,
    x,
    width,
    y,
    outlineWidth,
    ctx,
    $$restProps,
    $$slots,
    xIndex,
    yIndex,
    label,
    parent,
    $yScale,
    $xGet,
    $xScale,
    $ctxData,
    $yGet,
    slots,
    $$scope
  ];
}
class BarH extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$L, create_fragment$L, safe_not_equal, {
      color: 0,
      outline: 1,
      data: 2,
      xIndex: 17,
      yIndex: 18,
      label: 19,
      parent: 20
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarH",
      options,
      id: create_fragment$L.name
    });
  }
  get color() {
    throw new Error("<BarH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<BarH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<BarH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<BarH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<BarH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BarH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xIndex() {
    throw new Error("<BarH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xIndex(value) {
    throw new Error("<BarH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yIndex() {
    throw new Error("<BarH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yIndex(value) {
    throw new Error("<BarH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<BarH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<BarH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<BarH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<BarH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const BarH_story_svelte_svelte_type_style_lang = "";
const file$H = "src/lib/components/layercake/BarH.story.svelte";
function get_each_context$c(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function get_each_context_2$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block_2$2(ctx) {
  let barh;
  let current;
  barh = new BarH({
    props: { data: ctx[3] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(barh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(barh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(barh, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(barh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(barh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(barh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2$2.name,
    type: "each",
    source: "(34:10) {#each data as d}",
    ctx
  });
  return block;
}
function create_default_slot_10$7(ctx) {
  let axisy;
  let t;
  let each_1_anchor;
  let current;
  axisy = new AxisY({ $$inline: true });
  let each_value_2 = ctx[1];
  validate_each_argument(each_value_2);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      create_component(axisy.$$.fragment);
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(axisy.$$.fragment, nodes);
      t = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2) {
        each_value_2 = ctx2[1];
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2$2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2$2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisy.$$.fragment, local);
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(axisy.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10$7.name,
    type: "slot",
    source: "(32:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_9$8(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_10$7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 1024) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9$8.name,
    type: "slot",
    source: '(24:6) <LayerCake         {data}         padding={{ left: 18, right: 22 }}         yScale={scaleBand().padding(0.15)}         {xDomain}         x=\\"value\\"         y=\\"category\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_8$a(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { left: 18, right: 22 },
      yScale: band().padding(0.15),
      xDomain: ctx[2],
      x: "value",
      y: "category",
      $$slots: { default: [create_default_slot_9$8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-Uk_UGDZK7qlR");
      add_location(div, file$H, 22, 4, 642);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 1024) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8$a.name,
    type: "slot",
    source: '(22:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot_7$a(ctx) {
  let t0_value = ctx[3].value + "";
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7$a.name,
    type: "slot",
    source: "(55:12) <BarH data={d}>",
    ctx
  });
  return block;
}
function create_each_block_1$2(ctx) {
  let barh;
  let current;
  barh = new BarH({
    props: {
      data: ctx[3],
      $$slots: { default: [create_default_slot_7$a] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(barh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(barh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(barh, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const barh_changes = {};
      if (dirty & 1024) {
        barh_changes.$$scope = { dirty, ctx: ctx2 };
      }
      barh.$set(barh_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(barh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(barh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(barh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1$2.name,
    type: "each",
    source: "(54:10) {#each data as d}",
    ctx
  });
  return block;
}
function create_default_slot_6$b(ctx) {
  let axisy;
  let t;
  let each_1_anchor;
  let current;
  axisy = new AxisY({ $$inline: true });
  let each_value_1 = ctx[1];
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      create_component(axisy.$$.fragment);
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(axisy.$$.fragment, nodes);
      t = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2) {
        each_value_1 = ctx2[1];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisy.$$.fragment, local);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(axisy.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$b.name,
    type: "slot",
    source: "(52:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_5$k(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_6$b] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 1024) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$k.name,
    type: "slot",
    source: '(44:6) <LayerCake         {data}         padding={{ left: 18, right: 22 }}         yScale={scaleBand().padding(0.15)}         {xDomain}         x=\\"value\\"         y=\\"category\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_4$l(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { left: 18, right: 22 },
      yScale: band().padding(0.15),
      xDomain: ctx[2],
      x: "value",
      y: "category",
      $$slots: { default: [create_default_slot_5$k] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-Uk_UGDZK7qlR");
      add_location(div, file$H, 42, 4, 1065);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 1024) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$l.name,
    type: "slot",
    source: '(42:2) <Hst.Variant title=\\"With bar labels\\">',
    ctx
  });
  return block;
}
function create_end_slot$1(ctx) {
  let t_value = ctx[3].value + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_end_slot$1.name,
    type: "slot",
    source: '(78:14) <svelte:fragment slot=\\"end\\">',
    ctx
  });
  return block;
}
function create_each_block$c(ctx) {
  let barh;
  let current;
  barh = new BarH({
    props: {
      data: ctx[3],
      $$slots: { end: [create_end_slot$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(barh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(barh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(barh, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const barh_changes = {};
      if (dirty & 1024) {
        barh_changes.$$scope = { dirty, ctx: ctx2 };
      }
      barh.$set(barh_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(barh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(barh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(barh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$c.name,
    type: "each",
    source: "(76:10) {#each data as d}",
    ctx
  });
  return block;
}
function create_default_slot_3$n(ctx) {
  let axisy;
  let t;
  let each_1_anchor;
  let current;
  axisy = new AxisY({ $$inline: true });
  let each_value = ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      create_component(axisy.$$.fragment);
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(axisy.$$.fragment, nodes);
      t = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$c(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$c(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisy.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(axisy.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$n.name,
    type: "slot",
    source: "(74:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$n(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$n] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 1024) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$n.name,
    type: "slot",
    source: '(66:6) <LayerCake         {data}         padding={{ left: 18, right: 22 }}         yScale={scaleBand().padding(0.15)}         {xDomain}         x=\\"value\\"         y=\\"category\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$p(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { left: 18, right: 22 },
      yScale: band().padding(0.15),
      xDomain: ctx[2],
      x: "value",
      y: "category",
      $$slots: { default: [create_default_slot_2$n] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-Uk_UGDZK7qlR");
      add_location(div, file$H, 64, 4, 1541);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 1024) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$p.name,
    type: "slot",
    source: '(64:2) <Hst.Variant title=\\"With bar labels at the end\\">',
    ctx
  });
  return block;
}
function create_default_slot$p(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_8$a] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "With bar labels",
      $$slots: { default: [create_default_slot_4$l] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "With bar labels at the end",
      $$slots: { default: [create_default_slot_1$p] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 1024) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 1024) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 1024) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$p.name,
    type: "slot",
    source: `(17:0) <Hst.Story   group=\\"layercake\\"   title=\\"BarH\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$K(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "BarH",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$p] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 1024) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$K.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$K($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarH_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { category: "A", value: 10 },
    { category: "B", value: 30 },
    { category: "C", value: 25 },
    { category: "D", value: 50 },
    { category: "E", value: 10 },
    { category: "F", value: 5 }
  ];
  const xDomain = (domain) => [0, domain[1]];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<BarH_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BarH_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    scaleBand: band,
    LayerCake,
    Svg,
    BarH,
    AxisY,
    data,
    xDomain
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data, xDomain];
}
class BarH_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$K, create_fragment$K, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarH_story",
      options,
      id: create_fragment$K.name
    });
  }
  get Hst() {
    throw new Error("<BarH_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<BarH_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const BarV_svelte_svelte_type_style_lang = "";
const file$G = "src/lib/components/layercake/BarV.svelte";
const get_end_slot_changes = (dirty) => ({});
const get_end_slot_context = (ctx) => ({});
const get_start_slot_changes = (dirty) => ({});
const get_start_slot_context = (ctx) => ({});
function create_if_block$i(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (ctx[16].default || ctx[16].start) && create_if_block_2$8(ctx);
  let if_block1 = ctx[16].end && create_if_block_1$8(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[16].default || ctx2[16].start) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 65536) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[16].end) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 65536) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$8(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$i.name,
    type: "if",
    source: "(73:0) {#if data != undefined && ctx != undefined}",
    ctx
  });
  return block;
}
function create_if_block_2$8(ctx) {
  let svgtext;
  let current;
  svgtext = new SvgText({
    props: {
      class: "font-regular",
      x: ctx[12] + ctx[9] / 2,
      y: ctx[10] + ctx[11],
      xAlign: "center",
      yOffset: -4,
      outline: "none",
      color: getHighestContrastColor(ctx[15].fill || ctx[0] || cCategoryBlue),
      $$slots: { default: [create_default_slot_1$o] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svgtext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svgtext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svgtext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svgtext_changes = {};
      if (dirty & 4608)
        svgtext_changes.x = ctx2[12] + ctx2[9] / 2;
      if (dirty & 3072)
        svgtext_changes.y = ctx2[10] + ctx2[11];
      if (dirty & 32769)
        svgtext_changes.color = getHighestContrastColor(ctx2[15].fill || ctx2[0] || cCategoryBlue);
      if (dirty & 134283264) {
        svgtext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext.$set(svgtext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svgtext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svgtext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svgtext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$8.name,
    type: "if",
    source: "(74:2) {#if $$slots.default || $$slots.start}",
    ctx
  });
  return block;
}
function create_if_block_4$6(ctx) {
  let current;
  const default_slot_template = ctx[26].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[27], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(default_slot_template, ctx2[27], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4$6.name,
    type: "if",
    source: "(86:6) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_3$6(ctx) {
  let current;
  const start_slot_template = ctx[26].start;
  const start_slot = create_slot(start_slot_template, ctx, ctx[27], get_start_slot_context);
  const block = {
    c: function create() {
      if (start_slot)
        start_slot.c();
    },
    l: function claim(nodes) {
      if (start_slot)
        start_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (start_slot) {
        start_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (start_slot) {
        if (start_slot.p && (!current || dirty & 134217728)) {
          update_slot_base(
            start_slot,
            start_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(start_slot_template, ctx2[27], dirty, get_start_slot_changes),
            get_start_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(start_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(start_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (start_slot)
        start_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3$6.name,
    type: "if",
    source: "(89:6) {#if $$slots.start}",
    ctx
  });
  return block;
}
function create_default_slot_1$o(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[16].default && create_if_block_4$6(ctx);
  let if_block1 = ctx[16].start && create_if_block_3$6(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[16].default) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 65536) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[16].start) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 65536) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$o.name,
    type: "slot",
    source: '(75:4) <SvgText       class=\\"font-regular\\"       x={x + width / 2}       y={y + height}       xAlign=\\"center\\"       yOffset={-4}       outline=\\"none\\"       color={getHighestContrastColor(         $$restProps.fill || color || tokens.cCategoryBlue       )}     >',
    ctx
  });
  return block;
}
function create_if_block_1$8(ctx) {
  let svgtext;
  let current;
  svgtext = new SvgText({
    props: {
      class: "font-regular",
      x: ctx[12] + ctx[9] / 2,
      y: ctx[10],
      xAlign: "center",
      yOffset: -4,
      outline: "none",
      $$slots: { default: [create_default_slot$o] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svgtext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svgtext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svgtext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svgtext_changes = {};
      if (dirty & 4608)
        svgtext_changes.x = ctx2[12] + ctx2[9] / 2;
      if (dirty & 1024)
        svgtext_changes.y = ctx2[10];
      if (dirty & 134217728) {
        svgtext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext.$set(svgtext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svgtext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svgtext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svgtext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$8.name,
    type: "if",
    source: "(95:2) {#if $$slots.end}",
    ctx
  });
  return block;
}
function create_default_slot$o(ctx) {
  let current;
  const end_slot_template = ctx[26].end;
  const end_slot = create_slot(end_slot_template, ctx, ctx[27], get_end_slot_context);
  const block = {
    c: function create() {
      if (end_slot)
        end_slot.c();
    },
    l: function claim(nodes) {
      if (end_slot)
        end_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (end_slot) {
        end_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (end_slot) {
        if (end_slot.p && (!current || dirty & 134217728)) {
          update_slot_base(
            end_slot,
            end_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(end_slot_template, ctx2[27], dirty, get_end_slot_changes),
            get_end_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(end_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(end_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (end_slot)
        end_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$o.name,
    type: "slot",
    source: '(96:4) <SvgText       class=\\"font-regular\\"       x={x + width / 2}       {y}       xAlign=\\"center\\"       yOffset={-4}       outline=\\"none\\"     >',
    ctx
  });
  return block;
}
function create_fragment$J(ctx) {
  let rect;
  let symbol_action;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let rect_levels = [
    ctx[15],
    { x: ctx[12] },
    { y: ctx[10] },
    { width: ctx[9] },
    { height: ctx[11] }
  ];
  let rect_data = {};
  for (let i = 0; i < rect_levels.length; i += 1) {
    rect_data = assign(rect_data, rect_levels[i]);
  }
  let if_block = ctx[2] != void 0 && ctx[14] != void 0 && create_if_block$i(ctx);
  const block = {
    c: function create() {
      rect = svg_element("rect");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(rect, rect_data);
      toggle_class(rect, "no-outline", ctx[1] === "none");
      set_style(rect, "--_color", ctx[15].fill || ctx[0] || "");
      set_style(rect, "--_outline", ctx[15].stroke || ctx[1] || "");
      set_style(rect, "--_outline-width", ctx[15]["stroke-width"] || ctx[13] || "");
      set_style(rect, "--_opacity", ctx[15].opacity || "");
      toggle_class(rect, "s-nyRP36VndBBd", true);
      add_location(rect, file$G, 58, 0, 1472);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(symbol_action = symbol.call(null, rect, ctx[8]));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(rect, rect_data = get_spread_update(rect_levels, [
        dirty & 32768 && ctx2[15],
        (!current || dirty & 4096) && { x: ctx2[12] },
        (!current || dirty & 1024) && { y: ctx2[10] },
        (!current || dirty & 512) && { width: ctx2[9] },
        (!current || dirty & 2048) && { height: ctx2[11] }
      ]));
      if (symbol_action && is_function(symbol_action.update) && dirty & 256)
        symbol_action.update.call(null, ctx2[8]);
      toggle_class(rect, "no-outline", ctx2[1] === "none");
      set_style(rect, "--_color", ctx2[15].fill || ctx2[0] || "");
      set_style(rect, "--_outline", ctx2[15].stroke || ctx2[1] || "");
      set_style(rect, "--_outline-width", ctx2[15]["stroke-width"] || ctx2[13] || "");
      set_style(rect, "--_opacity", ctx2[15].opacity || "");
      toggle_class(rect, "s-nyRP36VndBBd", true);
      if (ctx2[2] != void 0 && ctx2[14] != void 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$i(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(rect);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$J.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$J($$self, $$props, $$invalidate) {
  let outlineWidth;
  let x;
  let y;
  let width;
  let height;
  const omit_props_names = ["color", "outline", "data", "xIndex", "yIndex", "label", "parent"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $xScale, $$unsubscribe_xScale = noop, $$subscribe_xScale = () => ($$unsubscribe_xScale(), $$unsubscribe_xScale = subscribe(xScale, ($$value) => $$invalidate(21, $xScale = $$value)), xScale);
  let $yGet, $$unsubscribe_yGet = noop, $$subscribe_yGet = () => ($$unsubscribe_yGet(), $$unsubscribe_yGet = subscribe(yGet, ($$value) => $$invalidate(22, $yGet = $$value)), yGet);
  let $yScale, $$unsubscribe_yScale = noop, $$subscribe_yScale = () => ($$unsubscribe_yScale(), $$unsubscribe_yScale = subscribe(yScale, ($$value) => $$invalidate(23, $yScale = $$value)), yScale);
  let $ctxData, $$unsubscribe_ctxData = noop, $$subscribe_ctxData = () => ($$unsubscribe_ctxData(), $$unsubscribe_ctxData = subscribe(ctxData, ($$value) => $$invalidate(24, $ctxData = $$value)), ctxData);
  let $xGet, $$unsubscribe_xGet = noop, $$subscribe_xGet = () => ($$unsubscribe_xGet(), $$unsubscribe_xGet = subscribe(xGet, ($$value) => $$invalidate(25, $xGet = $$value)), xGet);
  $$self.$$.on_destroy.push(() => $$unsubscribe_xScale());
  $$self.$$.on_destroy.push(() => $$unsubscribe_yGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_yScale());
  $$self.$$.on_destroy.push(() => $$unsubscribe_ctxData());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xGet());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarV", slots, ["default", "start", "end"]);
  const $$slots = compute_slots(slots);
  let { color = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { xIndex = 0 } = $$props;
  let { yIndex = 0 } = $$props;
  let { label = void 0 } = $$props;
  let { parent = void 0 } = $$props;
  const ctx = getContext("LayerCake");
  let ctxData, xGet, yGet, xScale, yScale;
  let friendly;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$new_props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$new_props)
      $$invalidate(2, data = $$new_props.data);
    if ("xIndex" in $$new_props)
      $$invalidate(17, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$new_props)
      $$invalidate(18, yIndex = $$new_props.yIndex);
    if ("label" in $$new_props)
      $$invalidate(19, label = $$new_props.label);
    if ("parent" in $$new_props)
      $$invalidate(20, parent = $$new_props.parent);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    symbol,
    SvgText,
    getHighestContrastColor,
    get,
    isStacked,
    tokens,
    color,
    outline,
    data,
    xIndex,
    yIndex,
    label,
    parent,
    ctx,
    ctxData,
    xGet,
    yGet,
    xScale,
    yScale,
    friendly,
    width,
    y,
    height,
    x,
    outlineWidth,
    $xScale,
    $yGet,
    $yScale,
    $ctxData,
    $xGet
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$props)
      $$invalidate(2, data = $$new_props.data);
    if ("xIndex" in $$props)
      $$invalidate(17, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$props)
      $$invalidate(18, yIndex = $$new_props.yIndex);
    if ("label" in $$props)
      $$invalidate(19, label = $$new_props.label);
    if ("parent" in $$props)
      $$invalidate(20, parent = $$new_props.parent);
    if ("ctxData" in $$props)
      $$subscribe_ctxData($$invalidate(3, ctxData = $$new_props.ctxData));
    if ("xGet" in $$props)
      $$subscribe_xGet($$invalidate(4, xGet = $$new_props.xGet));
    if ("yGet" in $$props)
      $$subscribe_yGet($$invalidate(5, yGet = $$new_props.yGet));
    if ("xScale" in $$props)
      $$subscribe_xScale($$invalidate(6, xScale = $$new_props.xScale));
    if ("yScale" in $$props)
      $$subscribe_yScale($$invalidate(7, yScale = $$new_props.yScale));
    if ("friendly" in $$props)
      $$invalidate(8, friendly = $$new_props.friendly);
    if ("width" in $$props)
      $$invalidate(9, width = $$new_props.width);
    if ("y" in $$props)
      $$invalidate(10, y = $$new_props.y);
    if ("height" in $$props)
      $$invalidate(11, height = $$new_props.height);
    if ("x" in $$props)
      $$invalidate(12, x = $$new_props.x);
    if ("outlineWidth" in $$props)
      $$invalidate(13, outlineWidth = $$new_props.outlineWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(13, outlineWidth = $$restProps["outline-width"]);
    $$invalidate(12, x = $$restProps.x || 0);
    $$invalidate(10, y = $$restProps.y || 0);
    $$invalidate(9, width = $$restProps.width || 20);
    $$invalidate(11, height = $$restProps.height || 100);
    if ($$self.$$.dirty & 65404932) {
      if (data != void 0 && ctx != void 0) {
        $$subscribe_ctxData($$invalidate(3, ctxData = ctx.data));
        $$subscribe_xGet($$invalidate(4, xGet = ctx.xGet));
        $$subscribe_yGet($$invalidate(5, yGet = ctx.yGet));
        $$subscribe_xScale($$invalidate(6, xScale = ctx.xScale));
        $$subscribe_yScale($$invalidate(7, yScale = ctx.yScale));
        $$invalidate(12, x = get($xGet, data, xIndex));
        let y0;
        let y1;
        if (isStacked($ctxData)) {
          const yVals = $yGet(data);
          y0 = yVals[0];
          y1 = yVals[1];
        } else {
          y0 = $yScale(0);
          y1 = get($yGet, data, yIndex);
        }
        $$invalidate(11, height = Math.abs(y1 - y0));
        $$invalidate(10, y = Math.min(y0, y1));
        if ($xScale.bandwidth) {
          $$invalidate(9, width = $xScale.bandwidth());
        }
      }
    }
    if (label != void 0) {
      $$invalidate(8, friendly = {
        id: $$restProps.id,
        type: "bar",
        label,
        parentId: parent
      });
    }
  };
  return [
    color,
    outline,
    data,
    ctxData,
    xGet,
    yGet,
    xScale,
    yScale,
    friendly,
    width,
    y,
    height,
    x,
    outlineWidth,
    ctx,
    $$restProps,
    $$slots,
    xIndex,
    yIndex,
    label,
    parent,
    $xScale,
    $yGet,
    $yScale,
    $ctxData,
    $xGet,
    slots,
    $$scope
  ];
}
class BarV extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$J, create_fragment$J, safe_not_equal, {
      color: 0,
      outline: 1,
      data: 2,
      xIndex: 17,
      yIndex: 18,
      label: 19,
      parent: 20
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarV",
      options,
      id: create_fragment$J.name
    });
  }
  get color() {
    throw new Error("<BarV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<BarV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<BarV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<BarV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<BarV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BarV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xIndex() {
    throw new Error("<BarV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xIndex(value) {
    throw new Error("<BarV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yIndex() {
    throw new Error("<BarV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yIndex(value) {
    throw new Error("<BarV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<BarV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<BarV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parent() {
    throw new Error("<BarV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parent(value) {
    throw new Error("<BarV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const BarV_story_svelte_svelte_type_style_lang = "";
const file$F = "src/lib/components/layercake/BarV.story.svelte";
function get_each_context$b(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function get_each_context_2$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block_2$1(ctx) {
  let barv;
  let current;
  barv = new BarV({
    props: { data: ctx[3] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(barv.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(barv.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(barv, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(barv.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(barv.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(barv, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2$1.name,
    type: "each",
    source: "(34:10) {#each data as d}",
    ctx
  });
  return block;
}
function create_default_slot_10$6(ctx) {
  let axisx;
  let t;
  let each_1_anchor;
  let current;
  axisx = new AxisX({
    props: {
      showTickLines: false,
      showDomainLine: false
    },
    $$inline: true
  });
  let each_value_2 = ctx[1];
  validate_each_argument(each_value_2);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2) {
        each_value_2 = ctx2[1];
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2$1(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10$6.name,
    type: "slot",
    source: "(32:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_9$7(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_10$6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 1024) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9$7.name,
    type: "slot",
    source: '(24:6) <LayerCake         {data}         padding={{ bottom: 20, top: 20 }}         xScale={scaleBand().padding(0.15)}         {yDomain}         y=\\"value\\"         x=\\"category\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_8$9(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { bottom: 20, top: 20 },
      xScale: band().padding(0.15),
      yDomain: ctx[2],
      y: "value",
      x: "category",
      $$slots: { default: [create_default_slot_9$7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-eq6XEJSsFw80");
      add_location(div, file$F, 22, 4, 642);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 1024) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8$9.name,
    type: "slot",
    source: '(22:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot_7$9(ctx) {
  let t0_value = ctx[3].value + "";
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7$9.name,
    type: "slot",
    source: "(55:12) <BarV data={d}>",
    ctx
  });
  return block;
}
function create_each_block_1$1(ctx) {
  let barv;
  let current;
  barv = new BarV({
    props: {
      data: ctx[3],
      $$slots: { default: [create_default_slot_7$9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(barv.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(barv.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(barv, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const barv_changes = {};
      if (dirty & 1024) {
        barv_changes.$$scope = { dirty, ctx: ctx2 };
      }
      barv.$set(barv_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(barv.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(barv.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(barv, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1$1.name,
    type: "each",
    source: "(54:10) {#each data as d}",
    ctx
  });
  return block;
}
function create_default_slot_6$a(ctx) {
  let axisx;
  let t;
  let each_1_anchor;
  let current;
  axisx = new AxisX({
    props: {
      showTickLines: false,
      showDomainLine: false
    },
    $$inline: true
  });
  let each_value_1 = ctx[1];
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2) {
        each_value_1 = ctx2[1];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$a.name,
    type: "slot",
    source: "(52:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_5$j(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_6$a] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 1024) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$j.name,
    type: "slot",
    source: '(44:6) <LayerCake         {data}         padding={{ bottom: 20, top: 20 }}         xScale={scaleBand().padding(0.15)}         {yDomain}         y=\\"value\\"         x=\\"category\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_4$k(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { bottom: 20, top: 20 },
      xScale: band().padding(0.15),
      yDomain: ctx[2],
      y: "value",
      x: "category",
      $$slots: { default: [create_default_slot_5$j] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-eq6XEJSsFw80");
      add_location(div, file$F, 42, 4, 1110);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 1024) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$k.name,
    type: "slot",
    source: '(42:2) <Hst.Variant title=\\"With bar labels\\">',
    ctx
  });
  return block;
}
function create_end_slot(ctx) {
  let t0_value = ctx[3].value + "";
  let t0;
  let t1;
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_end_slot.name,
    type: "slot",
    source: '(78:14) <svelte:fragment slot=\\"end\\">',
    ctx
  });
  return block;
}
function create_each_block$b(ctx) {
  let barv;
  let current;
  barv = new BarV({
    props: {
      data: ctx[3],
      $$slots: { end: [create_end_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(barv.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(barv.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(barv, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const barv_changes = {};
      if (dirty & 1024) {
        barv_changes.$$scope = { dirty, ctx: ctx2 };
      }
      barv.$set(barv_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(barv.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(barv.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(barv, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$b.name,
    type: "each",
    source: "(76:10) {#each data as d}",
    ctx
  });
  return block;
}
function create_default_slot_3$m(ctx) {
  let axisx;
  let t;
  let each_1_anchor;
  let current;
  axisx = new AxisX({
    props: {
      showTickLines: false,
      showDomainLine: false
    },
    $$inline: true
  });
  let each_value = ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$b(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$b(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$m.name,
    type: "slot",
    source: "(74:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$m(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$m] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 1024) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$m.name,
    type: "slot",
    source: '(66:6) <LayerCake         {data}         padding={{ bottom: 20, top: 20 }}         xScale={scaleBand().padding(0.15)}         {yDomain}         y=\\"value\\"         x=\\"category\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$n(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { bottom: 20, top: 20 },
      xScale: band().padding(0.15),
      yDomain: ctx[2],
      y: "value",
      x: "category",
      $$slots: { default: [create_default_slot_2$m] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-eq6XEJSsFw80");
      add_location(div, file$F, 64, 4, 1627);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 1024) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$n.name,
    type: "slot",
    source: '(64:2) <Hst.Variant title=\\"With bar labels on top\\">',
    ctx
  });
  return block;
}
function create_default_slot$n(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_8$9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "With bar labels",
      $$slots: { default: [create_default_slot_4$k] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "With bar labels on top",
      $$slots: { default: [create_default_slot_1$n] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 1024) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 1024) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 1024) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$n.name,
    type: "slot",
    source: `(17:0) <Hst.Story   group=\\"layercake\\"   title=\\"BarV\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$I(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "BarV",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$n] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 1024) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$I.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$I($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarV_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { category: "A", value: 10 },
    { category: "B", value: 30 },
    { category: "C", value: 25 },
    { category: "D", value: 50 },
    { category: "E", value: 10 },
    { category: "F", value: 5 }
  ];
  const yDomain = (domain) => [0, domain[1]];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<BarV_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BarV_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    scaleBand: band,
    LayerCake,
    Svg,
    BarV,
    AxisX,
    data,
    yDomain
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data, yDomain];
}
class BarV_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$I, create_fragment$I, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarV_story",
      options,
      id: create_fragment$I.name
    });
  }
  get Hst() {
    throw new Error("<BarV_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<BarV_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Circle_story_svelte_svelte_type_style_lang = "";
const file$E = "src/lib/components/layercake/Circle.story.svelte";
function get_each_context$a(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_default_slot_5$i(ctx) {
  let svg;
  let circle;
  let current;
  circle = new Circle({
    props: { cx: "50%", cy: "50%" },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(circle.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(circle.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$E, 21, 4, 546);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(circle, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(circle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(circle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$i.name,
    type: "slot",
    source: '(21:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$j(ctx) {
  let svg;
  let circle;
  let current;
  circle = new Circle({
    props: {
      cx: "50%",
      cy: "50%",
      r: "8",
      color: "orange",
      outline: "black",
      "outline-width": "2"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(circle.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(circle.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$E, 27, 4, 685);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(circle, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(circle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(circle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$j.name,
    type: "slot",
    source: '(27:2) <Hst.Variant title=\\"Custom attributes\\">',
    ctx
  });
  return block;
}
function create_each_block$a(ctx) {
  let circle;
  let current;
  circle = new Circle({
    props: { data: ctx[2] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(circle.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(circle.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(circle, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(circle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(circle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(circle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$a.name,
    type: "each",
    source: "(52:10) {#each data as d}",
    ctx
  });
  return block;
}
function create_default_slot_3$l(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let each_1_anchor;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  let each_value = ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$a(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$a(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$l.name,
    type: "slot",
    source: "(48:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$l(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$l] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 32) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$l.name,
    type: "slot",
    source: '(42:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$m(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_2$l] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-fKDr6-cVcMCM");
      add_location(div, file$E, 40, 4, 928);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 32) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$m.name,
    type: "slot",
    source: '(40:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot$m(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_5$i] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Custom attributes",
      $$slots: { default: [create_default_slot_4$j] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_1$m] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 32) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 32) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 32) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$m.name,
    type: "slot",
    source: `(16:0) <Hst.Story   group=\\"layercake\\"   title=\\"Circle\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$H(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "Circle",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$m] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 32) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$H.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$H($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Circle_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Circle_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Circle_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    Circle,
    AxisX,
    AxisY,
    data
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data];
}
class Circle_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$H, create_fragment$H, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Circle_story",
      options,
      id: create_fragment$H.name
    });
  }
  get Hst() {
    throw new Error("<Circle_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Circle_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const file$D = "src/lib/components/layercake/Group.svelte";
function get_each_context$9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
const get_default_slot_changes$8 = (dirty) => ({ d: dirty & 1 });
const get_default_slot_context$8 = (ctx) => ({ d: ctx[7] });
function create_each_block$9(ctx) {
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], get_default_slot_context$8);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 33)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, get_default_slot_changes$8),
            get_default_slot_context$8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$9.name,
    type: "each",
    source: "(19:2) {#each data as d}",
    ctx
  });
  return block;
}
function create_fragment$G(ctx) {
  let g;
  let g_class_value;
  let g_style_value;
  let group_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      g = svg_element("g");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", { class: true, style: true });
      var g_nodes = children(g);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(g_nodes);
      }
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g, "class", g_class_value = ctx[2].class);
      attr_dev(g, "style", g_style_value = ctx[2].style);
      add_location(g, file$D, 17, 0, 299);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(g, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(group_action = group.call(null, g, ctx[1]));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 33) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$9(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(g, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 4 && g_class_value !== (g_class_value = ctx2[2].class)) {
        attr_dev(g, "class", g_class_value);
      }
      if (!current || dirty & 4 && g_style_value !== (g_style_value = ctx2[2].style)) {
        attr_dev(g, "style", g_style_value);
      }
      if (group_action && is_function(group_action.update) && dirty & 2)
        group_action.update.call(null, ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(g);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$G.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$G($$self, $$props, $$invalidate) {
  const omit_props_names = ["data", "label", "type"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Group", slots, ["default"]);
  let { data } = $$props;
  let { label = void 0 } = $$props;
  let { type = void 0 } = $$props;
  let friendly;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Group> was created without expected prop 'data'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("data" in $$new_props)
      $$invalidate(0, data = $$new_props.data);
    if ("label" in $$new_props)
      $$invalidate(3, label = $$new_props.label);
    if ("type" in $$new_props)
      $$invalidate(4, type = $$new_props.type);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ group, data, label, type, friendly });
  $$self.$inject_state = ($$new_props) => {
    if ("data" in $$props)
      $$invalidate(0, data = $$new_props.data);
    if ("label" in $$props)
      $$invalidate(3, label = $$new_props.label);
    if ("type" in $$props)
      $$invalidate(4, type = $$new_props.type);
    if ("friendly" in $$props)
      $$invalidate(1, friendly = $$new_props.friendly);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if (label != void 0) {
      $$invalidate(1, friendly = { id: $$restProps.id, label, type });
    }
  };
  return [data, friendly, $$restProps, label, type, $$scope, slots];
}
class Group extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$G, create_fragment$G, safe_not_equal, { data: 0, label: 3, type: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Group",
      options,
      id: create_fragment$G.name
    });
  }
  get data() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Group_story_svelte_svelte_type_style_lang = "";
const file$C = "src/lib/components/layercake/Group.story.svelte";
function create_default_slot_3$k(ctx) {
  let circle;
  let current;
  circle = new Circle({
    props: { data: ctx[2] },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(circle.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(circle.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(circle, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const circle_changes = {};
      if (dirty & 4)
        circle_changes.data = ctx2[2];
      circle.$set(circle_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(circle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(circle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(circle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$k.name,
    type: "slot",
    source: "(33:8) <Group {data} let:d>",
    ctx
  });
  return block;
}
function create_default_slot_2$k(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let group2;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  group2 = new Group({
    props: {
      data: ctx[1],
      $$slots: {
        default: [create_default_slot_3$k, ({ d }) => ({ 2: d }), ({ d }) => d ? 4 : 0]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      create_component(group2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(group2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(group2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const group_changes = {};
      if (dirty & 12) {
        group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      group2.$set(group_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      transition_in(group2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      transition_out(group2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(group2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$k.name,
    type: "slot",
    source: "(29:6) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_1$l(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_2$k] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 8) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$l.name,
    type: "slot",
    source: '(23:4) <LayerCake       {data}       padding={{ top: 6, right: 8, bottom: 24, left: 24 }}       x=\\"x\\"       y=\\"y\\"     >',
    ctx
  });
  return block;
}
function create_default_slot$l(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_1$l] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-kiBih5FZ1xD1");
      add_location(div, file$C, 21, 2, 573);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 8) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$l.name,
    type: "slot",
    source: `(17:0) <Hst.Story   group=\\"layercake\\"   title=\\"Group\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$F(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "Group",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$l] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 8) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$F.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$F($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Group_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Group_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Group_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    Group,
    Circle,
    AxisX,
    AxisY,
    data
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data];
}
class Group_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$F, create_fragment$F, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Group_story",
      options,
      id: create_fragment$F.name
    });
  }
  get Hst() {
    throw new Error("<Group_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Group_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const HtmlText_svelte_svelte_type_style_lang = "";
const file$B = "src/lib/components/layercake/HtmlText.svelte";
function create_fragment$E(ctx) {
  let div;
  let style_transform = `translate(calc(${ctx[13][ctx[2]]} + ${ctx[10]}), calc(${ctx[14][ctx[3]]} + ${ctx[9]}))`;
  let current;
  const default_slot_template = ctx[28].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[27], null);
  let div_levels = [ctx[15]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      set_style(div, "left", ctx[12]);
      set_style(div, "top", ctx[11]);
      set_style(div, "max-width", ctx[4]);
      set_style(div, "transform", style_transform);
      set_style(div, "--_color", ctx[15].fill || ctx[0] || "");
      set_style(div, "--_outline", ctx[15].stroke || ctx[1] || "");
      set_style(div, "--_opacity", ctx[15].opacity || "");
      toggle_class(div, "s-zNXtPXUuFoiG", true);
      add_location(div, file$B, 50, 0, 1403);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(default_slot_template, ctx2[27], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 32768 && ctx2[15]]));
      set_style(div, "left", ctx2[12]);
      set_style(div, "top", ctx2[11]);
      set_style(div, "max-width", ctx2[4]);
      set_style(div, "transform", style_transform);
      set_style(div, "--_color", ctx2[15].fill || ctx2[0] || "");
      set_style(div, "--_outline", ctx2[15].stroke || ctx2[1] || "");
      set_style(div, "--_opacity", ctx2[15].opacity || "");
      toggle_class(div, "s-zNXtPXUuFoiG", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$E.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$E($$self, $$props, $$invalidate) {
  let left;
  let top;
  let _xOffset;
  let _yOffset;
  const omit_props_names = [
    "x",
    "y",
    "color",
    "outline",
    "data",
    "xIndex",
    "yIndex",
    "xAlign",
    "yAlign",
    "xOffset",
    "yOffset"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $padding, $$unsubscribe_padding = noop, $$subscribe_padding = () => ($$unsubscribe_padding(), $$unsubscribe_padding = subscribe(padding, ($$value) => $$invalidate(23, $padding = $$value)), padding);
  let $ctxWidth, $$unsubscribe_ctxWidth = noop, $$subscribe_ctxWidth = () => ($$unsubscribe_ctxWidth(), $$unsubscribe_ctxWidth = subscribe(ctxWidth, ($$value) => $$invalidate(24, $ctxWidth = $$value)), ctxWidth);
  let $yGet, $$unsubscribe_yGet = noop, $$subscribe_yGet = () => ($$unsubscribe_yGet(), $$unsubscribe_yGet = subscribe(yGet, ($$value) => $$invalidate(25, $yGet = $$value)), yGet);
  let $xGet, $$unsubscribe_xGet = noop, $$subscribe_xGet = () => ($$unsubscribe_xGet(), $$unsubscribe_xGet = subscribe(xGet, ($$value) => $$invalidate(26, $xGet = $$value)), xGet);
  $$self.$$.on_destroy.push(() => $$unsubscribe_padding());
  $$self.$$.on_destroy.push(() => $$unsubscribe_ctxWidth());
  $$self.$$.on_destroy.push(() => $$unsubscribe_yGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_xGet());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HtmlText", slots, ["default"]);
  let { x = 0 } = $$props;
  let { y = 0 } = $$props;
  let { color = void 0 } = $$props;
  let { outline = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { xIndex = 0 } = $$props;
  let { yIndex = 0 } = $$props;
  let { xAlign = "left" } = $$props;
  let { yAlign = "bottom" } = $$props;
  let { xOffset = 0 } = $$props;
  let { yOffset = 0 } = $$props;
  let maxWidth;
  const xTranslate = {
    left: "0px",
    center: "-50%",
    right: "-100%"
  };
  const yTranslate = {
    top: "0px",
    center: "-50%",
    bottom: "-100%"
  };
  const ctx = getContext("LayerCake");
  let xGet, yGet, ctxWidth, padding;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("x" in $$new_props)
      $$invalidate(16, x = $$new_props.x);
    if ("y" in $$new_props)
      $$invalidate(17, y = $$new_props.y);
    if ("color" in $$new_props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$new_props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$new_props)
      $$invalidate(18, data = $$new_props.data);
    if ("xIndex" in $$new_props)
      $$invalidate(19, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$new_props)
      $$invalidate(20, yIndex = $$new_props.yIndex);
    if ("xAlign" in $$new_props)
      $$invalidate(2, xAlign = $$new_props.xAlign);
    if ("yAlign" in $$new_props)
      $$invalidate(3, yAlign = $$new_props.yAlign);
    if ("xOffset" in $$new_props)
      $$invalidate(21, xOffset = $$new_props.xOffset);
    if ("yOffset" in $$new_props)
      $$invalidate(22, yOffset = $$new_props.yOffset);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get,
    x,
    y,
    color,
    outline,
    data,
    xIndex,
    yIndex,
    xAlign,
    yAlign,
    xOffset,
    yOffset,
    maxWidth,
    xTranslate,
    yTranslate,
    ctx,
    xGet,
    yGet,
    ctxWidth,
    padding,
    _yOffset,
    _xOffset,
    top,
    left,
    $padding,
    $ctxWidth,
    $yGet,
    $xGet
  });
  $$self.$inject_state = ($$new_props) => {
    if ("x" in $$props)
      $$invalidate(16, x = $$new_props.x);
    if ("y" in $$props)
      $$invalidate(17, y = $$new_props.y);
    if ("color" in $$props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$props)
      $$invalidate(18, data = $$new_props.data);
    if ("xIndex" in $$props)
      $$invalidate(19, xIndex = $$new_props.xIndex);
    if ("yIndex" in $$props)
      $$invalidate(20, yIndex = $$new_props.yIndex);
    if ("xAlign" in $$props)
      $$invalidate(2, xAlign = $$new_props.xAlign);
    if ("yAlign" in $$props)
      $$invalidate(3, yAlign = $$new_props.yAlign);
    if ("xOffset" in $$props)
      $$invalidate(21, xOffset = $$new_props.xOffset);
    if ("yOffset" in $$props)
      $$invalidate(22, yOffset = $$new_props.yOffset);
    if ("maxWidth" in $$props)
      $$invalidate(4, maxWidth = $$new_props.maxWidth);
    if ("xGet" in $$props)
      $$subscribe_xGet($$invalidate(5, xGet = $$new_props.xGet));
    if ("yGet" in $$props)
      $$subscribe_yGet($$invalidate(6, yGet = $$new_props.yGet));
    if ("ctxWidth" in $$props)
      $$subscribe_ctxWidth($$invalidate(7, ctxWidth = $$new_props.ctxWidth));
    if ("padding" in $$props)
      $$subscribe_padding($$invalidate(8, padding = $$new_props.padding));
    if ("_yOffset" in $$props)
      $$invalidate(9, _yOffset = $$new_props._yOffset);
    if ("_xOffset" in $$props)
      $$invalidate(10, _xOffset = $$new_props._xOffset);
    if ("top" in $$props)
      $$invalidate(11, top = $$new_props.top);
    if ("left" in $$props)
      $$invalidate(12, left = $$new_props.left);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 65536) {
      $$invalidate(12, left = (typeof x === "number" ? `${x}px` : x) || "0px");
    }
    if ($$self.$$.dirty & 131072) {
      $$invalidate(11, top = (typeof y === "number" ? `${y}px` : y) || "0px");
    }
    if ($$self.$$.dirty & 129761280) {
      if (data != void 0 && ctx != void 0) {
        $$subscribe_xGet($$invalidate(5, xGet = ctx.xGet));
        $$subscribe_yGet($$invalidate(6, yGet = ctx.yGet));
        $$subscribe_ctxWidth($$invalidate(7, ctxWidth = ctx.width));
        $$subscribe_padding($$invalidate(8, padding = ctx.padding));
        const l = get($xGet, data, xIndex);
        $$invalidate(12, left = l.toString() + "px");
        const t = get($yGet, data, yIndex);
        $$invalidate(11, top = t.toString() + "px");
        const w = $ctxWidth - l + $padding.right - xOffset;
        $$invalidate(4, maxWidth = `${w}px`);
      }
    }
    if ($$self.$$.dirty & 2097152) {
      $$invalidate(10, _xOffset = typeof xOffset === "number" ? `${xOffset}px` : xOffset);
    }
    if ($$self.$$.dirty & 4194304) {
      $$invalidate(9, _yOffset = typeof yOffset === "number" ? `${yOffset}px` : yOffset);
    }
  };
  return [
    color,
    outline,
    xAlign,
    yAlign,
    maxWidth,
    xGet,
    yGet,
    ctxWidth,
    padding,
    _yOffset,
    _xOffset,
    top,
    left,
    xTranslate,
    yTranslate,
    $$restProps,
    x,
    y,
    data,
    xIndex,
    yIndex,
    xOffset,
    yOffset,
    $padding,
    $ctxWidth,
    $yGet,
    $xGet,
    $$scope,
    slots
  ];
}
class HtmlText extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$E, create_fragment$E, safe_not_equal, {
      x: 16,
      y: 17,
      color: 0,
      outline: 1,
      data: 18,
      xIndex: 19,
      yIndex: 20,
      xAlign: 2,
      yAlign: 3,
      xOffset: 21,
      yOffset: 22
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HtmlText",
      options,
      id: create_fragment$E.name
    });
  }
  get x() {
    throw new Error("<HtmlText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<HtmlText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<HtmlText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<HtmlText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<HtmlText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<HtmlText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<HtmlText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<HtmlText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<HtmlText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<HtmlText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xIndex() {
    throw new Error("<HtmlText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xIndex(value) {
    throw new Error("<HtmlText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yIndex() {
    throw new Error("<HtmlText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yIndex(value) {
    throw new Error("<HtmlText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xAlign() {
    throw new Error("<HtmlText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xAlign(value) {
    throw new Error("<HtmlText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yAlign() {
    throw new Error("<HtmlText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yAlign(value) {
    throw new Error("<HtmlText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xOffset() {
    throw new Error("<HtmlText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xOffset(value) {
    throw new Error("<HtmlText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yOffset() {
    throw new Error("<HtmlText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yOffset(value) {
    throw new Error("<HtmlText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const HtmlText_story_svelte_svelte_type_style_lang = "";
const file$A = "src/lib/components/layercake/HtmlText.story.svelte";
function create_default_slot_29(ctx) {
  let axisx;
  let t;
  let axisy;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t = space();
      create_component(axisy.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(axisy, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(axisy, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_29.name,
    type: "slot",
    source: "(32:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_28(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_28.name,
    type: "slot",
    source: "(37:10) <HtmlText data={data[4]}>",
    ctx
  });
  return block;
}
function create_default_slot_27(ctx) {
  let htmltext;
  let current;
  htmltext = new HtmlText({
    props: {
      data: ctx[2][4],
      $$slots: { default: [create_default_slot_28] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(htmltext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(htmltext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(htmltext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const htmltext_changes = {};
      if (dirty & 66) {
        htmltext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      htmltext.$set(htmltext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(htmltext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(htmltext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(htmltext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_27.name,
    type: "slot",
    source: "(36:8) <Html>",
    ctx
  });
  return block;
}
function create_default_slot_26(ctx) {
  let svg;
  let t;
  let html;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_29] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  html = new Html({
    props: {
      $$slots: { default: [create_default_slot_27] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
      t = space();
      create_component(html.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(html.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(html, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 64) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
      const html_changes = {};
      if (dirty & 66) {
        html_changes.$$scope = { dirty, ctx: ctx2 };
      }
      html.$set(html_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      transition_in(html.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      transition_out(html.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(html, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_26.name,
    type: "slot",
    source: '(26:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_25(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_26] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-QDOERVnb_Nue");
      add_location(div, file$A, 24, 4, 685);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 66) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_25.name,
    type: "slot",
    source: '(24:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_controls_slot_2$2(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding(value) {
    ctx[3](value);
  }
  let hst_text_props = { title: "Text" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot_2$2.name,
    type: "slot",
    source: '(42:4) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_default_slot_24$1(ctx) {
  let axisx;
  let t;
  let axisy;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t = space();
      create_component(axisy.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(axisy, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(axisy, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_24$1.name,
    type: "slot",
    source: "(55:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_23$1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23$1.name,
    type: "slot",
    source: '(60:10) <HtmlText             data={data[4]}             color=\\"orange\\"             outline=\\"black\\"             outline-width=\\"2\\"           >',
    ctx
  });
  return block;
}
function create_default_slot_22$1(ctx) {
  let htmltext;
  let current;
  htmltext = new HtmlText({
    props: {
      data: ctx[2][4],
      color: "orange",
      outline: "black",
      "outline-width": "2",
      $$slots: { default: [create_default_slot_23$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(htmltext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(htmltext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(htmltext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const htmltext_changes = {};
      if (dirty & 66) {
        htmltext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      htmltext.$set(htmltext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(htmltext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(htmltext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(htmltext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22$1.name,
    type: "slot",
    source: "(59:8) <Html>",
    ctx
  });
  return block;
}
function create_default_slot_21$1(ctx) {
  let svg;
  let t;
  let html;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_24$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  html = new Html({
    props: {
      $$slots: { default: [create_default_slot_22$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
      t = space();
      create_component(html.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(html.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(html, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 64) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
      const html_changes = {};
      if (dirty & 66) {
        html_changes.$$scope = { dirty, ctx: ctx2 };
      }
      html.$set(html_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      transition_in(html.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      transition_out(html.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(html, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_21$1.name,
    type: "slot",
    source: '(49:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_20$1(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_21$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-QDOERVnb_Nue");
      add_location(div, file$A, 47, 4, 1202);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 66) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_20$1.name,
    type: "slot",
    source: '(47:2) <Hst.Variant title=\\"With custom attributes\\">',
    ctx
  });
  return block;
}
function create_controls_slot_1$3(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding_1(value) {
    ctx[4](value);
  }
  let hst_text_props = { title: "Text" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding_1, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot_1$3.name,
    type: "slot",
    source: '(72:4) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_default_slot_19$1(ctx) {
  let axisx;
  let t;
  let axisy;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t = space();
      create_component(axisy.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(axisy, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(axisy, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_19$1.name,
    type: "slot",
    source: "(85:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_18$3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_18$3.name,
    type: "slot",
    source: "(90:10) <HtmlText data={data[4]} xOffset={5} yOffset={5}>",
    ctx
  });
  return block;
}
function create_default_slot_17$3(ctx) {
  let htmltext;
  let current;
  htmltext = new HtmlText({
    props: {
      data: ctx[2][4],
      xOffset: 5,
      yOffset: 5,
      $$slots: { default: [create_default_slot_18$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(htmltext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(htmltext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(htmltext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const htmltext_changes = {};
      if (dirty & 66) {
        htmltext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      htmltext.$set(htmltext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(htmltext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(htmltext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(htmltext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17$3.name,
    type: "slot",
    source: "(89:8) <Html>",
    ctx
  });
  return block;
}
function create_default_slot_16$3(ctx) {
  let svg;
  let t;
  let html;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_19$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  html = new Html({
    props: {
      $$slots: { default: [create_default_slot_17$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
      t = space();
      create_component(html.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(html.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(html, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 64) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
      const html_changes = {};
      if (dirty & 66) {
        html_changes.$$scope = { dirty, ctx: ctx2 };
      }
      html.$set(html_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      transition_in(html.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      transition_out(html.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(html, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16$3.name,
    type: "slot",
    source: '(79:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_15$3(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_16$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-QDOERVnb_Nue");
      add_location(div, file$A, 77, 4, 1848);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 66) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15$3.name,
    type: "slot",
    source: '(77:2) <Hst.Variant title=\\"With custom offsets\\">',
    ctx
  });
  return block;
}
function create_controls_slot$6(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding_2(value) {
    ctx[5](value);
  }
  let hst_text_props = { title: "Text" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding_2, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot$6.name,
    type: "slot",
    source: '(97:4) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_default_slot_14$3(ctx) {
  let linev;
  let current;
  linev = new LineV({
    props: { x: "50", color: "red" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(linev.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(linev.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(linev, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(linev.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linev.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(linev, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14$3.name,
    type: "slot",
    source: "(110:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_13$3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Left");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Left");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13$3.name,
    type: "slot",
    source: '(114:10) <HtmlText x=\\"50px\\" y=\\"20px\\" xAlign=\\"left\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_12$4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Center");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Center");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12$4.name,
    type: "slot",
    source: '(117:10) <HtmlText x=\\"50px\\" y=\\"60px\\" xAlign=\\"center\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_11$4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Right");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Right");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_11$4.name,
    type: "slot",
    source: '(120:10) <HtmlText x=\\"50px\\" y=\\"100px\\" xAlign=\\"right\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_10$5(ctx) {
  let htmltext0;
  let t0;
  let htmltext1;
  let t1;
  let htmltext2;
  let current;
  htmltext0 = new HtmlText({
    props: {
      x: "50px",
      y: "20px",
      xAlign: "left",
      outline: "none",
      $$slots: { default: [create_default_slot_13$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  htmltext1 = new HtmlText({
    props: {
      x: "50px",
      y: "60px",
      xAlign: "center",
      outline: "none",
      $$slots: { default: [create_default_slot_12$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  htmltext2 = new HtmlText({
    props: {
      x: "50px",
      y: "100px",
      xAlign: "right",
      outline: "none",
      $$slots: { default: [create_default_slot_11$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(htmltext0.$$.fragment);
      t0 = space();
      create_component(htmltext1.$$.fragment);
      t1 = space();
      create_component(htmltext2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(htmltext0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(htmltext1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(htmltext2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(htmltext0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(htmltext1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(htmltext2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const htmltext0_changes = {};
      if (dirty & 64) {
        htmltext0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      htmltext0.$set(htmltext0_changes);
      const htmltext1_changes = {};
      if (dirty & 64) {
        htmltext1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      htmltext1.$set(htmltext1_changes);
      const htmltext2_changes = {};
      if (dirty & 64) {
        htmltext2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      htmltext2.$set(htmltext2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(htmltext0.$$.fragment, local);
      transition_in(htmltext1.$$.fragment, local);
      transition_in(htmltext2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(htmltext0.$$.fragment, local);
      transition_out(htmltext1.$$.fragment, local);
      transition_out(htmltext2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(htmltext0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(htmltext1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(htmltext2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10$5.name,
    type: "slot",
    source: "(113:8) <Html>",
    ctx
  });
  return block;
}
function create_default_slot_9$6(ctx) {
  let svg;
  let t;
  let html;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_14$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  html = new Html({
    props: {
      $$slots: { default: [create_default_slot_10$5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
      t = space();
      create_component(html.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(html.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(html, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 64) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
      const html_changes = {};
      if (dirty & 64) {
        html_changes.$$scope = { dirty, ctx: ctx2 };
      }
      html.$set(html_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      transition_in(html.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      transition_out(html.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(html, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9$6.name,
    type: "slot",
    source: '(104:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_8$8(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_9$6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-QDOERVnb_Nue");
      add_location(div, file$A, 102, 4, 2409);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 64) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8$8.name,
    type: "slot",
    source: '(102:2) <Hst.Variant title=\\"Align along x-axis\\">',
    ctx
  });
  return block;
}
function create_default_slot_7$8(ctx) {
  let lineh;
  let current;
  lineh = new LineH({
    props: { y: "100", color: "red" },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(lineh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lineh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lineh, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lineh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7$8.name,
    type: "slot",
    source: "(136:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_6$9(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Bottom");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Bottom");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$9.name,
    type: "slot",
    source: '(140:10) <HtmlText x=\\"30px\\" y=\\"100px\\" yAlign=\\"bottom\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_5$h(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Center");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Center");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$h.name,
    type: "slot",
    source: '(143:10) <HtmlText x=\\"100px\\" y=\\"100px\\" yAlign=\\"center\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$i(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Top");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Top");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$i.name,
    type: "slot",
    source: '(146:10) <HtmlText x=\\"170px\\" y=\\"100px\\" yAlign=\\"top\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$j(ctx) {
  let htmltext0;
  let t0;
  let htmltext1;
  let t1;
  let htmltext2;
  let current;
  htmltext0 = new HtmlText({
    props: {
      x: "30px",
      y: "100px",
      yAlign: "bottom",
      outline: "none",
      $$slots: { default: [create_default_slot_6$9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  htmltext1 = new HtmlText({
    props: {
      x: "100px",
      y: "100px",
      yAlign: "center",
      outline: "none",
      $$slots: { default: [create_default_slot_5$h] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  htmltext2 = new HtmlText({
    props: {
      x: "170px",
      y: "100px",
      yAlign: "top",
      outline: "none",
      $$slots: { default: [create_default_slot_4$i] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(htmltext0.$$.fragment);
      t0 = space();
      create_component(htmltext1.$$.fragment);
      t1 = space();
      create_component(htmltext2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(htmltext0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(htmltext1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(htmltext2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(htmltext0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(htmltext1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(htmltext2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const htmltext0_changes = {};
      if (dirty & 64) {
        htmltext0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      htmltext0.$set(htmltext0_changes);
      const htmltext1_changes = {};
      if (dirty & 64) {
        htmltext1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      htmltext1.$set(htmltext1_changes);
      const htmltext2_changes = {};
      if (dirty & 64) {
        htmltext2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      htmltext2.$set(htmltext2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(htmltext0.$$.fragment, local);
      transition_in(htmltext1.$$.fragment, local);
      transition_in(htmltext2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(htmltext0.$$.fragment, local);
      transition_out(htmltext1.$$.fragment, local);
      transition_out(htmltext2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(htmltext0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(htmltext1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(htmltext2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$j.name,
    type: "slot",
    source: "(139:8) <Html>",
    ctx
  });
  return block;
}
function create_default_slot_2$j(ctx) {
  let svg;
  let t;
  let html;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_7$8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  html = new Html({
    props: {
      $$slots: { default: [create_default_slot_3$j] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
      t = space();
      create_component(html.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(html.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(html, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 64) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
      const html_changes = {};
      if (dirty & 64) {
        html_changes.$$scope = { dirty, ctx: ctx2 };
      }
      html.$set(html_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      transition_in(html.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      transition_out(html.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(html, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$j.name,
    type: "slot",
    source: '(130:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$k(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_2$j] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-QDOERVnb_Nue");
      add_location(div, file$A, 128, 4, 3081);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 64) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$k.name,
    type: "slot",
    source: '(128:2) <Hst.Variant title=\\"Align on y-axis\\">',
    ctx
  });
  return block;
}
function create_default_slot$k(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let t2;
  let hst_variant3;
  let t3;
  let hst_variant4;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: {
        controls: [create_controls_slot_2$2],
        default: [create_default_slot_25]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "With custom attributes",
      $$slots: {
        controls: [create_controls_slot_1$3],
        default: [create_default_slot_20$1]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "With custom offsets",
      $$slots: {
        controls: [create_controls_slot$6],
        default: [create_default_slot_15$3]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant3 = new ctx[0].Variant({
    props: {
      title: "Align along x-axis",
      $$slots: { default: [create_default_slot_8$8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant4 = new ctx[0].Variant({
    props: {
      title: "Align on y-axis",
      $$slots: { default: [create_default_slot_1$k] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
      t2 = space();
      create_component(hst_variant3.$$.fragment);
      t3 = space();
      create_component(hst_variant4.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_variant3.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(hst_variant4.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_variant3, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(hst_variant4, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 66) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 66) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 66) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
      const hst_variant3_changes = {};
      if (dirty & 64) {
        hst_variant3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant3.$set(hst_variant3_changes);
      const hst_variant4_changes = {};
      if (dirty & 64) {
        hst_variant4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant4.$set(hst_variant4_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      transition_in(hst_variant3.$$.fragment, local);
      transition_in(hst_variant4.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      transition_out(hst_variant3.$$.fragment, local);
      transition_out(hst_variant4.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_variant3, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(hst_variant4, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$k.name,
    type: "slot",
    source: `(19:0) <Hst.Story   group=\\"layercake\\"   title=\\"HtmlText\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$D(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "HtmlText",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$k] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 66) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$D.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$D($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HtmlText_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  let text2 = "Multi-line text with a line break";
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<HtmlText_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<HtmlText_story> was created with unknown prop '${key}'`);
  });
  function hst_text_value_binding(value) {
    text2 = value;
    $$invalidate(1, text2);
  }
  function hst_text_value_binding_1(value) {
    text2 = value;
    $$invalidate(1, text2);
  }
  function hst_text_value_binding_2(value) {
    text2 = value;
    $$invalidate(1, text2);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    Html,
    HtmlText,
    AxisX,
    AxisY,
    LineV,
    LineH,
    data,
    text: text2
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    text2,
    data,
    hst_text_value_binding,
    hst_text_value_binding_1,
    hst_text_value_binding_2
  ];
}
class HtmlText_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$D, create_fragment$D, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HtmlText_story",
      options,
      id: create_fragment$D.name
    });
  }
  get Hst() {
    throw new Error("<HtmlText_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<HtmlText_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Line_story_svelte_svelte_type_style_lang = "";
const file$z = "src/lib/components/layercake/Line.story.svelte";
function create_default_slot_5$g(ctx) {
  let svg;
  let line;
  let current;
  line = new Line({
    props: { x2: "50", y1: "10", y2: "10" },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(line.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(line.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$z, 21, 4, 540);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(line, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(line.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(line.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$g.name,
    type: "slot",
    source: '(21:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$h(ctx) {
  let svg;
  let line;
  let current;
  line = new Line({
    props: {
      x2: "50",
      y1: "10",
      y2: "10",
      color: "orange",
      width: 4,
      outline: "black",
      "outline-width": "2"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(line.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(line.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$z, 27, 4, 683);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(line, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(line.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(line.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$h.name,
    type: "slot",
    source: '(27:2) <Hst.Variant title=\\"Custom attributes\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$i(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let line;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  line = new Line({
    props: {
      data: [ctx[1][0], ctx[1][1]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      create_component(line.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(line.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(line, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      transition_in(line.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      transition_out(line.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(line, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$i.name,
    type: "slot",
    source: "(49:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$i(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$i] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 4) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$i.name,
    type: "slot",
    source: '(43:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$j(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_2$i] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-3h-hA6xJmV71");
      add_location(div, file$z, 41, 4, 942);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 4) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$j.name,
    type: "slot",
    source: '(41:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot$j(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_5$g] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Custom attributes",
      $$slots: { default: [create_default_slot_4$h] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_1$j] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 4) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 4) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 4) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$j.name,
    type: "slot",
    source: `(16:0) <Hst.Story   group=\\"layercake\\"   title=\\"Line\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$C(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "Line",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$j] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 4) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$C.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$C($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Line_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Line_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Line_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    Line,
    AxisX,
    AxisY,
    data
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data];
}
class Line_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$C, create_fragment$C, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Line_story",
      options,
      id: create_fragment$C.name
    });
  }
  get Hst() {
    throw new Error("<Line_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Line_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const LineH_story_svelte_svelte_type_style_lang = "";
const file$y = "src/lib/components/layercake/LineH.story.svelte";
function create_default_slot_5$f(ctx) {
  let svg;
  let lineh;
  let current;
  lineh = new LineH({
    props: { y: "10", x1: "5", x2: "40" },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(lineh.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(lineh.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$y, 21, 4, 543);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(lineh, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(lineh);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$f.name,
    type: "slot",
    source: '(21:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$g(ctx) {
  let svg;
  let lineh;
  let current;
  lineh = new LineH({
    props: {
      y: "10",
      x1: "5",
      x2: "40",
      color: "orange",
      width: 4,
      outline: "black",
      "outline-width": "2"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(lineh.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(lineh.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$y, 27, 4, 685);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(lineh, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(lineh);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$g.name,
    type: "slot",
    source: '(27:2) <Hst.Variant title=\\"Custom attributes\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$h(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let lineh;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({
    props: {
      showGridLines: false,
      showTickLines: true
    },
    $$inline: true
  });
  lineh = new LineH({
    props: { yData: ctx[1][1].y },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      create_component(lineh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(lineh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(lineh, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      transition_in(lineh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      transition_out(lineh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(lineh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$h.name,
    type: "slot",
    source: "(49:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$h(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$h] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 4) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$h.name,
    type: "slot",
    source: '(43:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$i(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_2$h] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-mRbfeXT-5L82");
      add_location(div, file$y, 41, 4, 943);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 4) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$i.name,
    type: "slot",
    source: '(41:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot$i(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_5$f] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Custom attributes",
      $$slots: { default: [create_default_slot_4$g] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_1$i] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 4) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 4) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 4) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$i.name,
    type: "slot",
    source: `(16:0) <Hst.Story   group=\\"layercake\\"   title=\\"LineH\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$B(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "LineH",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$i] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 4) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$B.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$B($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineH_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<LineH_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LineH_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    LineH,
    AxisX,
    AxisY,
    data
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data];
}
class LineH_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$B, create_fragment$B, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineH_story",
      options,
      id: create_fragment$B.name
    });
  }
  get Hst() {
    throw new Error("<LineH_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<LineH_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const LineV_story_svelte_svelte_type_style_lang = "";
const file$x = "src/lib/components/layercake/LineV.story.svelte";
function create_default_slot_5$e(ctx) {
  let svg;
  let linev;
  let current;
  linev = new LineV({
    props: { x: "10", y1: "5", y2: "40" },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(linev.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(linev.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$x, 21, 4, 543);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(linev, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(linev.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linev.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(linev);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$e.name,
    type: "slot",
    source: '(21:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$f(ctx) {
  let svg;
  let linev;
  let current;
  linev = new LineV({
    props: {
      x: "10",
      y1: "5",
      y2: "40",
      color: "orange",
      width: 4,
      outline: "black",
      "outline-width": "2"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(linev.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(linev.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$x, 27, 4, 685);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(linev, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(linev.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linev.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(linev);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$f.name,
    type: "slot",
    source: '(27:2) <Hst.Variant title=\\"Custom attributes\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$g(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let linev;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({
    props: {
      showGridLines: false,
      showTickLines: true
    },
    $$inline: true
  });
  linev = new LineV({
    props: { xData: ctx[1][1].y },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      create_component(linev.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(linev.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(linev, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      transition_in(linev.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      transition_out(linev.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(linev, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$g.name,
    type: "slot",
    source: "(49:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$g(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$g] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 4) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$g.name,
    type: "slot",
    source: '(43:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$h(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_2$g] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-BMRvenm6e6W5");
      add_location(div, file$x, 41, 4, 943);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 4) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$h.name,
    type: "slot",
    source: '(41:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot$h(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_5$e] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Custom attributes",
      $$slots: { default: [create_default_slot_4$f] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_1$h] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 4) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 4) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 4) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$h.name,
    type: "slot",
    source: `(16:0) <Hst.Story   group=\\"layercake\\"   title=\\"LineV\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$A(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "LineV",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 4) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$A.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$A($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineV_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<LineV_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LineV_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    LineV,
    AxisX,
    AxisY,
    data
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data];
}
class LineV_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$A, create_fragment$A, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineV_story",
      options,
      id: create_fragment$A.name
    });
  }
  get Hst() {
    throw new Error("<LineV_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<LineV_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Path_story_svelte_svelte_type_style_lang = "";
const file$w = "src/lib/components/layercake/Path.story.svelte";
function create_default_slot_5$d(ctx) {
  let svg;
  let path;
  let current;
  path = new Path({
    props: { d: "M0,10L25,25L50,10" },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(path.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(path.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$w, 21, 4, 540);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(path, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(path.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(path.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$d.name,
    type: "slot",
    source: '(21:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$e(ctx) {
  let svg;
  let path;
  let current;
  path = new Path({
    props: {
      d: "M0,10L25,25L50,10",
      color: "orange",
      width: 4,
      outline: "black",
      "outline-width": "2"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(path.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(path.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$w, 27, 4, 681);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(path, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(path.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(path.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$e.name,
    type: "slot",
    source: '(27:2) <Hst.Variant title=\\"Custom attributes\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$f(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let path;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  path = new Path({ $$inline: true });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      create_component(path.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(path.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(path, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      transition_in(path.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      transition_out(path.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(path, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$f.name,
    type: "slot",
    source: "(47:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$f(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$f] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 4) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$f.name,
    type: "slot",
    source: '(41:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$g(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_2$f] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-LNtWwVvuYB2_");
      add_location(div, file$w, 39, 4, 922);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 4) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$g.name,
    type: "slot",
    source: '(39:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot$g(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_5$d] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Custom attributes",
      $$slots: { default: [create_default_slot_4$e] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_1$g] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 4) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 4) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 4) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$g.name,
    type: "slot",
    source: `(16:0) <Hst.Story   group=\\"layercake\\"   title=\\"Path\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$z(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "Path",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 4) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$z.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$z($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Path_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Path_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Path_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    Path,
    AxisX,
    AxisY,
    data
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data];
}
class Path_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$z, create_fragment$z, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Path_story",
      options,
      id: create_fragment$z.name
    });
  }
  get Hst() {
    throw new Error("<Path_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Path_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const RectH_svelte_svelte_type_style_lang = "";
const file$v = "src/lib/components/layercake/RectH.svelte";
function create_fragment$y(ctx) {
  let rect;
  let rect_levels = [
    ctx[9],
    { x: ctx[7] },
    { y: ctx[2] },
    { width: ctx[6] },
    { height: ctx[5] }
  ];
  let rect_data = {};
  for (let i = 0; i < rect_levels.length; i += 1) {
    rect_data = assign(rect_data, rect_levels[i]);
  }
  const block = {
    c: function create() {
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(rect, rect_data);
      toggle_class(rect, "no-outline", ctx[1] === "none");
      set_style(rect, "--_color", ctx[9].fill || ctx[0] || "");
      set_style(rect, "--_outline", ctx[9].stroke || ctx[1] || "");
      set_style(rect, "--_outline-width", ctx[9]["stroke-width"] || ctx[8] || "");
      set_style(rect, "--_opacity", ctx[9].opacity || "");
      toggle_class(rect, "s-w549SSPsVFjB", true);
      add_location(rect, file$v, 29, 0, 793);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(rect, rect_data = get_spread_update(rect_levels, [
        dirty & 512 && ctx2[9],
        dirty & 128 && { x: ctx2[7] },
        dirty & 4 && { y: ctx2[2] },
        dirty & 64 && { width: ctx2[6] },
        dirty & 32 && { height: ctx2[5] }
      ]));
      toggle_class(rect, "no-outline", ctx2[1] === "none");
      set_style(rect, "--_color", ctx2[9].fill || ctx2[0] || "");
      set_style(rect, "--_outline", ctx2[9].stroke || ctx2[1] || "");
      set_style(rect, "--_outline-width", ctx2[9]["stroke-width"] || ctx2[8] || "");
      set_style(rect, "--_opacity", ctx2[9].opacity || "");
      toggle_class(rect, "s-w549SSPsVFjB", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(rect);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$y.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$y($$self, $$props, $$invalidate) {
  let outlineWidth;
  let x;
  let y;
  let width;
  let height;
  let isWidthSet;
  const omit_props_names = ["color", "outline", "data", "yIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $yGet, $$unsubscribe_yGet = noop, $$subscribe_yGet = () => ($$unsubscribe_yGet(), $$unsubscribe_yGet = subscribe(yGet, ($$value) => $$invalidate(13, $yGet = $$value)), yGet);
  let $ctxWidth, $$unsubscribe_ctxWidth = noop, $$subscribe_ctxWidth = () => ($$unsubscribe_ctxWidth(), $$unsubscribe_ctxWidth = subscribe(ctxWidth, ($$value) => $$invalidate(14, $ctxWidth = $$value)), ctxWidth);
  $$self.$$.on_destroy.push(() => $$unsubscribe_yGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_ctxWidth());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RectH", slots, []);
  let { color = void 0 } = $$props;
  let { outline = "none" } = $$props;
  let { data = void 0 } = $$props;
  let { yIndex = 0 } = $$props;
  const ctx = getContext("LayerCake");
  let ctxWidth, yGet;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$new_props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$new_props)
      $$invalidate(10, data = $$new_props.data);
    if ("yIndex" in $$new_props)
      $$invalidate(11, yIndex = $$new_props.yIndex);
  };
  $$self.$capture_state = () => ({
    getContext,
    get,
    color,
    outline,
    data,
    yIndex,
    ctx,
    ctxWidth,
    yGet,
    y,
    height,
    width,
    isWidthSet,
    x,
    outlineWidth,
    $yGet,
    $ctxWidth
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$props)
      $$invalidate(10, data = $$new_props.data);
    if ("yIndex" in $$props)
      $$invalidate(11, yIndex = $$new_props.yIndex);
    if ("ctxWidth" in $$props)
      $$subscribe_ctxWidth($$invalidate(3, ctxWidth = $$new_props.ctxWidth));
    if ("yGet" in $$props)
      $$subscribe_yGet($$invalidate(4, yGet = $$new_props.yGet));
    if ("y" in $$props)
      $$invalidate(2, y = $$new_props.y);
    if ("height" in $$props)
      $$invalidate(5, height = $$new_props.height);
    if ("width" in $$props)
      $$invalidate(6, width = $$new_props.width);
    if ("isWidthSet" in $$props)
      $$invalidate(12, isWidthSet = $$new_props.isWidthSet);
    if ("x" in $$props)
      $$invalidate(7, x = $$new_props.x);
    if ("outlineWidth" in $$props)
      $$invalidate(8, outlineWidth = $$new_props.outlineWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(8, outlineWidth = $$restProps["outline-width"]);
    $$invalidate(7, x = $$restProps.x || 0);
    $$invalidate(2, y = $$restProps.y || 0);
    $$invalidate(6, width = $$restProps.width || 100);
    $$invalidate(5, height = $$restProps.height || 20);
    $$invalidate(12, isWidthSet = $$restProps.width != void 0);
    if ($$self.$$.dirty & 31748) {
      if (data != void 0 && ctx != void 0) {
        $$subscribe_ctxWidth($$invalidate(3, ctxWidth = ctx.width));
        $$subscribe_yGet($$invalidate(4, yGet = ctx.yGet));
        $$invalidate(7, x = 0);
        $$invalidate(2, y = get($yGet, data[1], yIndex));
        if (!isWidthSet)
          $$invalidate(6, width = $ctxWidth);
        let y2 = get($yGet, data[0], yIndex);
        $$invalidate(5, height = y2 - y);
      }
    }
  };
  return [
    color,
    outline,
    y,
    ctxWidth,
    yGet,
    height,
    width,
    x,
    outlineWidth,
    $$restProps,
    data,
    yIndex,
    isWidthSet,
    $yGet,
    $ctxWidth
  ];
}
class RectH extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$y, create_fragment$y, safe_not_equal, {
      color: 0,
      outline: 1,
      data: 10,
      yIndex: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RectH",
      options,
      id: create_fragment$y.name
    });
  }
  get color() {
    throw new Error("<RectH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<RectH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<RectH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<RectH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<RectH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<RectH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yIndex() {
    throw new Error("<RectH>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yIndex(value) {
    throw new Error("<RectH>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const RectH_story_svelte_svelte_type_style_lang = "";
const file$u = "src/lib/components/layercake/RectH.story.svelte";
function create_default_slot_5$c(ctx) {
  let svg;
  let recth;
  let current;
  recth = new RectH({ $$inline: true });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(recth.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(recth.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$u, 21, 4, 543);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(recth, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(recth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(recth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(recth);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$c.name,
    type: "slot",
    source: '(21:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$d(ctx) {
  let svg;
  let recth;
  let current;
  recth = new RectH({
    props: {
      x: "10",
      y: "10",
      width: "30",
      height: "10",
      color: "orange",
      outline: "black",
      "outline-width": "2"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(recth.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(recth.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$u, 27, 4, 663);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(recth, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(recth.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(recth.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(recth);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$d.name,
    type: "slot",
    source: '(27:2) <Hst.Variant title=\\"Custom attributes\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$e(ctx) {
  let recth;
  let t0;
  let axisx;
  let t1;
  let axisy;
  let current;
  recth = new RectH({
    props: {
      data: [ctx[1][0], ctx[1][1]]
    },
    $$inline: true
  });
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  const block = {
    c: function create() {
      create_component(recth.$$.fragment);
      t0 = space();
      create_component(axisx.$$.fragment);
      t1 = space();
      create_component(axisy.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(recth.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisx.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(recth, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(axisy, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(recth.$$.fragment, local);
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(recth.$$.fragment, local);
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(recth, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(axisy, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$e.name,
    type: "slot",
    source: "(49:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$e(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$e] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 4) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$e.name,
    type: "slot",
    source: '(43:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$f(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_2$e] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-6p4yXVOqq_vQ");
      add_location(div, file$u, 41, 4, 926);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 4) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$f.name,
    type: "slot",
    source: '(41:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot$f(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_5$c] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Custom attributes",
      $$slots: { default: [create_default_slot_4$d] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_1$f] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 4) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 4) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 4) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$f.name,
    type: "slot",
    source: `(16:0) <Hst.Story   group=\\"layercake\\"   title=\\"RectH\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$x(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "RectH",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 4) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$x.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$x($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RectH_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<RectH_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RectH_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    RectH,
    AxisX,
    AxisY,
    data
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data];
}
class RectH_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$x, create_fragment$x, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RectH_story",
      options,
      id: create_fragment$x.name
    });
  }
  get Hst() {
    throw new Error("<RectH_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<RectH_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const RectV_svelte_svelte_type_style_lang = "";
const file$t = "src/lib/components/layercake/RectV.svelte";
function create_fragment$w(ctx) {
  let rect;
  let rect_levels = [
    ctx[9],
    { x: ctx[2] },
    { y: ctx[7] },
    { width: ctx[6] },
    { height: ctx[3] }
  ];
  let rect_data = {};
  for (let i = 0; i < rect_levels.length; i += 1) {
    rect_data = assign(rect_data, rect_levels[i]);
  }
  const block = {
    c: function create() {
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(rect, rect_data);
      toggle_class(rect, "no-outline", ctx[1] === "none");
      set_style(rect, "--_color", ctx[9].fill || ctx[0] || "");
      set_style(rect, "--_outline", ctx[9].stroke || ctx[1] || "");
      set_style(rect, "--_outline-width", ctx[9]["stroke-width"] || ctx[8] || "");
      set_style(rect, "--_opacity", ctx[9].opacity || "");
      toggle_class(rect, "s-UTcMMgL8GiZl", true);
      add_location(rect, file$t, 29, 0, 816);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(rect, rect_data = get_spread_update(rect_levels, [
        dirty & 512 && ctx2[9],
        dirty & 4 && { x: ctx2[2] },
        dirty & 128 && { y: ctx2[7] },
        dirty & 64 && { width: ctx2[6] },
        dirty & 8 && { height: ctx2[3] }
      ]));
      toggle_class(rect, "no-outline", ctx2[1] === "none");
      set_style(rect, "--_color", ctx2[9].fill || ctx2[0] || "");
      set_style(rect, "--_outline", ctx2[9].stroke || ctx2[1] || "");
      set_style(rect, "--_outline-width", ctx2[9]["stroke-width"] || ctx2[8] || "");
      set_style(rect, "--_opacity", ctx2[9].opacity || "");
      toggle_class(rect, "s-UTcMMgL8GiZl", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(rect);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$w.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$w($$self, $$props, $$invalidate) {
  let outlineWidth;
  let x;
  let y;
  let width;
  let height;
  let isHeightSet;
  const omit_props_names = ["color", "outline", "data", "xIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $xGet, $$unsubscribe_xGet = noop, $$subscribe_xGet = () => ($$unsubscribe_xGet(), $$unsubscribe_xGet = subscribe(xGet, ($$value) => $$invalidate(13, $xGet = $$value)), xGet);
  let $ctxHeight, $$unsubscribe_ctxHeight = noop, $$subscribe_ctxHeight = () => ($$unsubscribe_ctxHeight(), $$unsubscribe_ctxHeight = subscribe(ctxHeight, ($$value) => $$invalidate(14, $ctxHeight = $$value)), ctxHeight);
  $$self.$$.on_destroy.push(() => $$unsubscribe_xGet());
  $$self.$$.on_destroy.push(() => $$unsubscribe_ctxHeight());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RectV", slots, []);
  let { color = void 0 } = $$props;
  let { outline = "none" } = $$props;
  let { data = void 0 } = $$props;
  let { xIndex = 0 } = $$props;
  const ctx = getContext("LayerCake");
  let ctxHeight, xGet;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$new_props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$new_props)
      $$invalidate(10, data = $$new_props.data);
    if ("xIndex" in $$new_props)
      $$invalidate(11, xIndex = $$new_props.xIndex);
  };
  $$self.$capture_state = () => ({
    getContext,
    get,
    color,
    outline,
    data,
    xIndex,
    ctx,
    ctxHeight,
    xGet,
    x,
    width,
    height,
    y,
    isHeightSet,
    outlineWidth,
    $xGet,
    $ctxHeight
  });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(0, color = $$new_props.color);
    if ("outline" in $$props)
      $$invalidate(1, outline = $$new_props.outline);
    if ("data" in $$props)
      $$invalidate(10, data = $$new_props.data);
    if ("xIndex" in $$props)
      $$invalidate(11, xIndex = $$new_props.xIndex);
    if ("ctxHeight" in $$props)
      $$subscribe_ctxHeight($$invalidate(4, ctxHeight = $$new_props.ctxHeight));
    if ("xGet" in $$props)
      $$subscribe_xGet($$invalidate(5, xGet = $$new_props.xGet));
    if ("x" in $$props)
      $$invalidate(2, x = $$new_props.x);
    if ("width" in $$props)
      $$invalidate(6, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(3, height = $$new_props.height);
    if ("y" in $$props)
      $$invalidate(7, y = $$new_props.y);
    if ("isHeightSet" in $$props)
      $$invalidate(12, isHeightSet = $$new_props.isHeightSet);
    if ("outlineWidth" in $$props)
      $$invalidate(8, outlineWidth = $$new_props.outlineWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $$invalidate(8, outlineWidth = $$restProps["outline-width"]);
    $$invalidate(2, x = $$restProps.x || 0);
    $$invalidate(7, y = $$restProps.y || 0);
    $$invalidate(6, width = $$restProps.width || 20);
    $$invalidate(3, height = $$restProps.height || 100);
    $$invalidate(12, isHeightSet = $$restProps.height != void 0);
    if ($$self.$$.dirty & 31756) {
      if (data != void 0 && ctx != void 0) {
        $$subscribe_ctxHeight($$invalidate(4, ctxHeight = ctx.height));
        $$subscribe_xGet($$invalidate(5, xGet = ctx.xGet));
        $$invalidate(2, x = get($xGet, data[0], xIndex));
        if (!isHeightSet)
          $$invalidate(3, height = $ctxHeight);
        $$invalidate(7, y = $ctxHeight - height);
        let x2 = get($xGet, data[1], xIndex);
        $$invalidate(6, width = x2 - x);
      }
    }
  };
  return [
    color,
    outline,
    x,
    height,
    ctxHeight,
    xGet,
    width,
    y,
    outlineWidth,
    $$restProps,
    data,
    xIndex,
    isHeightSet,
    $xGet,
    $ctxHeight
  ];
}
class RectV extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$w, create_fragment$w, safe_not_equal, {
      color: 0,
      outline: 1,
      data: 10,
      xIndex: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RectV",
      options,
      id: create_fragment$w.name
    });
  }
  get color() {
    throw new Error("<RectV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<RectV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<RectV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<RectV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<RectV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<RectV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xIndex() {
    throw new Error("<RectV>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xIndex(value) {
    throw new Error("<RectV>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const RectV_story_svelte_svelte_type_style_lang = "";
const file$s = "src/lib/components/layercake/RectV.story.svelte";
function create_default_slot_5$b(ctx) {
  let svg;
  let rectv;
  let current;
  rectv = new RectV({ $$inline: true });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(rectv.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(rectv.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$s, 21, 4, 543);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(rectv, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(rectv.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rectv.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(rectv);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$b.name,
    type: "slot",
    source: '(21:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$c(ctx) {
  let svg;
  let rectv;
  let current;
  rectv = new RectV({
    props: {
      x: "10",
      y: "10",
      width: "30",
      height: "10",
      color: "orange",
      outline: "black",
      "outline-width": "2"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(rectv.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, height: true });
      var svg_nodes = children(svg);
      claim_component(rectv.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "50");
      attr_dev(svg, "height", "50");
      add_location(svg, file$s, 27, 4, 663);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      mount_component(rectv, svg, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(rectv.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rectv.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      destroy_component(rectv);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$c.name,
    type: "slot",
    source: '(27:2) <Hst.Variant title=\\"Custom attributes\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$d(ctx) {
  let rectv;
  let t0;
  let axisx;
  let t1;
  let axisy;
  let current;
  rectv = new RectV({
    props: {
      data: [ctx[1][1], ctx[1][2]]
    },
    $$inline: true
  });
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  const block = {
    c: function create() {
      create_component(rectv.$$.fragment);
      t0 = space();
      create_component(axisx.$$.fragment);
      t1 = space();
      create_component(axisy.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rectv.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisx.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rectv, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(axisy, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(rectv.$$.fragment, local);
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rectv.$$.fragment, local);
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rectv, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(axisy, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$d.name,
    type: "slot",
    source: "(49:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$d(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$d] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 4) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$d.name,
    type: "slot",
    source: '(43:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_1$e(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[1],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_2$d] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-Emb0mmxfPMwN");
      add_location(div, file$s, 41, 4, 926);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 4) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$e.name,
    type: "slot",
    source: '(41:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_default_slot$e(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_5$b] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Custom attributes",
      $$slots: { default: [create_default_slot_4$c] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: { default: [create_default_slot_1$e] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 4) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 4) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 4) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$e.name,
    type: "slot",
    source: `(16:0) <Hst.Story   group=\\"layercake\\"   title=\\"RectV\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$v(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "RectV",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 4) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$v.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$v($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RectV_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<RectV_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RectV_story> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    RectV,
    AxisX,
    AxisY,
    data
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, data];
}
class RectV_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$v, create_fragment$v, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RectV_story",
      options,
      id: create_fragment$v.name
    });
  }
  get Hst() {
    throw new Error("<RectV_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<RectV_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const SvgText_story_svelte_svelte_type_style_lang = "";
const file$r = "src/lib/components/layercake/SvgText.story.svelte";
function create_default_slot_24(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_24.name,
    type: "slot",
    source: "(35:10) <SvgText data={data[2]}>",
    ctx
  });
  return block;
}
function create_default_slot_23(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let svgtext;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  svgtext = new SvgText({
    props: {
      data: ctx[2][2],
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      create_component(svgtext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(svgtext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(svgtext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svgtext_changes = {};
      if (dirty & 66) {
        svgtext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext.$set(svgtext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      transition_in(svgtext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      transition_out(svgtext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(svgtext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: "(32:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 66) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: '(26:6) <LayerCake         {data}         padding={{ top: 6, right: 8, bottom: 24, left: 24 }}         x=\\"x\\"         y=\\"y\\"       >',
    ctx
  });
  return block;
}
function create_default_slot_21(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { top: 6, right: 8, bottom: 24, left: 24 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-kkUATs4YyhRY");
      add_location(div, file$r, 24, 4, 647);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 66) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_21.name,
    type: "slot",
    source: '(24:2) <Hst.Variant title=\\"Within chart\\">',
    ctx
  });
  return block;
}
function create_controls_slot_2$1(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding(value) {
    ctx[3](value);
  }
  let hst_text_props = { title: "Text" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot_2$1.name,
    type: "slot",
    source: '(40:4) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_default_slot_20(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_20.name,
    type: "slot",
    source: '(51:10) <SvgText             data={data[2]}             color=\\"orange\\"             outline=\\"black\\"             outline-width=\\"2\\"           >',
    ctx
  });
  return block;
}
function create_default_slot_19(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let svgtext;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  svgtext = new SvgText({
    props: {
      data: ctx[2][2],
      color: "orange",
      outline: "black",
      "outline-width": "2",
      $$slots: { default: [create_default_slot_20] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      create_component(svgtext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(svgtext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(svgtext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svgtext_changes = {};
      if (dirty & 66) {
        svgtext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext.$set(svgtext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      transition_in(svgtext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      transition_out(svgtext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(svgtext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_19.name,
    type: "slot",
    source: "(48:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_18$2(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_19] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 66) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_18$2.name,
    type: "slot",
    source: '(47:6) <LayerCake {data} padding={{ left: 20, bottom: 30 }} x=\\"x\\" y=\\"y\\">',
    ctx
  });
  return block;
}
function create_default_slot_17$2(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { left: 20, bottom: 30 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_18$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-kkUATs4YyhRY");
      add_location(div, file$r, 45, 4, 1131);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 66) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17$2.name,
    type: "slot",
    source: '(45:2) <Hst.Variant title=\\"With custom attributes\\">',
    ctx
  });
  return block;
}
function create_controls_slot_1$2(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding_1(value) {
    ctx[4](value);
  }
  let hst_text_props = { title: "Text" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding_1, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot_1$2.name,
    type: "slot",
    source: '(63:4) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_default_slot_16$2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16$2.name,
    type: "slot",
    source: "(74:10) <SvgText data={data[2]} xOffset={5} yOffset={5}>",
    ctx
  });
  return block;
}
function create_default_slot_15$2(ctx) {
  let axisx;
  let t0;
  let axisy;
  let t1;
  let svgtext;
  let current;
  axisx = new AxisX({ $$inline: true });
  axisy = new AxisY({ $$inline: true });
  svgtext = new SvgText({
    props: {
      data: ctx[2][2],
      xOffset: 5,
      yOffset: 5,
      $$slots: { default: [create_default_slot_16$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(axisx.$$.fragment);
      t0 = space();
      create_component(axisy.$$.fragment);
      t1 = space();
      create_component(svgtext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(axisx.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(axisy.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(svgtext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(axisx, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(axisy, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(svgtext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svgtext_changes = {};
      if (dirty & 66) {
        svgtext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext.$set(svgtext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(axisx.$$.fragment, local);
      transition_in(axisy.$$.fragment, local);
      transition_in(svgtext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(axisx.$$.fragment, local);
      transition_out(axisy.$$.fragment, local);
      transition_out(svgtext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(axisx, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(axisy, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(svgtext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15$2.name,
    type: "slot",
    source: "(71:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_14$2(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_15$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 66) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14$2.name,
    type: "slot",
    source: '(70:6) <LayerCake {data} padding={{ left: 20, bottom: 30 }} x=\\"x\\" y=\\"y\\">',
    ctx
  });
  return block;
}
function create_default_slot_13$2(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { left: 20, bottom: 30 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_14$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-kkUATs4YyhRY");
      add_location(div, file$r, 68, 4, 1687);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 66) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13$2.name,
    type: "slot",
    source: '(68:2) <Hst.Variant title=\\"With custom offsets\\">',
    ctx
  });
  return block;
}
function create_controls_slot$5(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding_2(value) {
    ctx[5](value);
  }
  let hst_text_props = { title: "Text" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding_2, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot$5.name,
    type: "slot",
    source: '(81:4) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_default_slot_12$3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Left");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Left");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12$3.name,
    type: "slot",
    source: '(91:10) <SvgText x=\\"50px\\" y=\\"20px\\" xAlign=\\"left\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_11$3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Center");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Center");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_11$3.name,
    type: "slot",
    source: '(92:10) <SvgText x=\\"50px\\" y=\\"60px\\" xAlign=\\"center\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_10$4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Right");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Right");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10$4.name,
    type: "slot",
    source: '(95:10) <SvgText x=\\"50px\\" y=\\"100px\\" xAlign=\\"right\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_9$5(ctx) {
  let linev;
  let t0;
  let svgtext0;
  let t1;
  let svgtext1;
  let t2;
  let svgtext2;
  let current;
  linev = new LineV({
    props: { x: "50", color: "red" },
    $$inline: true
  });
  svgtext0 = new SvgText({
    props: {
      x: "50px",
      y: "20px",
      xAlign: "left",
      outline: "none",
      $$slots: { default: [create_default_slot_12$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  svgtext1 = new SvgText({
    props: {
      x: "50px",
      y: "60px",
      xAlign: "center",
      outline: "none",
      $$slots: { default: [create_default_slot_11$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  svgtext2 = new SvgText({
    props: {
      x: "50px",
      y: "100px",
      xAlign: "right",
      outline: "none",
      $$slots: { default: [create_default_slot_10$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(linev.$$.fragment);
      t0 = space();
      create_component(svgtext0.$$.fragment);
      t1 = space();
      create_component(svgtext1.$$.fragment);
      t2 = space();
      create_component(svgtext2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(linev.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(svgtext0.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(svgtext1.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(svgtext2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(linev, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(svgtext0, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(svgtext1, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(svgtext2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svgtext0_changes = {};
      if (dirty & 64) {
        svgtext0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext0.$set(svgtext0_changes);
      const svgtext1_changes = {};
      if (dirty & 64) {
        svgtext1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext1.$set(svgtext1_changes);
      const svgtext2_changes = {};
      if (dirty & 64) {
        svgtext2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext2.$set(svgtext2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(linev.$$.fragment, local);
      transition_in(svgtext0.$$.fragment, local);
      transition_in(svgtext1.$$.fragment, local);
      transition_in(svgtext2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linev.$$.fragment, local);
      transition_out(svgtext0.$$.fragment, local);
      transition_out(svgtext1.$$.fragment, local);
      transition_out(svgtext2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(linev, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(svgtext0, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(svgtext1, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(svgtext2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9$5.name,
    type: "slot",
    source: "(89:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_8$7(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_9$5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 64) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8$7.name,
    type: "slot",
    source: '(88:6) <LayerCake {data} padding={{ left: 20, bottom: 30 }} x=\\"x\\" y=\\"y\\">',
    ctx
  });
  return block;
}
function create_default_slot_7$7(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { left: 20, bottom: 30 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_8$7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-kkUATs4YyhRY");
      add_location(div, file$r, 86, 4, 2158);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 64) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7$7.name,
    type: "slot",
    source: '(86:2) <Hst.Variant title=\\"Align along x-axis\\">',
    ctx
  });
  return block;
}
function create_default_slot_6$8(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Bottom");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Bottom");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$8.name,
    type: "slot",
    source: '(108:10) <SvgText x=\\"30px\\" y=\\"100px\\" yAlign=\\"bottom\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_5$a(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Center");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Center");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$a.name,
    type: "slot",
    source: '(111:10) <SvgText x=\\"100px\\" y=\\"100px\\" yAlign=\\"center\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$b(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Top");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Top");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$b.name,
    type: "slot",
    source: '(114:10) <SvgText x=\\"170px\\" y=\\"100px\\" yAlign=\\"top\\" outline=\\"none\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$c(ctx) {
  let lineh;
  let t0;
  let svgtext0;
  let t1;
  let svgtext1;
  let t2;
  let svgtext2;
  let current;
  lineh = new LineH({
    props: { y: "100", color: "red" },
    $$inline: true
  });
  svgtext0 = new SvgText({
    props: {
      x: "30px",
      y: "100px",
      yAlign: "bottom",
      outline: "none",
      $$slots: { default: [create_default_slot_6$8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  svgtext1 = new SvgText({
    props: {
      x: "100px",
      y: "100px",
      yAlign: "center",
      outline: "none",
      $$slots: { default: [create_default_slot_5$a] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  svgtext2 = new SvgText({
    props: {
      x: "170px",
      y: "100px",
      yAlign: "top",
      outline: "none",
      $$slots: { default: [create_default_slot_4$b] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(lineh.$$.fragment);
      t0 = space();
      create_component(svgtext0.$$.fragment);
      t1 = space();
      create_component(svgtext1.$$.fragment);
      t2 = space();
      create_component(svgtext2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lineh.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(svgtext0.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(svgtext1.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(svgtext2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lineh, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(svgtext0, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(svgtext1, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(svgtext2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svgtext0_changes = {};
      if (dirty & 64) {
        svgtext0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext0.$set(svgtext0_changes);
      const svgtext1_changes = {};
      if (dirty & 64) {
        svgtext1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext1.$set(svgtext1_changes);
      const svgtext2_changes = {};
      if (dirty & 64) {
        svgtext2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svgtext2.$set(svgtext2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineh.$$.fragment, local);
      transition_in(svgtext0.$$.fragment, local);
      transition_in(svgtext1.$$.fragment, local);
      transition_in(svgtext2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineh.$$.fragment, local);
      transition_out(svgtext0.$$.fragment, local);
      transition_out(svgtext1.$$.fragment, local);
      transition_out(svgtext2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(lineh, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(svgtext0, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(svgtext1, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(svgtext2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$c.name,
    type: "slot",
    source: "(106:8) <Svg>",
    ctx
  });
  return block;
}
function create_default_slot_2$c(ctx) {
  let svg;
  let current;
  svg = new Svg({
    props: {
      $$slots: { default: [create_default_slot_3$c] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const svg_changes = {};
      if (dirty & 64) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$c.name,
    type: "slot",
    source: '(105:6) <LayerCake {data} padding={{ left: 20, bottom: 30 }} x=\\"x\\" y=\\"y\\">',
    ctx
  });
  return block;
}
function create_default_slot_1$d(ctx) {
  let div;
  let layercake;
  let current;
  layercake = new LayerCake({
    props: {
      data: ctx[2],
      padding: { left: 20, bottom: 30 },
      x: "x",
      y: "y",
      $$slots: { default: [create_default_slot_2$c] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(layercake.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(layercake.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "layercake s-kkUATs4YyhRY");
      add_location(div, file$r, 103, 4, 2712);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(layercake, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const layercake_changes = {};
      if (dirty & 64) {
        layercake_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layercake.$set(layercake_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layercake.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layercake.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(layercake);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$d.name,
    type: "slot",
    source: '(103:2) <Hst.Variant title=\\"Align on y-axis\\">',
    ctx
  });
  return block;
}
function create_default_slot$d(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let t2;
  let hst_variant3;
  let t3;
  let hst_variant4;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Within chart",
      $$slots: {
        controls: [create_controls_slot_2$1],
        default: [create_default_slot_21]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "With custom attributes",
      $$slots: {
        controls: [create_controls_slot_1$2],
        default: [create_default_slot_17$2]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "With custom offsets",
      $$slots: {
        controls: [create_controls_slot$5],
        default: [create_default_slot_13$2]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant3 = new ctx[0].Variant({
    props: {
      title: "Align along x-axis",
      $$slots: { default: [create_default_slot_7$7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant4 = new ctx[0].Variant({
    props: {
      title: "Align on y-axis",
      $$slots: { default: [create_default_slot_1$d] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
      t2 = space();
      create_component(hst_variant3.$$.fragment);
      t3 = space();
      create_component(hst_variant4.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_variant3.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(hst_variant4.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_variant3, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(hst_variant4, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 66) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 66) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 66) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
      const hst_variant3_changes = {};
      if (dirty & 64) {
        hst_variant3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant3.$set(hst_variant3_changes);
      const hst_variant4_changes = {};
      if (dirty & 64) {
        hst_variant4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant4.$set(hst_variant4_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      transition_in(hst_variant3.$$.fragment, local);
      transition_in(hst_variant4.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      transition_out(hst_variant3.$$.fragment, local);
      transition_out(hst_variant4.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_variant3, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(hst_variant4, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$d.name,
    type: "slot",
    source: `(19:0) <Hst.Story   group=\\"layercake\\"   title=\\"SvgText\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$u(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "layercake",
      title: "SvgText",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 66) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$u.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$u($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvgText_story", slots, []);
  let { Hst } = $$props;
  const data = [
    { x: 0, y: 10 },
    { x: 10, y: 30 },
    { x: 20, y: 25 },
    { x: 30, y: 50 },
    { x: 40, y: 10 },
    { x: 50, y: 0 }
  ];
  let text2 = "Text";
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<SvgText_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SvgText_story> was created with unknown prop '${key}'`);
  });
  function hst_text_value_binding(value) {
    text2 = value;
    $$invalidate(1, text2);
  }
  function hst_text_value_binding_1(value) {
    text2 = value;
    $$invalidate(1, text2);
  }
  function hst_text_value_binding_2(value) {
    text2 = value;
    $$invalidate(1, text2);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    LayerCake,
    Svg,
    SvgText,
    AxisX,
    AxisY,
    LineV,
    LineH,
    data,
    text: text2
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    text2,
    data,
    hst_text_value_binding,
    hst_text_value_binding_1,
    hst_text_value_binding_2
  ];
}
class SvgText_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$u, create_fragment$u, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvgText_story",
      options,
      id: create_fragment$u.name
    });
  }
  get Hst() {
    throw new Error("<SvgText_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<SvgText_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Button_svelte_svelte_type_style_lang = "";
const file$q = "src/lib/components/shared/Button.svelte";
function fallback_block$a(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Label missing");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Label missing");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$a.name,
    type: "fallback",
    source: "(31:8) Label missing",
    ctx
  });
  return block;
}
function create_fragment$t(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const default_slot_or_fallback = default_slot || fallback_block$a(ctx);
  let button_levels = [
    { type: "button" },
    ctx[1],
    { "data-variant": ctx[0] }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, "data-variant": true });
      var button_nodes = children(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(button, "button", true);
      toggle_class(button, "s-e-ddGKLCeTu1", true);
      add_location(button, file$q, 23, 0, 776);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[4], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { "data-variant": ctx2[0] }
      ]));
      toggle_class(button, "button", true);
      toggle_class(button, "s-e-ddGKLCeTu1", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$t.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$t($$self, $$props, $$invalidate) {
  const omit_props_names = ["variant"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { variant = "primary" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("variant" in $$new_props)
      $$invalidate(0, variant = $$new_props.variant);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ variant });
  $$self.$inject_state = ($$new_props) => {
    if ("variant" in $$props)
      $$invalidate(0, variant = $$new_props.variant);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [variant, $$restProps, $$scope, slots, click_handler];
}
class Button extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$t, create_fragment$t, safe_not_equal, { variant: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment$t.name
    });
  }
  get variant() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const file$p = "src/lib/components/icons/SearchIcon.svelte";
function create_if_block$h(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", { id: true });
      var title_1_nodes = children(title_1);
      t = claim_text(title_1_nodes, ctx[0]);
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(title_1, "id", ctx[1]);
      add_location(title_1, file$p, 20, 4, 419);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
      if (dirty & 2) {
        attr_dev(title_1, "id", ctx2[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$h.name,
    type: "if",
    source: "(20:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment$s(ctx) {
  let svg;
  let path;
  let svg_aria_labelledby_value;
  let svg_aria_hidden_value;
  let if_block = ctx[0] && create_if_block$h(ctx);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        role: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        style: true,
        "aria-labelledby": true,
        "aria-hidden": true
      });
      var svg_nodes = children(svg);
      if (if_block)
        if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        "clip-rule": true,
        d: true,
        fill: true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      attr_dev(path, "d", "m13.02 30.005-1.95-.427 1.77-8.089C8.87 20.164 6 16.414 6 12 6 6.48 10.48 2 16 2s10 4.48 10 10c0 5.519-4.48 10-10 10-.41 0-.81-.025-1.21-.073l-1.77 8.078ZM16 4c-4.41 0-8 3.584-8 8 0 4.415 3.59 8 8 8s8-3.585 8-8c0-4.416-3.59-8-8-8Zm-6.02 8.017c0-3.319 2.7-6.014 6.02-6.014v2a4.018 4.018 0 0 0-4.02 4.014h-2Z");
      attr_dev(path, "fill", ctx[2]);
      add_location(path, file$p, 22, 2, 457);
      attr_dev(svg, "role", "img");
      attr_dev(svg, "width", "32");
      attr_dev(svg, "height", "32");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 32 32");
      set_style(svg, "fill-rule", "evenodd");
      set_style(svg, "clip-rule", "evenodd");
      set_style(svg, "stroke-linejoin", "round");
      set_style(svg, "stroke-miterlimit", "2");
      attr_dev(svg, "aria-labelledby", svg_aria_labelledby_value = ctx[0] && ctx[1]);
      attr_dev(svg, "aria-hidden", svg_aria_hidden_value = ctx[0] === void 0);
      add_location(svg, file$p, 9, 0, 162);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$h(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 4) {
        attr_dev(path, "fill", ctx2[2]);
      }
      if (dirty & 3 && svg_aria_labelledby_value !== (svg_aria_labelledby_value = ctx2[0] && ctx2[1])) {
        attr_dev(svg, "aria-labelledby", svg_aria_labelledby_value);
      }
      if (dirty & 1 && svg_aria_hidden_value !== (svg_aria_hidden_value = ctx2[0] === void 0)) {
        attr_dev(svg, "aria-hidden", svg_aria_hidden_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$s.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$s($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SearchIcon", slots, []);
  let { title = void 0 } = $$props;
  let { id = "search-icon--title" } = $$props;
  let { color = "#000000" } = $$props;
  const writable_props = ["title", "id", "color"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SearchIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
  };
  $$self.$capture_state = () => ({ title, id, color });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, id, color];
}
class SearchIcon extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$s, create_fragment$s, safe_not_equal, { title: 0, id: 1, color: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SearchIcon",
      options,
      id: create_fragment$s.name
    });
  }
  get title() {
    throw new Error("<SearchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<SearchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<SearchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<SearchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<SearchIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<SearchIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Button_story_svelte_svelte_type_style_lang = "";
const file$o = "src/lib/components/shared/Button.story.svelte";
function create_default_slot_12$2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12$2.name,
    type: "slot",
    source: "(15:4) <Button {variant} {disabled} on:click={handleClick}>",
    ctx
  });
  return block;
}
function create_default_slot_11$2(ctx) {
  let button;
  let current;
  button = new Button({
    props: {
      variant: ctx[2],
      disabled: ctx[3],
      $$slots: { default: [create_default_slot_12$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[4]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 4)
        button_changes.variant = ctx2[2];
      if (dirty & 8)
        button_changes.disabled = ctx2[3];
      if (dirty & 258) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_11$2.name,
    type: "slot",
    source: '(14:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_10$3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10$3.name,
    type: "slot",
    source: '(21:4) <Button {variant} {disabled} on:click={handleClick} class=\\"w-full\\">',
    ctx
  });
  return block;
}
function create_default_slot_9$4(ctx) {
  let button;
  let current;
  button = new Button({
    props: {
      variant: ctx[2],
      disabled: ctx[3],
      class: "w-full",
      $$slots: { default: [create_default_slot_10$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[4]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 4)
        button_changes.variant = ctx2[2];
      if (dirty & 8)
        button_changes.disabled = ctx2[3];
      if (dirty & 258) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9$4.name,
    type: "slot",
    source: '(20:2) <Hst.Variant title=\\"Full width\\">',
    ctx
  });
  return block;
}
function create_default_slot_8$6(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8$6.name,
    type: "slot",
    source: '(27:4) <Button       {variant}       {disabled}       class=\\"button-with-custom-color\\"       on:click={handleClick}     >',
    ctx
  });
  return block;
}
function create_default_slot_7$6(ctx) {
  let button;
  let current;
  button = new Button({
    props: {
      variant: ctx[2],
      disabled: ctx[3],
      class: "button-with-custom-color",
      $$slots: { default: [create_default_slot_8$6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[4]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 4)
        button_changes.variant = ctx2[2];
      if (dirty & 8)
        button_changes.disabled = ctx2[3];
      if (dirty & 258) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7$6.name,
    type: "slot",
    source: '(26:2) <Hst.Variant title=\\"Custom accent color\\">',
    ctx
  });
  return block;
}
function create_default_slot_6$7(ctx) {
  let searchicon;
  let current;
  searchicon = new SearchIcon({ $$inline: true });
  const block = {
    c: function create() {
      create_component(searchicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(searchicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(searchicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(searchicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(searchicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(searchicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$7.name,
    type: "slot",
    source: '(38:4) <Button {variant} {disabled} class=\\"icon\\" aria-label=\\"Search\\">',
    ctx
  });
  return block;
}
function create_default_slot_5$9(ctx) {
  let button;
  let current;
  button = new Button({
    props: {
      variant: ctx[2],
      disabled: ctx[3],
      class: "icon",
      "aria-label": "Search",
      $$slots: { default: [create_default_slot_6$7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 4)
        button_changes.variant = ctx2[2];
      if (dirty & 8)
        button_changes.disabled = ctx2[3];
      if (dirty & 256) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$9.name,
    type: "slot",
    source: '(37:2) <Hst.Variant title=\\"With icon\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$a(ctx) {
  let searchicon;
  let current;
  searchicon = new SearchIcon({ $$inline: true });
  const block = {
    c: function create() {
      create_component(searchicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(searchicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(searchicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(searchicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(searchicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(searchicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$a.name,
    type: "slot",
    source: '(44:4) <Button {variant} {disabled} class=\\"icon round\\" aria-label=\\"Search\\">',
    ctx
  });
  return block;
}
function create_default_slot_3$b(ctx) {
  let button;
  let current;
  button = new Button({
    props: {
      variant: ctx[2],
      disabled: ctx[3],
      class: "icon round",
      "aria-label": "Search",
      $$slots: { default: [create_default_slot_4$a] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 4)
        button_changes.variant = ctx2[2];
      if (dirty & 8)
        button_changes.disabled = ctx2[3];
      if (dirty & 256) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$b.name,
    type: "slot",
    source: '(43:2) <Hst.Variant title=\\"Round with icon\\">',
    ctx
  });
  return block;
}
function create_default_slot_2$b(ctx) {
  let div;
  let searchicon;
  let t0;
  let span;
  let t1;
  let current;
  searchicon = new SearchIcon({ $$inline: true });
  const block = {
    c: function create() {
      div = element("div");
      create_component(searchicon.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(searchicon.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", {});
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, ctx[1]);
      span_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file$o, 52, 8, 1349);
      attr_dev(div, "class", "splitter align-center");
      add_location(div, file$o, 50, 6, 1282);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(searchicon, div, null);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, span);
      append_hydration_dev(span, t1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & 2)
        set_data_dev(t1, ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(searchicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(searchicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(searchicon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$b.name,
    type: "slot",
    source: "(50:4) <Button {variant} {disabled}>",
    ctx
  });
  return block;
}
function create_default_slot_1$c(ctx) {
  let button;
  let current;
  button = new Button({
    props: {
      variant: ctx[2],
      disabled: ctx[3],
      $$slots: { default: [create_default_slot_2$b] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 4)
        button_changes.variant = ctx2[2];
      if (dirty & 8)
        button_changes.disabled = ctx2[3];
      if (dirty & 258) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$c.name,
    type: "slot",
    source: '(49:2) <Hst.Variant title=\\"Icon and text\\">',
    ctx
  });
  return block;
}
function create_default_slot$c(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let t2;
  let hst_variant3;
  let t3;
  let hst_variant4;
  let t4;
  let hst_variant5;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_11$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Full width",
      $$slots: { default: [create_default_slot_9$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Custom accent color",
      $$slots: { default: [create_default_slot_7$6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant3 = new ctx[0].Variant({
    props: {
      title: "With icon",
      $$slots: { default: [create_default_slot_5$9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant4 = new ctx[0].Variant({
    props: {
      title: "Round with icon",
      $$slots: { default: [create_default_slot_3$b] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant5 = new ctx[0].Variant({
    props: {
      title: "Icon and text",
      $$slots: { default: [create_default_slot_1$c] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
      t2 = space();
      create_component(hst_variant3.$$.fragment);
      t3 = space();
      create_component(hst_variant4.$$.fragment);
      t4 = space();
      create_component(hst_variant5.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_variant3.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(hst_variant4.$$.fragment, nodes);
      t4 = claim_space(nodes);
      claim_component(hst_variant5.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_variant3, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(hst_variant4, target, anchor);
      insert_hydration_dev(target, t4, anchor);
      mount_component(hst_variant5, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 270) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 270) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 270) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
      const hst_variant3_changes = {};
      if (dirty & 268) {
        hst_variant3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant3.$set(hst_variant3_changes);
      const hst_variant4_changes = {};
      if (dirty & 268) {
        hst_variant4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant4.$set(hst_variant4_changes);
      const hst_variant5_changes = {};
      if (dirty & 270) {
        hst_variant5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant5.$set(hst_variant5_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      transition_in(hst_variant3.$$.fragment, local);
      transition_in(hst_variant4.$$.fragment, local);
      transition_in(hst_variant5.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      transition_out(hst_variant3.$$.fragment, local);
      transition_out(hst_variant4.$$.fragment, local);
      transition_out(hst_variant5.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_variant3, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(hst_variant4, detaching);
      if (detaching)
        detach_dev(t4);
      destroy_component(hst_variant5, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$c.name,
    type: "slot",
    source: `(13:0) <Hst.Story group=\\"ui\\" title=\\"Button\\" layout={{ type: 'grid', width: '100%' }}>`,
    ctx
  });
  return block;
}
function create_controls_slot$4(ctx) {
  let hst_text;
  let updating_value;
  let t0;
  let hst_radio;
  let updating_value_1;
  let t1;
  let hst_checkbox;
  let updating_value_2;
  let current;
  function hst_text_value_binding(value) {
    ctx[5](value);
  }
  let hst_text_props = { title: "Content" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding, ctx[1]));
  function hst_radio_value_binding(value) {
    ctx[6](value);
  }
  let hst_radio_props = {
    title: "Variant",
    options: [
      { label: "Primary", value: "primary" },
      { label: "Secondary", value: "secondary" },
      { label: "Tertiary", value: "tertiary" }
    ]
  };
  if (ctx[2] !== void 0) {
    hst_radio_props.value = ctx[2];
  }
  hst_radio = new ctx[0].Radio({ props: hst_radio_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_radio, "value", hst_radio_value_binding, ctx[2]));
  function hst_checkbox_value_binding(value) {
    ctx[7](value);
  }
  let hst_checkbox_props = { title: "Disabled" };
  if (ctx[3] !== void 0) {
    hst_checkbox_props.value = ctx[3];
  }
  hst_checkbox = new ctx[0].Checkbox({
    props: hst_checkbox_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hst_checkbox, "value", hst_checkbox_value_binding, ctx[3]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
      t0 = space();
      create_component(hst_radio.$$.fragment);
      t1 = space();
      create_component(hst_checkbox.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_radio.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_checkbox.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_radio, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_checkbox, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
      const hst_radio_changes = {};
      if (!updating_value_1 && dirty & 4) {
        updating_value_1 = true;
        hst_radio_changes.value = ctx2[2];
        add_flush_callback(() => updating_value_1 = false);
      }
      hst_radio.$set(hst_radio_changes);
      const hst_checkbox_changes = {};
      if (!updating_value_2 && dirty & 8) {
        updating_value_2 = true;
        hst_checkbox_changes.value = ctx2[3];
        add_flush_callback(() => updating_value_2 = false);
      }
      hst_checkbox.$set(hst_checkbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      transition_in(hst_radio.$$.fragment, local);
      transition_in(hst_checkbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      transition_out(hst_radio.$$.fragment, local);
      transition_out(hst_checkbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_radio, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_checkbox, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot$4.name,
    type: "slot",
    source: '(58:2) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_fragment$r(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "ui",
      title: "Button",
      layout: { type: "grid", width: "100%" },
      $$slots: {
        controls: [create_controls_slot$4],
        default: [create_default_slot$c]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 270) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$r.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$r($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button_story", slots, []);
  let { Hst } = $$props;
  let content = "Content";
  let variant = "primary";
  let disabled = false;
  function handleClick(e) {
    logEvent("click", e);
  }
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Button_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Button_story> was created with unknown prop '${key}'`);
  });
  function hst_text_value_binding(value) {
    content = value;
    $$invalidate(1, content);
  }
  function hst_radio_value_binding(value) {
    variant = value;
    $$invalidate(2, variant);
  }
  function hst_checkbox_value_binding(value) {
    disabled = value;
    $$invalidate(3, disabled);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    logEvent,
    Hst,
    Button,
    SearchIcon,
    content,
    variant,
    disabled,
    handleClick
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("content" in $$props2)
      $$invalidate(1, content = $$props2.content);
    if ("variant" in $$props2)
      $$invalidate(2, variant = $$props2.variant);
    if ("disabled" in $$props2)
      $$invalidate(3, disabled = $$props2.disabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    content,
    variant,
    disabled,
    handleClick,
    hst_text_value_binding,
    hst_radio_value_binding,
    hst_checkbox_value_binding
  ];
}
class Button_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$r, create_fragment$r, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button_story",
      options,
      id: create_fragment$r.name
    });
  }
  get Hst() {
    throw new Error("<Button_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Button_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const ChartFooter_svelte_svelte_type_style_lang = "";
const file$n = "src/lib/components/shared/ChartFooter.svelte";
function fallback_block$9(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Footer missing");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Footer missing");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$9.name,
    type: "fallback",
    source: "(14:8) Footer missing",
    ctx
  });
  return block;
}
function create_fragment$q(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  const default_slot_or_fallback = default_slot || fallback_block$9(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty(ctx[0].class) + " s-OJNQwUYlvLPZ");
      attr_dev(div, "style", div_style_value = ctx[0].style);
      toggle_class(div, "chart-footer", true);
      add_location(div, file$n, 8, 0, 94);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1 && div_class_value !== (div_class_value = null_to_empty(ctx2[0].class) + " s-OJNQwUYlvLPZ")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & 1 && div_style_value !== (div_style_value = ctx2[0].style)) {
        attr_dev(div, "style", div_style_value);
      }
      if (!current || dirty & 1) {
        toggle_class(div, "chart-footer", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$q.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$q($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChartFooter", slots, ["default"]);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [$$restProps, $$scope, slots];
}
class ChartFooter extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$q, create_fragment$q, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChartFooter",
      options,
      id: create_fragment$q.name
    });
  }
}
function create_default_slot_1$b(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$b.name,
    type: "slot",
    source: "(11:2) <ChartFooter>",
    ctx
  });
  return block;
}
function create_default_slot$b(ctx) {
  let chartfooter;
  let current;
  chartfooter = new ChartFooter({
    props: {
      $$slots: { default: [create_default_slot_1$b] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chartfooter.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chartfooter.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chartfooter, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chartfooter_changes = {};
      if (dirty & 10) {
        chartfooter_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chartfooter.$set(chartfooter_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chartfooter.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chartfooter.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chartfooter, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$b.name,
    type: "slot",
    source: `(6:0) <Hst.Story   group=\\"viz\\"   title=\\"ChartFooter\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_controls_slot$3(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding(value) {
    ctx[2](value);
  }
  let hst_text_props = { title: "Content" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot$3.name,
    type: "slot",
    source: '(13:2) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_fragment$p(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "viz",
      title: "ChartFooter",
      layout: { type: "grid", width: "100%" },
      $$slots: {
        controls: [create_controls_slot$3],
        default: [create_default_slot$b]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 10) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$p.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$p($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChartFooter_story", slots, []);
  let { Hst } = $$props;
  let content = "Footer";
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<ChartFooter_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChartFooter_story> was created with unknown prop '${key}'`);
  });
  function hst_text_value_binding(value) {
    content = value;
    $$invalidate(1, content);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({ Hst, ChartFooter, content });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("content" in $$props2)
      $$invalidate(1, content = $$props2.content);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, content, hst_text_value_binding];
}
class ChartFooter_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$p, create_fragment$p, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChartFooter_story",
      options,
      id: create_fragment$p.name
    });
  }
  get Hst() {
    throw new Error("<ChartFooter_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<ChartFooter_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const ChartHeader_svelte_svelte_type_style_lang = "";
const file$m = "src/lib/components/shared/ChartHeader.svelte";
const get_subtitle_slot_changes = (dirty) => ({});
const get_subtitle_slot_context = (ctx) => ({});
const get_title_slot_changes = (dirty) => ({});
const get_title_slot_context = (ctx) => ({});
function create_if_block_2$7(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const default_slot_or_fallback = default_slot || fallback_block$8(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$7.name,
    type: "if",
    source: "(17:4) {#if $$slots.default}",
    ctx
  });
  return block;
}
function fallback_block$8(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Title missing");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Title missing");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$8.name,
    type: "fallback",
    source: "(18:12) Title missing",
    ctx
  });
  return block;
}
function create_if_block_1$7(ctx) {
  let current;
  const title_slot_template = ctx[3].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[2], get_title_slot_context);
  const block = {
    c: function create() {
      if (title_slot)
        title_slot.c();
    },
    l: function claim(nodes) {
      if (title_slot)
        title_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (title_slot) {
        title_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(title_slot_template, ctx2[2], dirty, get_title_slot_changes),
            get_title_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (title_slot)
        title_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$7.name,
    type: "if",
    source: "(20:4) {#if $$slots.title}",
    ctx
  });
  return block;
}
function create_if_block$g(ctx) {
  let p;
  let current;
  const subtitle_slot_template = ctx[3].subtitle;
  const subtitle_slot = create_slot(subtitle_slot_template, ctx, ctx[2], get_subtitle_slot_context);
  const block = {
    c: function create() {
      p = element("p");
      if (subtitle_slot)
        subtitle_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (subtitle_slot)
        subtitle_slot.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "class", "chart-header__subtitle s-ftBKZZ-Zdn0h");
      add_location(p, file$m, 25, 4, 524);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (subtitle_slot) {
        subtitle_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(subtitle_slot_template, ctx2[2], dirty, get_subtitle_slot_changes),
            get_subtitle_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(subtitle_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(subtitle_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (subtitle_slot)
        subtitle_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$g.name,
    type: "if",
    source: "(25:2) {#if $$slots.subtitle}",
    ctx
  });
  return block;
}
function create_fragment$o(ctx) {
  let hgroup;
  let h2;
  let t0;
  let t1;
  let hgroup_class_value;
  let hgroup_style_value;
  let current;
  let if_block0 = ctx[1].default && create_if_block_2$7(ctx);
  let if_block1 = ctx[1].title && create_if_block_1$7(ctx);
  let if_block2 = ctx[1].subtitle && create_if_block$g(ctx);
  const block = {
    c: function create() {
      hgroup = element("hgroup");
      h2 = element("h2");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      hgroup = claim_element(nodes, "HGROUP", { class: true, style: true });
      var hgroup_nodes = children(hgroup);
      h2 = claim_element(hgroup_nodes, "H2", { class: true });
      var h2_nodes = children(h2);
      if (if_block0)
        if_block0.l(h2_nodes);
      t0 = claim_space(h2_nodes);
      if (if_block1)
        if_block1.l(h2_nodes);
      h2_nodes.forEach(detach_dev);
      t1 = claim_space(hgroup_nodes);
      if (if_block2)
        if_block2.l(hgroup_nodes);
      hgroup_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h2, "class", "chart-header__title s-ftBKZZ-Zdn0h");
      add_location(h2, file$m, 15, 2, 322);
      attr_dev(hgroup, "class", hgroup_class_value = null_to_empty(ctx[0].class) + " s-ftBKZZ-Zdn0h");
      attr_dev(hgroup, "style", hgroup_style_value = ctx[0].style);
      toggle_class(hgroup, "chart-header", true);
      add_location(hgroup, file$m, 10, 0, 226);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, hgroup, anchor);
      append_hydration_dev(hgroup, h2);
      if (if_block0)
        if_block0.m(h2, null);
      append_hydration_dev(h2, t0);
      if (if_block1)
        if_block1.m(h2, null);
      append_hydration_dev(hgroup, t1);
      if (if_block2)
        if_block2.m(hgroup, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[1].default) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(h2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[1].title) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$7(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(h2, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[1].subtitle) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$g(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(hgroup, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & 1 && hgroup_class_value !== (hgroup_class_value = null_to_empty(ctx2[0].class) + " s-ftBKZZ-Zdn0h")) {
        attr_dev(hgroup, "class", hgroup_class_value);
      }
      if (!current || dirty & 1 && hgroup_style_value !== (hgroup_style_value = ctx2[0].style)) {
        attr_dev(hgroup, "style", hgroup_style_value);
      }
      if (!current || dirty & 1) {
        toggle_class(hgroup, "chart-header", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(hgroup);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$o.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$o($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChartHeader", slots, ["default", "title", "subtitle"]);
  const $$slots = compute_slots(slots);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  return [$$restProps, $$slots, $$scope, slots];
}
class ChartHeader extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$o, create_fragment$o, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChartHeader",
      options,
      id: create_fragment$o.name
    });
  }
}
function create_default_slot_4$9(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$9.name,
    type: "slot",
    source: "(13:4) <ChartHeader>",
    ctx
  });
  return block;
}
function create_default_slot_3$a(ctx) {
  let chartheader;
  let current;
  chartheader = new ChartHeader({
    props: {
      $$slots: { default: [create_default_slot_4$9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chartheader.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chartheader.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chartheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chartheader_changes = {};
      if (dirty & 66) {
        chartheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chartheader.$set(chartheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chartheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chartheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chartheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$a.name,
    type: "slot",
    source: '(12:2) <Hst.Variant title=\\"Title\\">',
    ctx
  });
  return block;
}
function create_controls_slot_1$1(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding(value) {
    ctx[3](value);
  }
  let hst_text_props = { title: "Title" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot_1$1.name,
    type: "slot",
    source: '(15:4) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_default_slot_2$a(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$a.name,
    type: "slot",
    source: "(21:4) <ChartHeader>",
    ctx
  });
  return block;
}
function create_subtitle_slot(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[2]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[2]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_subtitle_slot.name,
    type: "slot",
    source: '(23:6) <svelte:fragment slot=\\"subtitle\\">',
    ctx
  });
  return block;
}
function create_default_slot_1$a(ctx) {
  let chartheader;
  let current;
  chartheader = new ChartHeader({
    props: {
      $$slots: {
        subtitle: [create_subtitle_slot],
        default: [create_default_slot_2$a]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chartheader.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chartheader.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chartheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chartheader_changes = {};
      if (dirty & 70) {
        chartheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chartheader.$set(chartheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chartheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chartheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chartheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$a.name,
    type: "slot",
    source: '(20:2) <Hst.Variant title=\\"With subtitle\\">',
    ctx
  });
  return block;
}
function create_controls_slot$2(ctx) {
  let hst_text0;
  let updating_value;
  let t;
  let hst_text1;
  let updating_value_1;
  let current;
  function hst_text0_value_binding(value) {
    ctx[4](value);
  }
  let hst_text0_props = { title: "Title" };
  if (ctx[1] !== void 0) {
    hst_text0_props.value = ctx[1];
  }
  hst_text0 = new ctx[0].Text({ props: hst_text0_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text0, "value", hst_text0_value_binding, ctx[1]));
  function hst_text1_value_binding(value) {
    ctx[5](value);
  }
  let hst_text1_props = { title: "Subtitle" };
  if (ctx[2] !== void 0) {
    hst_text1_props.value = ctx[2];
  }
  hst_text1 = new ctx[0].Text({ props: hst_text1_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text1, "value", hst_text1_value_binding, ctx[2]));
  const block = {
    c: function create() {
      create_component(hst_text0.$$.fragment);
      t = space();
      create_component(hst_text1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text0.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(hst_text1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text0, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(hst_text1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text0_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text0_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text0.$set(hst_text0_changes);
      const hst_text1_changes = {};
      if (!updating_value_1 && dirty & 4) {
        updating_value_1 = true;
        hst_text1_changes.value = ctx2[2];
        add_flush_callback(() => updating_value_1 = false);
      }
      hst_text1.$set(hst_text1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text0.$$.fragment, local);
      transition_in(hst_text1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text0.$$.fragment, local);
      transition_out(hst_text1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text0, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(hst_text1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot$2.name,
    type: "slot",
    source: '(26:4) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_default_slot$a(ctx) {
  let hst_variant0;
  let t;
  let hst_variant1;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Title",
      $$slots: {
        controls: [create_controls_slot_1$1],
        default: [create_default_slot_3$a]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "With subtitle",
      $$slots: {
        controls: [create_controls_slot$2],
        default: [create_default_slot_1$a]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t = space();
      create_component(hst_variant1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(hst_variant1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 66) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 70) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(hst_variant1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$a.name,
    type: "slot",
    source: `(7:0) <Hst.Story   group=\\"viz\\"   title=\\"ChartHeader\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$n(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "viz",
      title: "ChartHeader",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 70) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$n.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$n($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChartHeader_story", slots, []);
  let { Hst } = $$props;
  let title = "Chart title";
  let subtitle = "Chart subtitle";
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<ChartHeader_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChartHeader_story> was created with unknown prop '${key}'`);
  });
  function hst_text_value_binding(value) {
    title = value;
    $$invalidate(1, title);
  }
  function hst_text0_value_binding(value) {
    title = value;
    $$invalidate(1, title);
  }
  function hst_text1_value_binding(value) {
    subtitle = value;
    $$invalidate(2, subtitle);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({ Hst, ChartHeader, title, subtitle });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(2, subtitle = $$props2.subtitle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    title,
    subtitle,
    hst_text_value_binding,
    hst_text0_value_binding,
    hst_text1_value_binding
  ];
}
class ChartHeader_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$n, create_fragment$n, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChartHeader_story",
      options,
      id: create_fragment$n.name
    });
  }
  get Hst() {
    throw new Error("<ChartHeader_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<ChartHeader_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const file$l = "src/lib/components/shared/Slant.svelte";
function create_fragment$m(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let div_resize_listener;
  let style___slant_height = `${ctx[4]}px`;
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        style: true,
        "data-slant-position": true,
        "data-slant-direction": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = ctx[5].class);
      attr_dev(div, "style", div_style_value = ctx[5].style);
      attr_dev(div, "data-slant-position", ctx[0]);
      attr_dev(div, "data-slant-direction", ctx[1]);
      add_render_callback(() => ctx[8].call(div));
      toggle_class(div, "slant", true);
      set_style(div, "--slant-height", style___slant_height);
      set_style(div, "--slant-text-color", ctx[3]);
      set_style(div, "--slant-background-color", ctx[2]);
      add_location(div, file$l, 25, 0, 923);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      div_resize_listener = add_resize_listener(div, ctx[8].bind(div));
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 32 && div_class_value !== (div_class_value = ctx2[5].class)) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & 32 && div_style_value !== (div_style_value = ctx2[5].style)) {
        attr_dev(div, "style", div_style_value);
      }
      if (!current || dirty & 1) {
        attr_dev(div, "data-slant-position", ctx2[0]);
      }
      if (!current || dirty & 2) {
        attr_dev(div, "data-slant-direction", ctx2[1]);
      }
      if (!current || dirty & 32) {
        toggle_class(div, "slant", true);
      }
      if (dirty & 16 && style___slant_height !== (style___slant_height = `${ctx2[4]}px`)) {
        set_style(div, "--slant-height", style___slant_height);
      }
      if (dirty & 8) {
        set_style(div, "--slant-text-color", ctx2[3]);
      }
      if (dirty & 4) {
        set_style(div, "--slant-background-color", ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      div_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$m.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$m($$self, $$props, $$invalidate) {
  const omit_props_names = ["position", "direction", "backgroundColor", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Slant", slots, ["default"]);
  let { position = "right" } = $$props;
  let { direction = "forward" } = $$props;
  let { backgroundColor = cUiAccentBlue } = $$props;
  let { color = getHighestContrastColor(backgroundColor) } = $$props;
  let height = 0;
  function div_elementresize_handler() {
    height = this.clientHeight;
    $$invalidate(4, height);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("position" in $$new_props)
      $$invalidate(0, position = $$new_props.position);
    if ("direction" in $$new_props)
      $$invalidate(1, direction = $$new_props.direction);
    if ("backgroundColor" in $$new_props)
      $$invalidate(2, backgroundColor = $$new_props.backgroundColor);
    if ("color" in $$new_props)
      $$invalidate(3, color = $$new_props.color);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tokens,
    getHighestContrastColor,
    position,
    direction,
    backgroundColor,
    color,
    height
  });
  $$self.$inject_state = ($$new_props) => {
    if ("position" in $$props)
      $$invalidate(0, position = $$new_props.position);
    if ("direction" in $$props)
      $$invalidate(1, direction = $$new_props.direction);
    if ("backgroundColor" in $$props)
      $$invalidate(2, backgroundColor = $$new_props.backgroundColor);
    if ("color" in $$props)
      $$invalidate(3, color = $$new_props.color);
    if ("height" in $$props)
      $$invalidate(4, height = $$new_props.height);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    position,
    direction,
    backgroundColor,
    color,
    height,
    $$restProps,
    $$scope,
    slots,
    div_elementresize_handler
  ];
}
class Slant extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$m, create_fragment$m, safe_not_equal, {
      position: 0,
      direction: 1,
      backgroundColor: 2,
      color: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slant",
      options,
      id: create_fragment$m.name
    });
  }
  get position() {
    throw new Error("<Slant>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Slant>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<Slant>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<Slant>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error("<Slant>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error("<Slant>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Slant>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Slant>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const ChartLegend_svelte_svelte_type_style_lang = "";
const file$k = "src/lib/components/shared/ChartLegend.svelte";
function get_each_context$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  child_ctx[7] = i;
  return child_ctx;
}
const get_default_slot_changes$7 = (dirty) => ({ item: dirty & 1 });
const get_default_slot_context$7 = (ctx) => ({ item: ctx[5] });
const get_shape_slot_changes = (dirty) => ({ item: dirty & 1 });
const get_shape_slot_context = (ctx) => ({ item: ctx[5] });
function fallback_block_1(ctx) {
  let slant;
  let current;
  slant = new Slant({
    props: {
      backgroundColor: ctx[1](ctx[5], ctx[7])
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(slant.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(slant.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(slant, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const slant_changes = {};
      if (dirty & 3)
        slant_changes.backgroundColor = ctx2[1](ctx2[5], ctx2[7]);
      slant.$set(slant_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(slant.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(slant.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(slant, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(23:32)          ",
    ctx
  });
  return block;
}
function fallback_block$7(ctx) {
  let t_value = ctx[5] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[5] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$7.name,
    type: "fallback",
    source: "(27:21) {item}",
    ctx
  });
  return block;
}
function create_each_block$8(ctx) {
  let div;
  let t0;
  let span;
  let t1;
  let current;
  const shape_slot_template = ctx[4].shape;
  const shape_slot = create_slot(shape_slot_template, ctx, ctx[3], get_shape_slot_context);
  const shape_slot_or_fallback = shape_slot || fallback_block_1(ctx);
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], get_default_slot_context$7);
  const default_slot_or_fallback = default_slot || fallback_block$7(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (shape_slot_or_fallback)
        shape_slot_or_fallback.c();
      t0 = space();
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (shape_slot_or_fallback)
        shape_slot_or_fallback.l(div_nodes);
      t0 = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "chart-legend__item-label s-h70P6Ra6ZHDf");
      add_location(span, file$k, 25, 6, 666);
      attr_dev(div, "class", "chart-legend__item s-h70P6Ra6ZHDf");
      add_location(div, file$k, 21, 4, 522);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (shape_slot_or_fallback) {
        shape_slot_or_fallback.m(div, null);
      }
      append_hydration_dev(div, t0);
      append_hydration_dev(div, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      append_hydration_dev(div, t1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (shape_slot) {
        if (shape_slot.p && (!current || dirty & 9)) {
          update_slot_base(
            shape_slot,
            shape_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(shape_slot_template, ctx2[3], dirty, get_shape_slot_changes),
            get_shape_slot_context
          );
        }
      } else {
        if (shape_slot_or_fallback && shape_slot_or_fallback.p && (!current || dirty & 3)) {
          shape_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 9)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, get_default_slot_changes$7),
            get_default_slot_context$7
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 1)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(shape_slot_or_fallback, local);
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(shape_slot_or_fallback, local);
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (shape_slot_or_fallback)
        shape_slot_or_fallback.d(detaching);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$8.name,
    type: "each",
    source: "(21:2) {#each items as item, i}",
    ctx
  });
  return block;
}
function create_fragment$l(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let current;
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = null_to_empty(ctx[2].class) + " s-h70P6Ra6ZHDf");
      attr_dev(div, "style", div_style_value = ctx[2].style);
      toggle_class(div, "chart-legend", true);
      add_location(div, file$k, 15, 0, 400);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 11) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$8(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 4 && div_class_value !== (div_class_value = null_to_empty(ctx2[2].class) + " s-h70P6Ra6ZHDf")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & 4 && div_style_value !== (div_style_value = ctx2[2].style)) {
        attr_dev(div, "style", div_style_value);
      }
      if (!current || dirty & 4) {
        toggle_class(div, "chart-legend", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$l.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$l($$self, $$props, $$invalidate) {
  const omit_props_names = ["items", "getItemColor"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChartLegend", slots, ["shape", "default"]);
  let { items } = $$props;
  let { getItemColor } = $$props;
  $$self.$$.on_mount.push(function() {
    if (items === void 0 && !("items" in $$props || $$self.$$.bound[$$self.$$.props["items"]])) {
      console.warn("<ChartLegend> was created without expected prop 'items'");
    }
    if (getItemColor === void 0 && !("getItemColor" in $$props || $$self.$$.bound[$$self.$$.props["getItemColor"]])) {
      console.warn("<ChartLegend> was created without expected prop 'getItemColor'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("items" in $$new_props)
      $$invalidate(0, items = $$new_props.items);
    if ("getItemColor" in $$new_props)
      $$invalidate(1, getItemColor = $$new_props.getItemColor);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Slant, items, getItemColor });
  $$self.$inject_state = ($$new_props) => {
    if ("items" in $$props)
      $$invalidate(0, items = $$new_props.items);
    if ("getItemColor" in $$props)
      $$invalidate(1, getItemColor = $$new_props.getItemColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [items, getItemColor, $$restProps, $$scope, slots];
}
class ChartLegend extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$l, create_fragment$l, safe_not_equal, { items: 0, getItemColor: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChartLegend",
      options,
      id: create_fragment$l.name
    });
  }
  get items() {
    throw new Error("<ChartLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<ChartLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getItemColor() {
    throw new Error("<ChartLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getItemColor(value) {
    throw new Error("<ChartLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const ChartLegend_story_svelte_svelte_type_style_lang = "";
const file$j = "src/lib/components/shared/ChartLegend.story.svelte";
function create_default_slot_5$8(ctx) {
  let chartlegend;
  let current;
  chartlegend = new ChartLegend({
    props: {
      items: ["Beschriftung", "Beschriftung", "Beschriftung"],
      getItemColor: ctx[1]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chartlegend.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chartlegend.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chartlegend, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(chartlegend.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chartlegend.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chartlegend, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$8.name,
    type: "slot",
    source: '(11:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$8(ctx) {
  let t_value = ctx[2].label + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[2].label + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$8.name,
    type: "slot",
    source: "(22:4) <ChartLegend       items={[         { label: 'Beschriftung', color: tokens.cCategoryBlue },         { label: 'Beschriftung', color: tokens.cCategoryGreen },         { label: 'Beschriftung', color: tokens.cCategoryPurple },       ]}       getItemColor={(item) => item.color}       let:item     >",
    ctx
  });
  return block;
}
function create_default_slot_3$9(ctx) {
  let chartlegend;
  let current;
  chartlegend = new ChartLegend({
    props: {
      items: [
        {
          label: "Beschriftung",
          color: cCategoryBlue
        },
        {
          label: "Beschriftung",
          color: cCategoryGreen
        },
        {
          label: "Beschriftung",
          color: cCategoryPurple
        }
      ],
      getItemColor: func_1$2,
      $$slots: {
        default: [
          create_default_slot_4$8,
          ({ item }) => ({ 2: item }),
          ({ item }) => item ? 4 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chartlegend.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chartlegend.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chartlegend, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chartlegend_changes = {};
      if (dirty & 12) {
        chartlegend_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chartlegend.$set(chartlegend_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chartlegend.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chartlegend.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chartlegend, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$9.name,
    type: "slot",
    source: '(21:2) <Hst.Variant title=\\"With complex items\\">',
    ctx
  });
  return block;
}
function create_default_slot_2$9(ctx) {
  let t_value = ctx[2].label + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[2].label + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$9.name,
    type: "slot",
    source: "(36:4) <ChartLegend       items={[         { label: 'Beschriftung', color: tokens.cCategoryBlue },         { label: 'Beschriftung', color: tokens.cCategoryGreen },         { label: 'Beschriftung', color: tokens.cCategoryPurple },       ]}       getItemColor={(item) => item.color}       let:item     >",
    ctx
  });
  return block;
}
function create_shape_slot(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { slot: true, class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "slot", "shape");
      attr_dev(div, "class", "circle s-B0Etwbfms3eS");
      set_style(div, "--color", ctx[2].color);
      add_location(div, file$j, 44, 6, 1237);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4) {
        set_style(div, "--color", ctx2[2].color);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_shape_slot.name,
    type: "slot",
    source: "(45:6) ",
    ctx
  });
  return block;
}
function create_default_slot_1$9(ctx) {
  let chartlegend;
  let current;
  chartlegend = new ChartLegend({
    props: {
      items: [
        {
          label: "Beschriftung",
          color: cCategoryBlue
        },
        {
          label: "Beschriftung",
          color: cCategoryGreen
        },
        {
          label: "Beschriftung",
          color: cCategoryPurple
        }
      ],
      getItemColor: func_2,
      $$slots: {
        shape: [
          create_shape_slot,
          ({ item }) => ({ 2: item }),
          ({ item }) => item ? 4 : 0
        ],
        default: [
          create_default_slot_2$9,
          ({ item }) => ({ 2: item }),
          ({ item }) => item ? 4 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(chartlegend.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chartlegend.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chartlegend, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chartlegend_changes = {};
      if (dirty & 12) {
        chartlegend_changes.$$scope = { dirty, ctx: ctx2 };
      }
      chartlegend.$set(chartlegend_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chartlegend.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chartlegend.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chartlegend, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$9.name,
    type: "slot",
    source: '(35:2) <Hst.Variant title=\\"With custom shapes\\">',
    ctx
  });
  return block;
}
function create_default_slot$9(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_5$8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "With complex items",
      $$slots: { default: [create_default_slot_3$9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "With custom shapes",
      $$slots: { default: [create_default_slot_1$9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 8) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 8) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 8) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$9.name,
    type: "slot",
    source: `(6:0) <Hst.Story   group=\\"viz\\"   title=\\"ChartLegend\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$k(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "viz",
      title: "ChartLegend",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 8) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$k.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const func_1$2 = (item) => item.color;
const func_2 = (item) => item.color;
function instance$k($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChartLegend_story", slots, []);
  let { Hst } = $$props;
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<ChartLegend_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ChartLegend_story> was created with unknown prop '${key}'`);
  });
  const func2 = (_, i) => [cCategoryBlue, cCategoryGreen, cCategoryPurple][i];
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({ Hst, ChartLegend, tokens });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [Hst, func2];
}
class ChartLegend_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$k, create_fragment$k, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChartLegend_story",
      options,
      id: create_fragment$k.name
    });
  }
  get Hst() {
    throw new Error("<ChartLegend_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<ChartLegend_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const CheckBoxes_svelte_svelte_type_style_lang = "";
const file$i = "src/lib/components/shared/CheckBoxes.svelte";
function get_each_context$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  const constants_0 = child_ctx[0].includes(child_ctx[14]);
  child_ctx[15] = constants_0;
  const constants_1 = child_ctx[5](child_ctx[14]);
  child_ctx[16] = constants_1;
  const constants_2 = child_ctx[14] === child_ctx[6];
  child_ctx[17] = constants_2;
  return child_ctx;
}
const get_default_slot_changes$6 = (dirty) => ({
  option: dirty & 4,
  selected: dirty & 5
});
const get_default_slot_context$6 = (ctx) => ({
  option: ctx[14],
  selected: ctx[15]
});
function create_if_block$f(ctx) {
  let legend;
  let t;
  const block = {
    c: function create() {
      legend = element("legend");
      t = text(ctx[3]);
      this.h();
    },
    l: function claim(nodes) {
      legend = claim_element(nodes, "LEGEND", { class: true });
      var legend_nodes = children(legend);
      t = claim_text(legend_nodes, ctx[3]);
      legend_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(legend, "class", "check-boxes__label s-k_RNNms-Pl3o");
      toggle_class(legend, "visually-hidden", ctx[4]);
      add_location(legend, file$i, 43, 4, 1182);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, legend, anchor);
      append_hydration_dev(legend, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
      if (dirty & 16) {
        toggle_class(legend, "visually-hidden", ctx2[4]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(legend);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$f.name,
    type: "if",
    source: "(43:2) {#if label}",
    ctx
  });
  return block;
}
function fallback_block$6(ctx) {
  let t_value = ctx[14] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[14] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$6.name,
    type: "fallback",
    source: "(77:40)          ",
    ctx
  });
  return block;
}
function create_each_block$7(ctx) {
  let label_1;
  let input;
  let input_value_value;
  let input_disabled_value;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  function focus_handler(...args) {
    return ctx[12](ctx[14], ...args);
  }
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], get_default_slot_context$6);
  const default_slot_or_fallback = default_slot || fallback_block$6(ctx);
  const block = {
    c: function create() {
      label_1 = element("label");
      input = element("input");
      t0 = space();
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true });
      var label_1_nodes = children(label_1);
      input = claim_element(label_1_nodes, "INPUT", { class: true, type: true, name: true });
      t0 = claim_space(label_1_nodes);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(label_1_nodes);
      t1 = claim_space(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "check-boxes__input s-k_RNNms-Pl3o");
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "name", ctx[1]);
      input.__value = input_value_value = ctx[14];
      input.value = input.__value;
      input.disabled = input_disabled_value = ctx[16];
      ctx[11][0].push(input);
      add_location(input, file$i, 61, 6, 1643);
      attr_dev(label_1, "class", "check-boxes__option s-k_RNNms-Pl3o");
      toggle_class(label_1, "focused", ctx[17]);
      toggle_class(label_1, "checked", ctx[15]);
      toggle_class(label_1, "selected", ctx[15]);
      toggle_class(label_1, "disabled", ctx[16]);
      add_location(label_1, file$i, 54, 4, 1498);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, input);
      input.checked = ~ctx[0].indexOf(input.__value);
      append_hydration_dev(label_1, t0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(label_1, null);
      }
      append_hydration_dev(label_1, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[10]),
          listen_dev(input, "focus", focus_handler, false, false, false),
          listen_dev(input, "blur", ctx[13], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & 2) {
        attr_dev(input, "name", ctx[1]);
      }
      if (!current || dirty & 4 && input_value_value !== (input_value_value = ctx[14])) {
        prop_dev(input, "__value", input_value_value);
        input.value = input.__value;
      }
      if (!current || dirty & 36 && input_disabled_value !== (input_disabled_value = ctx[16])) {
        prop_dev(input, "disabled", input_disabled_value);
      }
      if (dirty & 1) {
        input.checked = ~ctx[0].indexOf(input.__value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 261)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[8],
            !current ? get_all_dirty_from_scope(ctx[8]) : get_slot_changes(default_slot_template, ctx[8], dirty, get_default_slot_changes$6),
            get_default_slot_context$6
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
          default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 68) {
        toggle_class(label_1, "focused", ctx[17]);
      }
      if (!current || dirty & 5) {
        toggle_class(label_1, "checked", ctx[15]);
      }
      if (!current || dirty & 5) {
        toggle_class(label_1, "selected", ctx[15]);
      }
      if (!current || dirty & 36) {
        toggle_class(label_1, "disabled", ctx[16]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      ctx[11][0].splice(ctx[11][0].indexOf(input), 1);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$7.name,
    type: "each",
    source: "(51:2) {#each options as option}",
    ctx
  });
  return block;
}
function create_fragment$j(ctx) {
  let fieldset;
  let t;
  let fieldset_class_value;
  let fieldset_style_value;
  let current;
  let if_block = ctx[3] && create_if_block$f(ctx);
  let each_value = ctx[2];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      fieldset = element("fieldset");
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      fieldset = claim_element(nodes, "FIELDSET", { id: true, class: true, style: true });
      var fieldset_nodes = children(fieldset);
      if (if_block)
        if_block.l(fieldset_nodes);
      t = claim_space(fieldset_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(fieldset_nodes);
      }
      fieldset_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(fieldset, "id", ctx[1]);
      attr_dev(fieldset, "class", fieldset_class_value = null_to_empty(ctx[7].class) + " s-k_RNNms-Pl3o");
      attr_dev(fieldset, "style", fieldset_style_value = ctx[7].style);
      toggle_class(fieldset, "check-boxes", true);
      add_location(fieldset, file$i, 36, 0, 1062);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, fieldset, anchor);
      if (if_block)
        if_block.m(fieldset, null);
      append_hydration_dev(fieldset, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(fieldset, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$f(ctx2);
          if_block.c();
          if_block.m(fieldset, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 359) {
        each_value = ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$7(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(fieldset, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 2) {
        attr_dev(fieldset, "id", ctx2[1]);
      }
      if (!current || dirty & 128 && fieldset_class_value !== (fieldset_class_value = null_to_empty(ctx2[7].class) + " s-k_RNNms-Pl3o")) {
        attr_dev(fieldset, "class", fieldset_class_value);
      }
      if (!current || dirty & 128 && fieldset_style_value !== (fieldset_style_value = ctx2[7].style)) {
        attr_dev(fieldset, "style", fieldset_style_value);
      }
      if (!current || dirty & 128) {
        toggle_class(fieldset, "check-boxes", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(fieldset);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$j.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$j($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "id",
    "options",
    "label",
    "selectedOptions",
    "hideLabelVisually",
    "isOptionDisabled"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckBoxes", slots, ["default"]);
  let { id } = $$props;
  let { options } = $$props;
  let { label } = $$props;
  let { selectedOptions = [] } = $$props;
  let { hideLabelVisually = false } = $$props;
  let { isOptionDisabled = () => false } = $$props;
  let focusedOption = null;
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<CheckBoxes> was created without expected prop 'id'");
    }
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<CheckBoxes> was created without expected prop 'options'");
    }
    if (label === void 0 && !("label" in $$props || $$self.$$.bound[$$self.$$.props["label"]])) {
      console.warn("<CheckBoxes> was created without expected prop 'label'");
    }
  });
  const $$binding_groups = [[]];
  function input_change_handler() {
    selectedOptions = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
    $$invalidate(0, selectedOptions);
  }
  const focus_handler = (option, e) => {
    const node = e.currentTarget;
    if (node.classList.contains("focus-visible")) {
      $$invalidate(6, focusedOption = option);
    }
  };
  const blur_handler = () => $$invalidate(6, focusedOption = null);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(1, id = $$new_props.id);
    if ("options" in $$new_props)
      $$invalidate(2, options = $$new_props.options);
    if ("label" in $$new_props)
      $$invalidate(3, label = $$new_props.label);
    if ("selectedOptions" in $$new_props)
      $$invalidate(0, selectedOptions = $$new_props.selectedOptions);
    if ("hideLabelVisually" in $$new_props)
      $$invalidate(4, hideLabelVisually = $$new_props.hideLabelVisually);
    if ("isOptionDisabled" in $$new_props)
      $$invalidate(5, isOptionDisabled = $$new_props.isOptionDisabled);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    id,
    options,
    label,
    selectedOptions,
    hideLabelVisually,
    isOptionDisabled,
    focusedOption
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(1, id = $$new_props.id);
    if ("options" in $$props)
      $$invalidate(2, options = $$new_props.options);
    if ("label" in $$props)
      $$invalidate(3, label = $$new_props.label);
    if ("selectedOptions" in $$props)
      $$invalidate(0, selectedOptions = $$new_props.selectedOptions);
    if ("hideLabelVisually" in $$props)
      $$invalidate(4, hideLabelVisually = $$new_props.hideLabelVisually);
    if ("isOptionDisabled" in $$props)
      $$invalidate(5, isOptionDisabled = $$new_props.isOptionDisabled);
    if ("focusedOption" in $$props)
      $$invalidate(6, focusedOption = $$new_props.focusedOption);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    selectedOptions,
    id,
    options,
    label,
    hideLabelVisually,
    isOptionDisabled,
    focusedOption,
    $$restProps,
    $$scope,
    slots,
    input_change_handler,
    $$binding_groups,
    focus_handler,
    blur_handler
  ];
}
class CheckBoxes extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$j, create_fragment$j, safe_not_equal, {
      id: 1,
      options: 2,
      label: 3,
      selectedOptions: 0,
      hideLabelVisually: 4,
      isOptionDisabled: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckBoxes",
      options,
      id: create_fragment$j.name
    });
  }
  get id() {
    throw new Error("<CheckBoxes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<CheckBoxes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<CheckBoxes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<CheckBoxes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<CheckBoxes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<CheckBoxes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedOptions() {
    throw new Error("<CheckBoxes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedOptions(value) {
    throw new Error("<CheckBoxes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabelVisually() {
    throw new Error("<CheckBoxes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabelVisually(value) {
    throw new Error("<CheckBoxes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOptionDisabled() {
    throw new Error("<CheckBoxes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOptionDisabled(value) {
    throw new Error("<CheckBoxes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const CheckBoxes_story_svelte_svelte_type_style_lang = "";
const file$h = "src/lib/components/shared/CheckBoxes.story.svelte";
function create_if_block_8(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$h, 22, 8, 618);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(22:6) {#if selectedOptions.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_10$2(ctx) {
  let checkboxes;
  let updating_selectedOptions;
  let t0;
  let div;
  let t1;
  let current;
  function checkboxes_selectedOptions_binding(value) {
    ctx[4](value);
  }
  let checkboxes_props = {
    id: "my-unique-checkboxes-id",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine oder mehrere Regionen:"
  };
  if (ctx[1] !== void 0) {
    checkboxes_props.selectedOptions = ctx[1];
  }
  checkboxes = new CheckBoxes({ props: checkboxes_props, $$inline: true });
  binding_callbacks.push(() => bind(checkboxes, "selectedOptions", checkboxes_selectedOptions_binding, ctx[1]));
  let if_block = ctx[1].length > 0 && create_if_block_8(ctx);
  const block = {
    c: function create() {
      create_component(checkboxes.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(checkboxes.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-vSiuPK4jSs6Y");
      add_location(div, file$h, 19, 4, 527);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxes, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxes_changes = {};
      if (!updating_selectedOptions && dirty & 2) {
        updating_selectedOptions = true;
        checkboxes_changes.selectedOptions = ctx2[1];
        add_flush_callback(() => updating_selectedOptions = false);
      }
      checkboxes.$set(checkboxes_changes);
      if (ctx2[1].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_8(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxes, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10$2.name,
    type: "slot",
    source: '(13:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_if_block_7$1(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[3]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[3]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$h, 37, 8, 1071);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7$1.name,
    type: "if",
    source: "(37:6) {#if selectedOptionsInitiallySet.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_9$3(ctx) {
  let checkboxes;
  let updating_selectedOptions;
  let t0;
  let div;
  let t1;
  let current;
  function checkboxes_selectedOptions_binding_1(value) {
    ctx[5](value);
  }
  let checkboxes_props = {
    id: "my-unique-checkboxes-id",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine oder mehrere Regionen:"
  };
  if (ctx[3] !== void 0) {
    checkboxes_props.selectedOptions = ctx[3];
  }
  checkboxes = new CheckBoxes({ props: checkboxes_props, $$inline: true });
  binding_callbacks.push(() => bind(checkboxes, "selectedOptions", checkboxes_selectedOptions_binding_1, ctx[3]));
  let if_block = ctx[3].length > 0 && create_if_block_7$1(ctx);
  const block = {
    c: function create() {
      create_component(checkboxes.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(checkboxes.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-vSiuPK4jSs6Y");
      add_location(div, file$h, 34, 4, 968);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxes, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxes_changes = {};
      if (!updating_selectedOptions && dirty & 8) {
        updating_selectedOptions = true;
        checkboxes_changes.selectedOptions = ctx2[3];
        add_flush_callback(() => updating_selectedOptions = false);
      }
      checkboxes.$set(checkboxes_changes);
      if (ctx2[3].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_7$1(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxes, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9$3.name,
    type: "slot",
    source: '(28:2) <Hst.Variant title=\\"Specify initially selected values\\">',
    ctx
  });
  return block;
}
function create_if_block_6$2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(selected)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(selected)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6$2.name,
    type: "if",
    source: "(53:6) {#if selected}",
    ctx
  });
  return block;
}
function create_default_slot_8$5(ctx) {
  let t0;
  let t1_value = ctx[12] + "";
  let t1;
  let t2;
  let if_block_anchor;
  let if_block = ctx[13] && create_if_block_6$2(ctx);
  const block = {
    c: function create() {
      t0 = text("Hallo, ");
      t1 = text(t1_value);
      t2 = text("!\n      ");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, "Hallo, ");
      t1 = claim_text(nodes, t1_value);
      t2 = claim_text(nodes, "!\n      ");
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4096 && t1_value !== (t1_value = ctx2[12] + ""))
        set_data_dev(t1, t1_value);
      if (ctx2[13]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_6$2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8$5.name,
    type: "slot",
    source: `(44:4) <CheckBoxes       id=\\"my-unique-checkboxes-id\\"       options={['Berlin', 'Brandenburg', 'Stadt', 'Land']}       label=\\"Wähle eine oder mehrere Regionen:\\"       bind:selectedOptions       let:option       let:selected     >`,
    ctx
  });
  return block;
}
function create_if_block_5$3(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$h, 59, 8, 1608);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5$3.name,
    type: "if",
    source: "(59:6) {#if selectedOptions.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_7$5(ctx) {
  let checkboxes;
  let updating_selectedOptions;
  let t0;
  let div;
  let t1;
  let current;
  function checkboxes_selectedOptions_binding_2(value) {
    ctx[6](value);
  }
  let checkboxes_props = {
    id: "my-unique-checkboxes-id",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine oder mehrere Regionen:",
    $$slots: {
      default: [
        create_default_slot_8$5,
        ({ option, selected }) => ({ 12: option, 13: selected }),
        ({ option, selected }) => (option ? 4096 : 0) | (selected ? 8192 : 0)
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    checkboxes_props.selectedOptions = ctx[1];
  }
  checkboxes = new CheckBoxes({ props: checkboxes_props, $$inline: true });
  binding_callbacks.push(() => bind(checkboxes, "selectedOptions", checkboxes_selectedOptions_binding_2, ctx[1]));
  let if_block = ctx[1].length > 0 && create_if_block_5$3(ctx);
  const block = {
    c: function create() {
      create_component(checkboxes.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(checkboxes.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-vSiuPK4jSs6Y");
      add_location(div, file$h, 56, 4, 1517);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxes, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxes_changes = {};
      if (dirty & 28672) {
        checkboxes_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedOptions && dirty & 2) {
        updating_selectedOptions = true;
        checkboxes_changes.selectedOptions = ctx2[1];
        add_flush_callback(() => updating_selectedOptions = false);
      }
      checkboxes.$set(checkboxes_changes);
      if (ctx2[1].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5$3(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxes, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7$5.name,
    type: "slot",
    source: '(43:2) <Hst.Variant title=\\"Custom option label\\">',
    ctx
  });
  return block;
}
function create_if_block_4$5(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$h, 75, 8, 2057);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4$5.name,
    type: "if",
    source: "(75:6) {#if selectedOptions.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_6$6(ctx) {
  let checkboxes;
  let updating_selectedOptions;
  let t0;
  let div;
  let t1;
  let current;
  function checkboxes_selectedOptions_binding_3(value) {
    ctx[7](value);
  }
  let checkboxes_props = {
    id: "my-unique-checkboxes-id",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine oder mehrere Regionen:",
    isOptionDisabled: func$5
  };
  if (ctx[1] !== void 0) {
    checkboxes_props.selectedOptions = ctx[1];
  }
  checkboxes = new CheckBoxes({ props: checkboxes_props, $$inline: true });
  binding_callbacks.push(() => bind(checkboxes, "selectedOptions", checkboxes_selectedOptions_binding_3, ctx[1]));
  let if_block = ctx[1].length > 0 && create_if_block_4$5(ctx);
  const block = {
    c: function create() {
      create_component(checkboxes.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected value:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(checkboxes.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected value:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-vSiuPK4jSs6Y");
      add_location(div, file$h, 72, 4, 1967);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxes, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxes_changes = {};
      if (!updating_selectedOptions && dirty & 2) {
        updating_selectedOptions = true;
        checkboxes_changes.selectedOptions = ctx2[1];
        add_flush_callback(() => updating_selectedOptions = false);
      }
      checkboxes.$set(checkboxes_changes);
      if (ctx2[1].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$5(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxes, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$6.name,
    type: "slot",
    source: '(65:2) <Hst.Variant title=\\"Disabled option\\">',
    ctx
  });
  return block;
}
function create_default_slot_5$7(ctx) {
  let t_value = ctx[12].label + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4096 && t_value !== (t_value = ctx2[12].label + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$7.name,
    type: "slot",
    source: `(82:4) <CheckBoxes       id=\\"my-unique-checkboxes-id\\"       options={[         { label: 'Berlin', value: 'berlin' },         { label: 'Brandenburg', value: 'brandenburg' },         { label: 'Stadt', value: 'city' },         { label: 'Land', value: 'country' },       ]}       label=\\"Wähle eine oder mehrere Regionen:\\"       bind:selectedOptions={selectedComplexOptions}       let:option     >`,
    ctx
  });
  return block;
}
function create_if_block_3$5(ctx) {
  let i;
  let t_value = JSON.stringify(ctx[2]) + "";
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, t_value);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$h, 98, 8, 2694);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = JSON.stringify(ctx2[2]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3$5.name,
    type: "if",
    source: "(98:6) {#if selectedComplexOptions.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_4$7(ctx) {
  let checkboxes;
  let updating_selectedOptions;
  let t0;
  let div;
  let t1;
  let current;
  function checkboxes_selectedOptions_binding_4(value) {
    ctx[8](value);
  }
  let checkboxes_props = {
    id: "my-unique-checkboxes-id",
    options: [
      { label: "Berlin", value: "berlin" },
      {
        label: "Brandenburg",
        value: "brandenburg"
      },
      { label: "Stadt", value: "city" },
      { label: "Land", value: "country" }
    ],
    label: "Wähle eine oder mehrere Regionen:",
    $$slots: {
      default: [
        create_default_slot_5$7,
        ({ option }) => ({ 12: option }),
        ({ option }) => option ? 4096 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[2] !== void 0) {
    checkboxes_props.selectedOptions = ctx[2];
  }
  checkboxes = new CheckBoxes({ props: checkboxes_props, $$inline: true });
  binding_callbacks.push(() => bind(checkboxes, "selectedOptions", checkboxes_selectedOptions_binding_4, ctx[2]));
  let if_block = ctx[2].length > 0 && create_if_block_3$5(ctx);
  const block = {
    c: function create() {
      create_component(checkboxes.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(checkboxes.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-vSiuPK4jSs6Y");
      add_location(div, file$h, 95, 4, 2596);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxes, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxes_changes = {};
      if (dirty & 20480) {
        checkboxes_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedOptions && dirty & 4) {
        updating_selectedOptions = true;
        checkboxes_changes.selectedOptions = ctx2[2];
        add_flush_callback(() => updating_selectedOptions = false);
      }
      checkboxes.$set(checkboxes_changes);
      if (ctx2[2].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$5(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxes, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$7.name,
    type: "slot",
    source: '(81:2) <Hst.Variant title=\\"Complex options\\">',
    ctx
  });
  return block;
}
function create_if_block_2$6(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$h, 114, 8, 3158);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$6.name,
    type: "if",
    source: "(114:6) {#if selectedOptions.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_3$8(ctx) {
  let checkboxes;
  let updating_selectedOptions;
  let t0;
  let div;
  let t1;
  let current;
  function checkboxes_selectedOptions_binding_5(value) {
    ctx[9](value);
  }
  let checkboxes_props = {
    id: "my-unique-checkboxes-id",
    class: "checkboxes-with-custom-colors",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine oder mehrere Regionen:"
  };
  if (ctx[1] !== void 0) {
    checkboxes_props.selectedOptions = ctx[1];
  }
  checkboxes = new CheckBoxes({ props: checkboxes_props, $$inline: true });
  binding_callbacks.push(() => bind(checkboxes, "selectedOptions", checkboxes_selectedOptions_binding_5, ctx[1]));
  let if_block = ctx[1].length > 0 && create_if_block_2$6(ctx);
  const block = {
    c: function create() {
      create_component(checkboxes.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(checkboxes.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-vSiuPK4jSs6Y");
      add_location(div, file$h, 111, 4, 3067);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxes, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxes_changes = {};
      if (!updating_selectedOptions && dirty & 2) {
        updating_selectedOptions = true;
        checkboxes_changes.selectedOptions = ctx2[1];
        add_flush_callback(() => updating_selectedOptions = false);
      }
      checkboxes.$set(checkboxes_changes);
      if (ctx2[1].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$6(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxes, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$8.name,
    type: "slot",
    source: '(104:2) <Hst.Variant title=\\"Custom accent color\\">',
    ctx
  });
  return block;
}
function create_if_block_1$6(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$h, 130, 8, 3579);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$6.name,
    type: "if",
    source: "(130:6) {#if selectedOptions.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_2$8(ctx) {
  let checkboxes;
  let updating_selectedOptions;
  let t0;
  let div;
  let t1;
  let current;
  function checkboxes_selectedOptions_binding_6(value) {
    ctx[10](value);
  }
  let checkboxes_props = {
    id: "my-unique-checkboxes-id",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine oder mehrere Regionen:",
    hideLabelVisually: true
  };
  if (ctx[1] !== void 0) {
    checkboxes_props.selectedOptions = ctx[1];
  }
  checkboxes = new CheckBoxes({ props: checkboxes_props, $$inline: true });
  binding_callbacks.push(() => bind(checkboxes, "selectedOptions", checkboxes_selectedOptions_binding_6, ctx[1]));
  let if_block = ctx[1].length > 0 && create_if_block_1$6(ctx);
  const block = {
    c: function create() {
      create_component(checkboxes.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(checkboxes.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-vSiuPK4jSs6Y");
      add_location(div, file$h, 127, 4, 3488);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxes, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxes_changes = {};
      if (!updating_selectedOptions && dirty & 2) {
        updating_selectedOptions = true;
        checkboxes_changes.selectedOptions = ctx2[1];
        add_flush_callback(() => updating_selectedOptions = false);
      }
      checkboxes.$set(checkboxes_changes);
      if (ctx2[1].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$6(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxes, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$8.name,
    type: "slot",
    source: '(120:2) <Hst.Variant title=\\"Hide label visually\\">',
    ctx
  });
  return block;
}
function create_if_block$e(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$h, 146, 8, 3982);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$e.name,
    type: "if",
    source: "(146:6) {#if selectedOptions.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_1$8(ctx) {
  let checkboxes;
  let updating_selectedOptions;
  let t0;
  let div;
  let t1;
  let current;
  function checkboxes_selectedOptions_binding_7(value) {
    ctx[11](value);
  }
  let checkboxes_props = {
    id: "my-unique-checkboxes-id",
    class: "chips",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine oder mehrere Regionen:"
  };
  if (ctx[1] !== void 0) {
    checkboxes_props.selectedOptions = ctx[1];
  }
  checkboxes = new CheckBoxes({ props: checkboxes_props, $$inline: true });
  binding_callbacks.push(() => bind(checkboxes, "selectedOptions", checkboxes_selectedOptions_binding_7, ctx[1]));
  let if_block = ctx[1].length > 0 && create_if_block$e(ctx);
  const block = {
    c: function create() {
      create_component(checkboxes.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(checkboxes.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-vSiuPK4jSs6Y");
      add_location(div, file$h, 143, 4, 3891);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxes, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const checkboxes_changes = {};
      if (!updating_selectedOptions && dirty & 2) {
        updating_selectedOptions = true;
        checkboxes_changes.selectedOptions = ctx2[1];
        add_flush_callback(() => updating_selectedOptions = false);
      }
      checkboxes.$set(checkboxes_changes);
      if (ctx2[1].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$e(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxes, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$8.name,
    type: "slot",
    source: '(136:2) <Hst.Variant title=\\"Chips\\">',
    ctx
  });
  return block;
}
function create_default_slot$8(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let t2;
  let hst_variant3;
  let t3;
  let hst_variant4;
  let t4;
  let hst_variant5;
  let t5;
  let hst_variant6;
  let t6;
  let hst_variant7;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_10$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Specify initially selected values",
      $$slots: { default: [create_default_slot_9$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Custom option label",
      $$slots: { default: [create_default_slot_7$5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant3 = new ctx[0].Variant({
    props: {
      title: "Disabled option",
      $$slots: { default: [create_default_slot_6$6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant4 = new ctx[0].Variant({
    props: {
      title: "Complex options",
      $$slots: { default: [create_default_slot_4$7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant5 = new ctx[0].Variant({
    props: {
      title: "Custom accent color",
      $$slots: { default: [create_default_slot_3$8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant6 = new ctx[0].Variant({
    props: {
      title: "Hide label visually",
      $$slots: { default: [create_default_slot_2$8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant7 = new ctx[0].Variant({
    props: {
      title: "Chips",
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
      t2 = space();
      create_component(hst_variant3.$$.fragment);
      t3 = space();
      create_component(hst_variant4.$$.fragment);
      t4 = space();
      create_component(hst_variant5.$$.fragment);
      t5 = space();
      create_component(hst_variant6.$$.fragment);
      t6 = space();
      create_component(hst_variant7.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_variant3.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(hst_variant4.$$.fragment, nodes);
      t4 = claim_space(nodes);
      claim_component(hst_variant5.$$.fragment, nodes);
      t5 = claim_space(nodes);
      claim_component(hst_variant6.$$.fragment, nodes);
      t6 = claim_space(nodes);
      claim_component(hst_variant7.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_variant3, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(hst_variant4, target, anchor);
      insert_hydration_dev(target, t4, anchor);
      mount_component(hst_variant5, target, anchor);
      insert_hydration_dev(target, t5, anchor);
      mount_component(hst_variant6, target, anchor);
      insert_hydration_dev(target, t6, anchor);
      mount_component(hst_variant7, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 16386) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 16392) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 16386) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
      const hst_variant3_changes = {};
      if (dirty & 16386) {
        hst_variant3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant3.$set(hst_variant3_changes);
      const hst_variant4_changes = {};
      if (dirty & 16388) {
        hst_variant4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant4.$set(hst_variant4_changes);
      const hst_variant5_changes = {};
      if (dirty & 16386) {
        hst_variant5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant5.$set(hst_variant5_changes);
      const hst_variant6_changes = {};
      if (dirty & 16386) {
        hst_variant6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant6.$set(hst_variant6_changes);
      const hst_variant7_changes = {};
      if (dirty & 16386) {
        hst_variant7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant7.$set(hst_variant7_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      transition_in(hst_variant3.$$.fragment, local);
      transition_in(hst_variant4.$$.fragment, local);
      transition_in(hst_variant5.$$.fragment, local);
      transition_in(hst_variant6.$$.fragment, local);
      transition_in(hst_variant7.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      transition_out(hst_variant3.$$.fragment, local);
      transition_out(hst_variant4.$$.fragment, local);
      transition_out(hst_variant5.$$.fragment, local);
      transition_out(hst_variant6.$$.fragment, local);
      transition_out(hst_variant7.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_variant3, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(hst_variant4, detaching);
      if (detaching)
        detach_dev(t4);
      destroy_component(hst_variant5, detaching);
      if (detaching)
        detach_dev(t5);
      destroy_component(hst_variant6, detaching);
      if (detaching)
        detach_dev(t6);
      destroy_component(hst_variant7, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$8.name,
    type: "slot",
    source: `(8:0) <Hst.Story   group=\\"ui\\"   title=\\"CheckBoxes\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$i(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "ui",
      title: "CheckBoxes",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 16398) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$i.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const func$5 = (option) => option === "Berlin";
function instance$i($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckBoxes_story", slots, []);
  let { Hst } = $$props;
  let selectedOptions = [];
  let selectedComplexOptions = [];
  let selectedOptionsInitiallySet = ["Berlin", "Brandenburg"];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<CheckBoxes_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CheckBoxes_story> was created with unknown prop '${key}'`);
  });
  function checkboxes_selectedOptions_binding(value) {
    selectedOptions = value;
    $$invalidate(1, selectedOptions);
  }
  function checkboxes_selectedOptions_binding_1(value) {
    selectedOptionsInitiallySet = value;
    $$invalidate(3, selectedOptionsInitiallySet);
  }
  function checkboxes_selectedOptions_binding_2(value) {
    selectedOptions = value;
    $$invalidate(1, selectedOptions);
  }
  function checkboxes_selectedOptions_binding_3(value) {
    selectedOptions = value;
    $$invalidate(1, selectedOptions);
  }
  function checkboxes_selectedOptions_binding_4(value) {
    selectedComplexOptions = value;
    $$invalidate(2, selectedComplexOptions);
  }
  function checkboxes_selectedOptions_binding_5(value) {
    selectedOptions = value;
    $$invalidate(1, selectedOptions);
  }
  function checkboxes_selectedOptions_binding_6(value) {
    selectedOptions = value;
    $$invalidate(1, selectedOptions);
  }
  function checkboxes_selectedOptions_binding_7(value) {
    selectedOptions = value;
    $$invalidate(1, selectedOptions);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    CheckBoxes,
    selectedOptions,
    selectedComplexOptions,
    selectedOptionsInitiallySet
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("selectedOptions" in $$props2)
      $$invalidate(1, selectedOptions = $$props2.selectedOptions);
    if ("selectedComplexOptions" in $$props2)
      $$invalidate(2, selectedComplexOptions = $$props2.selectedComplexOptions);
    if ("selectedOptionsInitiallySet" in $$props2)
      $$invalidate(3, selectedOptionsInitiallySet = $$props2.selectedOptionsInitiallySet);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    selectedOptions,
    selectedComplexOptions,
    selectedOptionsInitiallySet,
    checkboxes_selectedOptions_binding,
    checkboxes_selectedOptions_binding_1,
    checkboxes_selectedOptions_binding_2,
    checkboxes_selectedOptions_binding_3,
    checkboxes_selectedOptions_binding_4,
    checkboxes_selectedOptions_binding_5,
    checkboxes_selectedOptions_binding_6,
    checkboxes_selectedOptions_binding_7
  ];
}
class CheckBoxes_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$i, create_fragment$i, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckBoxes_story",
      options,
      id: create_fragment$i.name
    });
  }
  get Hst() {
    throw new Error("<CheckBoxes_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<CheckBoxes_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const file$g = "src/lib/components/icons/DropdownIcon.svelte";
function create_if_block$d(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", { id: true });
      var title_1_nodes = children(title_1);
      t = claim_text(title_1_nodes, ctx[0]);
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(title_1, "id", ctx[1]);
      add_location(title_1, file$g, 19, 4, 333);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
      if (dirty & 2) {
        attr_dev(title_1, "id", ctx2[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$d.name,
    type: "if",
    source: "(19:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment$h(ctx) {
  let svg;
  let path;
  let svg_aria_labelledby_value;
  let svg_aria_hidden_value;
  let if_block = ctx[0] && create_if_block$d(ctx);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        role: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        "aria-labelledby": true,
        "aria-hidden": true
      });
      var svg_nodes = children(svg);
      if (if_block)
        if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        "clip-rule": true,
        d: true,
        fill: true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      attr_dev(path, "d", "M5.29 11.707 16 22.414l10.71-10.707-1.42-1.414L16 19.586l-9.29-9.293-1.42 1.414Z");
      attr_dev(path, "fill", ctx[2]);
      add_location(path, file$g, 21, 2, 371);
      attr_dev(svg, "role", "img");
      attr_dev(svg, "width", "32");
      attr_dev(svg, "height", "32");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 32 32");
      attr_dev(svg, "aria-labelledby", svg_aria_labelledby_value = ctx[0] && ctx[1]);
      attr_dev(svg, "aria-hidden", svg_aria_hidden_value = ctx[0] === void 0);
      add_location(svg, file$g, 9, 0, 164);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$d(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 4) {
        attr_dev(path, "fill", ctx2[2]);
      }
      if (dirty & 3 && svg_aria_labelledby_value !== (svg_aria_labelledby_value = ctx2[0] && ctx2[1])) {
        attr_dev(svg, "aria-labelledby", svg_aria_labelledby_value);
      }
      if (dirty & 1 && svg_aria_hidden_value !== (svg_aria_hidden_value = ctx2[0] === void 0)) {
        attr_dev(svg, "aria-hidden", svg_aria_hidden_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$h.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$h($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownIcon", slots, []);
  let { title = void 0 } = $$props;
  let { id = "dropdown-icon--title" } = $$props;
  let { color = "#000000" } = $$props;
  const writable_props = ["title", "id", "color"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DropdownIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
  };
  $$self.$capture_state = () => ({ title, id, color });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, id, color];
}
class DropdownIcon extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$h, create_fragment$h, safe_not_equal, { title: 0, id: 1, color: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownIcon",
      options,
      id: create_fragment$h.name
    });
  }
  get title() {
    throw new Error("<DropdownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<DropdownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<DropdownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<DropdownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<DropdownIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<DropdownIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const file$f = "src/lib/components/icons/CheckIcon.svelte";
function create_if_block$c(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", { id: true });
      var title_1_nodes = children(title_1);
      t = claim_text(title_1_nodes, ctx[0]);
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(title_1, "id", ctx[1]);
      add_location(title_1, file$f, 19, 4, 330);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
      if (dirty & 2) {
        attr_dev(title_1, "id", ctx2[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$c.name,
    type: "if",
    source: "(19:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment$g(ctx) {
  let svg;
  let path;
  let svg_aria_labelledby_value;
  let svg_aria_hidden_value;
  let if_block = ctx[0] && create_if_block$c(ctx);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        role: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        "aria-labelledby": true,
        "aria-hidden": true
      });
      var svg_nodes = children(svg);
      if (if_block)
        if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        "clip-rule": true,
        d: true,
        fill: true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      attr_dev(path, "d", "M14.49 27.015h1.17l9.26-21.621-1.84-.788-8.32 19.435-4.94-6.605-1.6 1.198 6.27 8.381Z");
      attr_dev(path, "fill", ctx[2]);
      add_location(path, file$f, 21, 2, 368);
      attr_dev(svg, "role", "img");
      attr_dev(svg, "width", "32");
      attr_dev(svg, "height", "32");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 32 32");
      attr_dev(svg, "aria-labelledby", svg_aria_labelledby_value = ctx[0] && ctx[1]);
      attr_dev(svg, "aria-hidden", svg_aria_hidden_value = ctx[0] === void 0);
      add_location(svg, file$f, 9, 0, 161);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$c(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 4) {
        attr_dev(path, "fill", ctx2[2]);
      }
      if (dirty & 3 && svg_aria_labelledby_value !== (svg_aria_labelledby_value = ctx2[0] && ctx2[1])) {
        attr_dev(svg, "aria-labelledby", svg_aria_labelledby_value);
      }
      if (dirty & 1 && svg_aria_hidden_value !== (svg_aria_hidden_value = ctx2[0] === void 0)) {
        attr_dev(svg, "aria-hidden", svg_aria_hidden_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$g.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$g($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckIcon", slots, []);
  let { title = void 0 } = $$props;
  let { id = "check-icon--title" } = $$props;
  let { color = "#000000" } = $$props;
  const writable_props = ["title", "id", "color"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CheckIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
  };
  $$self.$capture_state = () => ({ title, id, color });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, id, color];
}
class CheckIcon extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$g, create_fragment$g, safe_not_equal, { title: 0, id: 1, color: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckIcon",
      options,
      id: create_fragment$g.name
    });
  }
  get title() {
    throw new Error("<CheckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CheckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<CheckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<CheckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<CheckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<CheckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const file$e = "src/lib/components/icons/ErrorCloseIcon.svelte";
function create_if_block$b(ctx) {
  let title_1;
  let t;
  const block = {
    c: function create() {
      title_1 = svg_element("title");
      t = text(ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      title_1 = claim_svg_element(nodes, "title", { id: true });
      var title_1_nodes = children(title_1);
      t = claim_text(title_1_nodes, ctx[0]);
      title_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(title_1, "id", ctx[1]);
      add_location(title_1, file$e, 19, 4, 336);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, title_1, anchor);
      append_hydration_dev(title_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
      if (dirty & 2) {
        attr_dev(title_1, "id", ctx2[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(title_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$b.name,
    type: "if",
    source: "(19:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment$f(ctx) {
  let svg;
  let path;
  let svg_aria_labelledby_value;
  let svg_aria_hidden_value;
  let if_block = ctx[0] && create_if_block$b(ctx);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (if_block)
        if_block.c();
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        role: true,
        width: true,
        height: true,
        fill: true,
        viewBox: true,
        "aria-labelledby": true,
        "aria-hidden": true
      });
      var svg_nodes = children(svg);
      if (if_block)
        if_block.l(svg_nodes);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        "clip-rule": true,
        d: true,
        fill: true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      attr_dev(path, "d", "M16 14.596 6.71 5.308 5.29 6.722l9.29 9.289-9.28 9.282 1.41 1.414L16 17.425l9.29 9.297 1.42-1.414-9.3-9.297 9.2-9.198-1.42-1.415L16 14.596Z");
      attr_dev(path, "fill", ctx[2]);
      add_location(path, file$e, 21, 2, 374);
      attr_dev(svg, "role", "img");
      attr_dev(svg, "width", "32");
      attr_dev(svg, "height", "32");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 32 32");
      attr_dev(svg, "aria-labelledby", svg_aria_labelledby_value = ctx[0] && ctx[1]);
      attr_dev(svg, "aria-hidden", svg_aria_hidden_value = ctx[0] === void 0);
      add_location(svg, file$e, 9, 0, 167);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (if_block)
        if_block.m(svg, null);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$b(ctx2);
          if_block.c();
          if_block.m(svg, path);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 4) {
        attr_dev(path, "fill", ctx2[2]);
      }
      if (dirty & 3 && svg_aria_labelledby_value !== (svg_aria_labelledby_value = ctx2[0] && ctx2[1])) {
        attr_dev(svg, "aria-labelledby", svg_aria_labelledby_value);
      }
      if (dirty & 1 && svg_aria_hidden_value !== (svg_aria_hidden_value = ctx2[0] === void 0)) {
        attr_dev(svg, "aria-hidden", svg_aria_hidden_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$f.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$f($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ErrorCloseIcon", slots, []);
  let { title = void 0 } = $$props;
  let { id = "error-close-icon--title" } = $$props;
  let { color = "#000000" } = $$props;
  const writable_props = ["title", "id", "color"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ErrorCloseIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
  };
  $$self.$capture_state = () => ({ title, id, color });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, id, color];
}
class ErrorCloseIcon extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$f, create_fragment$f, safe_not_equal, { title: 0, id: 1, color: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ErrorCloseIcon",
      options,
      id: create_fragment$f.name
    });
  }
  get title() {
    throw new Error("<ErrorCloseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ErrorCloseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ErrorCloseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ErrorCloseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ErrorCloseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ErrorCloseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
function typeahead(node, {
  handleInput,
  clearAfterMs = 600
}) {
  let input = "";
  let timestamp;
  function handleKeyDown(e) {
    const ignoredKeys = [
      "Enter",
      " ",
      "Spacebar",
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight"
    ];
    if (ignoredKeys.includes(e.key))
      return;
    const now = Date.now();
    if (timestamp && now - timestamp > clearAfterMs)
      input = "";
    input += e.key;
    timestamp = now;
    handleInput(input);
  }
  node.addEventListener("keydown", handleKeyDown);
  return {
    destroy: () => {
      node.removeEventListener("keydown", handleKeyDown);
    }
  };
}
function getIndexBefore(index, length, { circular = false } = {}) {
  const fallback = circular ? length - 1 : index;
  return index - 1 >= 0 ? index - 1 : fallback;
}
function getIndexAfter(index, length, { circular = false } = {}) {
  const fallback = circular ? 0 : index;
  return index + 1 < length ? index + 1 : fallback;
}
const Dropdown_svelte_svelte_type_style_lang = "";
const file$d = "src/lib/components/shared/Dropdown.svelte";
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  child_ctx[31] = list;
  child_ctx[32] = i;
  const constants_0 = child_ctx[0] === child_ctx[29];
  child_ctx[30] = constants_0;
  return child_ctx;
}
const get_default_slot_changes$5 = (dirty) => ({
  option: dirty[0] & 16,
  selected: dirty[0] & 17
});
const get_default_slot_context$5 = (ctx) => ({
  option: ctx[29],
  selected: ctx[30]
});
function create_else_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[5]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[5]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 32)
        set_data_dev(t, ctx2[5]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(147:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4$4(ctx) {
  let t_value = ctx[8](ctx[0]) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 257 && t_value !== (t_value = ctx2[8](ctx2[0]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4$4.name,
    type: "if",
    source: "(145:6) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_if_block_3$4(ctx) {
  let dropdownicon;
  let current;
  dropdownicon = new DropdownIcon({ $$inline: true });
  const block = {
    c: function create() {
      create_component(dropdownicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(dropdownicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(dropdownicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdownicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdownicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dropdownicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3$4.name,
    type: "if",
    source: "(152:6) {#if hideClearButton || (!hideClearButton && !selectedOption)}",
    ctx
  });
  return block;
}
function create_if_block_2$5(ctx) {
  let button;
  let errorcloseicon;
  let current;
  let mounted;
  let dispose;
  errorcloseicon = new ErrorCloseIcon({ $$inline: true });
  const block = {
    c: function create() {
      button = element("button");
      create_component(errorcloseicon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        "aria-label": true
      });
      var button_nodes = children(button);
      claim_component(errorcloseicon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "dropdown__button-clear | reset s-IZ64dNwyu-gU");
      attr_dev(button, "aria-label", "Zurücksetzen");
      add_location(button, file$d, 158, 6, 4535);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(errorcloseicon, button, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[24], false, false, false);
        mounted = true;
      }
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(errorcloseicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(errorcloseicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      destroy_component(errorcloseicon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$5.name,
    type: "if",
    source: "(158:4) {#if !hideClearButton && selectedOption}",
    ctx
  });
  return block;
}
function create_if_block$a(ctx) {
  let ul;
  let ul_id_value;
  let typeahead_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[4];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {
        id: true,
        class: true,
        role: true,
        "aria-orientation": true
      });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "id", ul_id_value = ctx[2] + "__listbox");
      attr_dev(ul, "class", "dropdown__options | shadow-sm s-IZ64dNwyu-gU");
      attr_dev(ul, "role", "listbox");
      attr_dev(ul, "aria-orientation", "vertical");
      add_location(ul, file$d, 170, 4, 4769);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(typeahead_action = typeahead.call(null, ul, {
          handleInput: ctx[28]
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 551953) {
        each_value = ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & 4 && ul_id_value !== (ul_id_value = ctx2[2] + "__listbox")) {
        attr_dev(ul, "id", ul_id_value);
      }
      if (typeahead_action && is_function(typeahead_action.update) && dirty[0] & 1296)
        typeahead_action.update.call(null, {
          handleInput: ctx2[28]
        });
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$a.name,
    type: "if",
    source: "(170:2) {#if isOpen}",
    ctx
  });
  return block;
}
function fallback_block$5(ctx) {
  let t_value = ctx[29] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 16 && t_value !== (t_value = ctx2[29] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$5.name,
    type: "fallback",
    source: "(223:36)              ",
    ctx
  });
  return block;
}
function create_if_block_1$5(ctx) {
  let checkicon;
  let current;
  checkicon = new CheckIcon({ $$inline: true });
  const block = {
    c: function create() {
      create_component(checkicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$5.name,
    type: "if",
    source: "(226:10) {#if selected}",
    ctx
  });
  return block;
}
function create_each_block$6(ctx) {
  let li;
  let t0;
  let t1;
  let li_aria_selected_value;
  let li_tabindex_value;
  let i = ctx[32];
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[20].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[19], get_default_slot_context$5);
  const default_slot_or_fallback = default_slot || fallback_block$5(ctx);
  let if_block = ctx[30] && create_if_block_1$5(ctx);
  const assign_li = () => ctx[25](li, i);
  const unassign_li = () => ctx[25](null, i);
  function click_handler_2() {
    return ctx[26](ctx[29]);
  }
  function keydown_handler(...args) {
    return ctx[27](ctx[29], ...args);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        class: true,
        role: true,
        "aria-selected": true,
        tabindex: true
      });
      var li_nodes = children(li);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(li_nodes);
      t0 = claim_space(li_nodes);
      if (if_block)
        if_block.l(li_nodes);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", "dropdown__option s-IZ64dNwyu-gU");
      attr_dev(li, "role", "option");
      attr_dev(li, "aria-selected", li_aria_selected_value = ctx[30]);
      attr_dev(li, "tabindex", li_tabindex_value = ctx[30] || !ctx[0] && ctx[32] === 0 ? 0 : -1);
      toggle_class(li, "selected", ctx[30]);
      add_location(li, file$d, 187, 8, 5264);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(li, null);
      }
      append_hydration_dev(li, t0);
      if (if_block)
        if_block.m(li, null);
      append_hydration_dev(li, t1);
      assign_li();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", click_handler_2, false, false, false),
          listen_dev(li, "keydown", prevent_default(keydown_handler), false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 524305)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[19],
            !current ? get_all_dirty_from_scope(ctx[19]) : get_slot_changes(default_slot_template, ctx[19], dirty, get_default_slot_changes$5),
            get_default_slot_context$5
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 16)) {
          default_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
        }
      }
      if (ctx[30]) {
        if (if_block) {
          if (dirty[0] & 17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$5(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(li, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 17 && li_aria_selected_value !== (li_aria_selected_value = ctx[30])) {
        attr_dev(li, "aria-selected", li_aria_selected_value);
      }
      if (!current || dirty[0] & 17 && li_tabindex_value !== (li_tabindex_value = ctx[30] || !ctx[0] && ctx[32] === 0 ? 0 : -1)) {
        attr_dev(li, "tabindex", li_tabindex_value);
      }
      if (i !== ctx[32]) {
        unassign_li();
        i = ctx[32];
        assign_li();
      }
      if (!current || dirty[0] & 17) {
        toggle_class(li, "selected", ctx[30]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
      unassign_li();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$6.name,
    type: "each",
    source: "(186:6) {#each options as option, i}",
    ctx
  });
  return block;
}
function create_fragment$e(ctx) {
  let div2;
  let div0;
  let t0;
  let div0_id_value;
  let t1;
  let div1;
  let button;
  let t2;
  let button_aria_controls_value;
  let button_aria_labelledby_value;
  let typeahead_action;
  let t3;
  let t4;
  let div2_class_value;
  let div2_style_value;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return create_if_block_4$4;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (ctx[7] || !ctx[7] && !ctx[0]) && create_if_block_3$4(ctx);
  let if_block2 = !ctx[7] && ctx[0] && create_if_block_2$5(ctx);
  let if_block3 = ctx[1] && create_if_block$a(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[3]);
      t1 = space();
      div1 = element("div");
      button = element("button");
      if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { id: true, class: true, style: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { id: true, class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, ctx[3]);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      button = claim_element(div1_nodes, "BUTTON", {
        role: true,
        class: true,
        type: true,
        "aria-haspopup": true,
        "aria-controls": true,
        "aria-expanded": true,
        "aria-autocomplete": true,
        "aria-disabled": true,
        "aria-labelledby": true
      });
      var button_nodes = children(button);
      if_block0.l(button_nodes);
      t2 = claim_space(button_nodes);
      if (if_block1)
        if_block1.l(button_nodes);
      button_nodes.forEach(detach_dev);
      t3 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t4 = claim_space(div2_nodes);
      if (if_block3)
        if_block3.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "id", div0_id_value = ctx[2] + "__label");
      attr_dev(div0, "class", "dropdown__label s-IZ64dNwyu-gU");
      toggle_class(div0, "visually-hidden", ctx[6]);
      add_location(div0, file$d, 101, 2, 2995);
      attr_dev(button, "role", "combobox");
      attr_dev(button, "class", "dropdown__field | reset s-IZ64dNwyu-gU");
      attr_dev(button, "type", "button");
      attr_dev(button, "aria-haspopup", "listbox");
      attr_dev(button, "aria-controls", button_aria_controls_value = ctx[1] ? `${ctx[2]}__listbox` : null);
      attr_dev(button, "aria-expanded", ctx[1]);
      attr_dev(button, "aria-autocomplete", "none");
      attr_dev(button, "aria-disabled", ctx[9]);
      attr_dev(button, "aria-labelledby", button_aria_labelledby_value = ctx[2] + "__label");
      button.disabled = false;
      add_location(button, file$d, 109, 4, 3165);
      attr_dev(div1, "class", "dropdown__button-wrapper s-IZ64dNwyu-gU");
      add_location(div1, file$d, 108, 2, 3122);
      attr_dev(div2, "id", ctx[2]);
      attr_dev(div2, "class", div2_class_value = null_to_empty(ctx[18].class) + " s-IZ64dNwyu-gU");
      attr_dev(div2, "style", div2_style_value = ctx[18].style);
      toggle_class(div2, "dropdown", true);
      add_location(div2, file$d, 95, 0, 2899);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, button);
      if_block0.m(button, null);
      append_hydration_dev(button, t2);
      if (if_block1)
        if_block1.m(button, null);
      ctx[21](button);
      append_hydration_dev(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
      append_hydration_dev(div2, t4);
      if (if_block3)
        if_block3.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "click", ctx[17], false, false, false),
          listen_dev(button, "click", ctx[22], false, false, false),
          action_destroyer(typeahead_action = typeahead.call(null, button, {
            handleInput: ctx[23]
          })),
          listen_dev(button, "keydown", ctx[16], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & 8)
        set_data_dev(t0, ctx2[3]);
      if (!current || dirty[0] & 4 && div0_id_value !== (div0_id_value = ctx2[2] + "__label")) {
        attr_dev(div0, "id", div0_id_value);
      }
      if (!current || dirty[0] & 64) {
        toggle_class(div0, "visually-hidden", ctx2[6]);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(button, t2);
        }
      }
      if (ctx2[7] || !ctx2[7] && !ctx2[0]) {
        if (if_block1) {
          if (dirty[0] & 129) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(button, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 6 && button_aria_controls_value !== (button_aria_controls_value = ctx2[1] ? `${ctx2[2]}__listbox` : null)) {
        attr_dev(button, "aria-controls", button_aria_controls_value);
      }
      if (!current || dirty[0] & 2) {
        attr_dev(button, "aria-expanded", ctx2[1]);
      }
      if (!current || dirty[0] & 512) {
        attr_dev(button, "aria-disabled", ctx2[9]);
      }
      if (!current || dirty[0] & 4 && button_aria_labelledby_value !== (button_aria_labelledby_value = ctx2[2] + "__label")) {
        attr_dev(button, "aria-labelledby", button_aria_labelledby_value);
      }
      if (typeahead_action && is_function(typeahead_action.update) && dirty[0] & 785)
        typeahead_action.update.call(null, {
          handleInput: ctx2[23]
        });
      if (!ctx2[7] && ctx2[0]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 129) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$5(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$a(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 4) {
        attr_dev(div2, "id", ctx2[2]);
      }
      if (!current || dirty[0] & 262144 && div2_class_value !== (div2_class_value = null_to_empty(ctx2[18].class) + " s-IZ64dNwyu-gU")) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & 262144 && div2_style_value !== (div2_style_value = ctx2[18].style)) {
        attr_dev(div2, "style", div2_style_value);
      }
      if (!current || dirty[0] & 262144) {
        toggle_class(div2, "dropdown", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[21](null);
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$e.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$e($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "id",
    "label",
    "options",
    "placeholder",
    "hideLabelVisually",
    "selectedOption",
    "isOpen",
    "hideClearButton",
    "formatOption",
    "disabled"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dropdown", slots, ["default"]);
  let { id } = $$props;
  let { label } = $$props;
  let { options } = $$props;
  let { placeholder } = $$props;
  let { hideLabelVisually = false } = $$props;
  let { selectedOption = void 0 } = $$props;
  let { isOpen = false } = $$props;
  let { hideClearButton = false } = $$props;
  let { formatOption = (option) => option } = $$props;
  let { disabled = false } = $$props;
  let focusedIndex;
  let selectElement;
  let optionElements = [];
  function selectOption(value) {
    $$invalidate(0, selectedOption = value);
    closePopup();
  }
  function closePopup() {
    $$invalidate(1, isOpen = false);
    selectElement.focus();
  }
  function reset() {
    if (isOpen)
      $$invalidate(1, isOpen = false);
    else {
      $$invalidate(0, selectedOption = void 0);
      $$invalidate(10, focusedIndex = void 0);
    }
  }
  function handleKeyDown(e) {
    if (disabled)
      return;
    if (e.key === "Escape") {
      reset();
      return;
    }
    if (e.key === "ArrowDown" || e.key === "ArrowUp") {
      e.preventDefault();
      $$invalidate(1, isOpen = true);
      tick().then(() => {
        const defaultIndex = e.key === "ArrowDown" ? 0 : options.length - 1;
        const nextIndex = focusedIndex !== void 0 ? focusedIndex : defaultIndex;
        $$invalidate(10, focusedIndex = nextIndex);
      });
    }
  }
  function handleClickOutside(e) {
    const node = e.target;
    if (node === selectElement || node.tagName === "LI" && node.getAttribute("role") === "option")
      return;
    $$invalidate(1, isOpen = false);
  }
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Dropdown> was created without expected prop 'id'");
    }
    if (label === void 0 && !("label" in $$props || $$self.$$.bound[$$self.$$.props["label"]])) {
      console.warn("<Dropdown> was created without expected prop 'label'");
    }
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<Dropdown> was created without expected prop 'options'");
    }
    if (placeholder === void 0 && !("placeholder" in $$props || $$self.$$.bound[$$self.$$.props["placeholder"]])) {
      console.warn("<Dropdown> was created without expected prop 'placeholder'");
    }
  });
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      selectElement = $$value;
      $$invalidate(12, selectElement);
    });
  }
  const click_handler = () => {
    if (disabled)
      return;
    $$invalidate(1, isOpen = !isOpen);
    if (isOpen) {
      tick().then(() => {
        const nextIndex = focusedIndex || 0;
        $$invalidate(10, focusedIndex = nextIndex);
      });
    }
  };
  const typeahead_function = (input) => {
    if (disabled)
      return;
    const option = options.find((o) => formatOption(o).toLowerCase().startsWith(input));
    if (!option)
      return;
    $$invalidate(0, selectedOption = option);
  };
  const click_handler_1 = () => reset();
  function li_binding($$value, i) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      optionElements[i] = $$value;
      $$invalidate(11, optionElements);
    });
  }
  const click_handler_2 = (option) => selectOption(option);
  const keydown_handler = (option, e) => {
    switch (e.key) {
      case "Escape":
        closePopup();
        return;
      case "Enter":
      case "Spacebar":
      case " ":
        selectOption(option);
        return;
      case "Home":
        $$invalidate(10, focusedIndex = 0);
        return;
      case "End":
        $$invalidate(10, focusedIndex = options.length - 1);
    }
    if (focusedIndex === void 0) {
      $$invalidate(10, focusedIndex = 0);
      return;
    }
    const getNextIndex = e.key === "ArrowUp" ? getIndexBefore : getIndexAfter;
    $$invalidate(10, focusedIndex = getNextIndex(focusedIndex, options.length));
  };
  const typeahead_function_1 = (input) => {
    const index = options.findIndex((o) => formatOption(o).toLowerCase().startsWith(input));
    if (index < 0)
      return;
    $$invalidate(10, focusedIndex = index);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("label" in $$new_props)
      $$invalidate(3, label = $$new_props.label);
    if ("options" in $$new_props)
      $$invalidate(4, options = $$new_props.options);
    if ("placeholder" in $$new_props)
      $$invalidate(5, placeholder = $$new_props.placeholder);
    if ("hideLabelVisually" in $$new_props)
      $$invalidate(6, hideLabelVisually = $$new_props.hideLabelVisually);
    if ("selectedOption" in $$new_props)
      $$invalidate(0, selectedOption = $$new_props.selectedOption);
    if ("isOpen" in $$new_props)
      $$invalidate(1, isOpen = $$new_props.isOpen);
    if ("hideClearButton" in $$new_props)
      $$invalidate(7, hideClearButton = $$new_props.hideClearButton);
    if ("formatOption" in $$new_props)
      $$invalidate(8, formatOption = $$new_props.formatOption);
    if ("disabled" in $$new_props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tick,
    DropdownIcon,
    CheckIcon,
    ErrorCloseIcon,
    typeahead,
    getIndexBefore,
    getIndexAfter,
    id,
    label,
    options,
    placeholder,
    hideLabelVisually,
    selectedOption,
    isOpen,
    hideClearButton,
    formatOption,
    disabled,
    focusedIndex,
    selectElement,
    optionElements,
    selectOption,
    closePopup,
    reset,
    handleKeyDown,
    handleClickOutside
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(2, id = $$new_props.id);
    if ("label" in $$props)
      $$invalidate(3, label = $$new_props.label);
    if ("options" in $$props)
      $$invalidate(4, options = $$new_props.options);
    if ("placeholder" in $$props)
      $$invalidate(5, placeholder = $$new_props.placeholder);
    if ("hideLabelVisually" in $$props)
      $$invalidate(6, hideLabelVisually = $$new_props.hideLabelVisually);
    if ("selectedOption" in $$props)
      $$invalidate(0, selectedOption = $$new_props.selectedOption);
    if ("isOpen" in $$props)
      $$invalidate(1, isOpen = $$new_props.isOpen);
    if ("hideClearButton" in $$props)
      $$invalidate(7, hideClearButton = $$new_props.hideClearButton);
    if ("formatOption" in $$props)
      $$invalidate(8, formatOption = $$new_props.formatOption);
    if ("disabled" in $$props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("focusedIndex" in $$props)
      $$invalidate(10, focusedIndex = $$new_props.focusedIndex);
    if ("selectElement" in $$props)
      $$invalidate(12, selectElement = $$new_props.selectElement);
    if ("optionElements" in $$props)
      $$invalidate(11, optionElements = $$new_props.optionElements);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 17) {
      $$invalidate(10, focusedIndex = selectedOption ? options.indexOf(selectedOption) : void 0);
    }
    if ($$self.$$.dirty[0] & 3072) {
      if (focusedIndex !== void 0 && focusedIndex >= 0 && optionElements[focusedIndex])
        optionElements[focusedIndex].focus();
    }
  };
  return [
    selectedOption,
    isOpen,
    id,
    label,
    options,
    placeholder,
    hideLabelVisually,
    hideClearButton,
    formatOption,
    disabled,
    focusedIndex,
    optionElements,
    selectElement,
    selectOption,
    closePopup,
    reset,
    handleKeyDown,
    handleClickOutside,
    $$restProps,
    $$scope,
    slots,
    button_binding,
    click_handler,
    typeahead_function,
    click_handler_1,
    li_binding,
    click_handler_2,
    keydown_handler,
    typeahead_function_1
  ];
}
class Dropdown extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance$e,
      create_fragment$e,
      safe_not_equal,
      {
        id: 2,
        label: 3,
        options: 4,
        placeholder: 5,
        hideLabelVisually: 6,
        selectedOption: 0,
        isOpen: 1,
        hideClearButton: 7,
        formatOption: 8,
        disabled: 9
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dropdown",
      options,
      id: create_fragment$e.name
    });
  }
  get id() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabelVisually() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabelVisually(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedOption() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedOption(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideClearButton() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideClearButton(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatOption() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatOption(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Dropdown_story_svelte_svelte_type_style_lang = "";
const file$c = "src/lib/components/shared/Dropdown.story.svelte";
function create_if_block_6$1(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$c, 20, 10, 626);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6$1.name,
    type: "if",
    source: "(20:8) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_8$4(ctx) {
  let div1;
  let dropdown;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function dropdown_selectedOption_binding(value) {
    ctx[4](value);
  }
  let dropdown_props = {
    id: "my-unique-dropdown-id",
    label: "Wähle eine Jahreszeit",
    options: ["Frühling", "Sommer", "Herbst", "Winter"],
    placeholder: "Jahreszeiten"
  };
  if (ctx[1] !== void 0) {
    dropdown_props.selectedOption = ctx[1];
  }
  dropdown = new Dropdown({ props: dropdown_props, $$inline: true });
  binding_callbacks.push(() => bind(dropdown, "selectedOption", dropdown_selectedOption_binding, ctx[1]));
  let if_block = ctx[1] && create_if_block_6$1(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(dropdown.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(dropdown.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-7YONNAxMYvH2");
      add_location(div0, file$c, 17, 6, 542);
      attr_dev(div1, "class", "wrapper s-7YONNAxMYvH2");
      add_location(div1, file$c, 9, 4, 292);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(dropdown, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dropdown_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        dropdown_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      dropdown.$set(dropdown_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_6$1(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(dropdown);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8$4.name,
    type: "slot",
    source: '(9:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_if_block_5$2(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$c, 39, 10, 1105);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5$2.name,
    type: "if",
    source: "(39:8) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_7$4(ctx) {
  let div1;
  let dropdown;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function dropdown_selectedOption_binding_1(value) {
    ctx[5](value);
  }
  let dropdown_props = {
    id: "my-unique-dropdown-id",
    label: "Wähle eine Jahreszeit",
    options: ["Frühling", "Sommer", "Herbst", "Winter"],
    placeholder: "Jahreszeiten",
    isOpen: true
  };
  if (ctx[1] !== void 0) {
    dropdown_props.selectedOption = ctx[1];
  }
  dropdown = new Dropdown({ props: dropdown_props, $$inline: true });
  binding_callbacks.push(() => bind(dropdown, "selectedOption", dropdown_selectedOption_binding_1, ctx[1]));
  let if_block = ctx[1] && create_if_block_5$2(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(dropdown.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(dropdown.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-7YONNAxMYvH2");
      add_location(div0, file$c, 36, 6, 1021);
      attr_dev(div1, "class", "wrapper s-7YONNAxMYvH2");
      add_location(div1, file$c, 27, 4, 749);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(dropdown, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dropdown_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        dropdown_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      dropdown.$set(dropdown_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5$2(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(dropdown);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7$4.name,
    type: "slot",
    source: '(27:2) <Hst.Variant title=\\"Initially Open\\">',
    ctx
  });
  return block;
}
function create_if_block_4$3(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[3]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[3]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$c, 57, 10, 1621);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4$3.name,
    type: "if",
    source: "(57:8) {#if selectedOptionInitiallySet}",
    ctx
  });
  return block;
}
function create_default_slot_6$5(ctx) {
  let div1;
  let dropdown;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function dropdown_selectedOption_binding_2(value) {
    ctx[6](value);
  }
  let dropdown_props = {
    id: "my-unique-dropdown-id",
    label: "Wähle eine Jahreszeit",
    options: ["Frühling", "Sommer", "Herbst", "Winter"],
    placeholder: "Jahreszeiten"
  };
  if (ctx[3] !== void 0) {
    dropdown_props.selectedOption = ctx[3];
  }
  dropdown = new Dropdown({ props: dropdown_props, $$inline: true });
  binding_callbacks.push(() => bind(dropdown, "selectedOption", dropdown_selectedOption_binding_2, ctx[3]));
  let if_block = ctx[3] && create_if_block_4$3(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(dropdown.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(dropdown.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-7YONNAxMYvH2");
      add_location(div0, file$c, 54, 6, 1525);
      attr_dev(div1, "class", "wrapper s-7YONNAxMYvH2");
      add_location(div1, file$c, 46, 4, 1246);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(dropdown, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dropdown_changes = {};
      if (!updating_selectedOption && dirty & 8) {
        updating_selectedOption = true;
        dropdown_changes.selectedOption = ctx2[3];
        add_flush_callback(() => updating_selectedOption = false);
      }
      dropdown.$set(dropdown_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$3(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(dropdown);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$5.name,
    type: "slot",
    source: '(46:2) <Hst.Variant title=\\"Specify initially selected value\\">',
    ctx
  });
  return block;
}
function create_default_slot_5$6(ctx) {
  let t_value = ctx[11].label + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2048 && t_value !== (t_value = ctx2[11].label + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$6.name,
    type: "slot",
    source: `(66:6) <Dropdown         id=\\"my-unique-dropdown-id\\"         label=\\"Wähle eine Jahreszeit\\"         options={[           { label: 'Frühling', value: 'spring' },           { label: 'Sommer', value: 'summer' },           { label: 'Herbst', value: 'autumn' },           { label: 'Winter', value: 'winter' },         ]}         placeholder=\\"Jahreszeiten\\"         formatOption={(option) => option.label}         bind:selectedOption={selectedComplexOption}         let:option       >`,
    ctx
  });
  return block;
}
function create_if_block_3$3(ctx) {
  let t_value = JSON.stringify(ctx[2], null, 2) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = JSON.stringify(ctx2[2], null, 2) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3$3.name,
    type: "if",
    source: "(84:8) {#if selectedComplexOption}",
    ctx
  });
  return block;
}
function create_default_slot_4$6(ctx) {
  let div1;
  let dropdown;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function dropdown_selectedOption_binding_3(value) {
    ctx[7](value);
  }
  let dropdown_props = {
    id: "my-unique-dropdown-id",
    label: "Wähle eine Jahreszeit",
    options: [
      { label: "Frühling", value: "spring" },
      { label: "Sommer", value: "summer" },
      { label: "Herbst", value: "autumn" },
      { label: "Winter", value: "winter" }
    ],
    placeholder: "Jahreszeiten",
    formatOption: func$4,
    $$slots: {
      default: [
        create_default_slot_5$6,
        ({ option }) => ({ 11: option }),
        ({ option }) => option ? 2048 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[2] !== void 0) {
    dropdown_props.selectedOption = ctx[2];
  }
  dropdown = new Dropdown({ props: dropdown_props, $$inline: true });
  binding_callbacks.push(() => bind(dropdown, "selectedOption", dropdown_selectedOption_binding_3, ctx[2]));
  let if_block = ctx[2] && create_if_block_3$3(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(dropdown.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(dropdown.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-7YONNAxMYvH2");
      add_location(div0, file$c, 81, 6, 2301);
      attr_dev(div1, "class", "wrapper s-7YONNAxMYvH2");
      add_location(div1, file$c, 64, 4, 1757);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(dropdown, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dropdown_changes = {};
      if (dirty & 6144) {
        dropdown_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedOption && dirty & 4) {
        updating_selectedOption = true;
        dropdown_changes.selectedOption = ctx2[2];
        add_flush_callback(() => updating_selectedOption = false);
      }
      dropdown.$set(dropdown_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$3(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(dropdown);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$6.name,
    type: "slot",
    source: '(64:2) <Hst.Variant title=\\"Complex options\\">',
    ctx
  });
  return block;
}
function create_if_block_2$4(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$c, 103, 10, 2885);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$4.name,
    type: "if",
    source: "(103:8) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_3$7(ctx) {
  let div1;
  let dropdown;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function dropdown_selectedOption_binding_4(value) {
    ctx[8](value);
  }
  let dropdown_props = {
    id: "my-unique-dropdown-id",
    label: "Wähle eine Jahreszeit",
    options: ["Frühling", "Sommer", "Herbst", "Winter"],
    placeholder: "Jahreszeiten",
    disabled: true
  };
  if (ctx[1] !== void 0) {
    dropdown_props.selectedOption = ctx[1];
  }
  dropdown = new Dropdown({ props: dropdown_props, $$inline: true });
  binding_callbacks.push(() => bind(dropdown, "selectedOption", dropdown_selectedOption_binding_4, ctx[1]));
  let if_block = ctx[1] && create_if_block_2$4(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(dropdown.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(dropdown.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-7YONNAxMYvH2");
      add_location(div0, file$c, 100, 6, 2801);
      attr_dev(div1, "class", "wrapper s-7YONNAxMYvH2");
      add_location(div1, file$c, 91, 4, 2534);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(dropdown, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dropdown_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        dropdown_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      dropdown.$set(dropdown_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$4(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(dropdown);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$7.name,
    type: "slot",
    source: '(91:2) <Hst.Variant title=\\"Disabled\\">',
    ctx
  });
  return block;
}
function create_if_block_1$4(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$c, 122, 10, 3369);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$4.name,
    type: "if",
    source: "(122:8) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_2$7(ctx) {
  let div1;
  let dropdown;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function dropdown_selectedOption_binding_5(value) {
    ctx[9](value);
  }
  let dropdown_props = {
    id: "my-unique-dropdown-id",
    label: "Wähle eine Jahreszeit",
    options: ["Frühling", "Sommer", "Herbst", "Winter"],
    placeholder: "Jahreszeiten",
    hideClearButton: true
  };
  if (ctx[1] !== void 0) {
    dropdown_props.selectedOption = ctx[1];
  }
  dropdown = new Dropdown({ props: dropdown_props, $$inline: true });
  binding_callbacks.push(() => bind(dropdown, "selectedOption", dropdown_selectedOption_binding_5, ctx[1]));
  let if_block = ctx[1] && create_if_block_1$4(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(dropdown.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(dropdown.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-7YONNAxMYvH2");
      add_location(div0, file$c, 119, 6, 3285);
      attr_dev(div1, "class", "wrapper s-7YONNAxMYvH2");
      add_location(div1, file$c, 110, 4, 3011);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(dropdown, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dropdown_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        dropdown_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      dropdown.$set(dropdown_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$4(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(dropdown);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$7.name,
    type: "slot",
    source: '(110:2) <Hst.Variant title=\\"Hide clear button\\">',
    ctx
  });
  return block;
}
function create_if_block$9(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$c, 141, 10, 3857);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$9.name,
    type: "if",
    source: "(141:8) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_1$7(ctx) {
  let div1;
  let dropdown;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function dropdown_selectedOption_binding_6(value) {
    ctx[10](value);
  }
  let dropdown_props = {
    id: "my-unique-dropdown-id",
    label: "Wähle eine Jahreszeit",
    hideLabelVisually: true,
    options: ["Frühling", "Sommer", "Herbst", "Winter"],
    placeholder: "Jahreszeiten"
  };
  if (ctx[1] !== void 0) {
    dropdown_props.selectedOption = ctx[1];
  }
  dropdown = new Dropdown({ props: dropdown_props, $$inline: true });
  binding_callbacks.push(() => bind(dropdown, "selectedOption", dropdown_selectedOption_binding_6, ctx[1]));
  let if_block = ctx[1] && create_if_block$9(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(dropdown.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(dropdown.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-7YONNAxMYvH2");
      add_location(div0, file$c, 138, 6, 3773);
      attr_dev(div1, "class", "wrapper s-7YONNAxMYvH2");
      add_location(div1, file$c, 129, 4, 3497);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(dropdown, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const dropdown_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        dropdown_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      dropdown.$set(dropdown_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$9(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(dropdown);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$7.name,
    type: "slot",
    source: '(129:2) <Hst.Variant title=\\"Hide label visually\\">',
    ctx
  });
  return block;
}
function create_default_slot$7(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let t2;
  let hst_variant3;
  let t3;
  let hst_variant4;
  let t4;
  let hst_variant5;
  let t5;
  let hst_variant6;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_8$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Initially Open",
      $$slots: { default: [create_default_slot_7$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Specify initially selected value",
      $$slots: { default: [create_default_slot_6$5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant3 = new ctx[0].Variant({
    props: {
      title: "Complex options",
      $$slots: { default: [create_default_slot_4$6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant4 = new ctx[0].Variant({
    props: {
      title: "Disabled",
      $$slots: { default: [create_default_slot_3$7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant5 = new ctx[0].Variant({
    props: {
      title: "Hide clear button",
      $$slots: { default: [create_default_slot_2$7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant6 = new ctx[0].Variant({
    props: {
      title: "Hide label visually",
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
      t2 = space();
      create_component(hst_variant3.$$.fragment);
      t3 = space();
      create_component(hst_variant4.$$.fragment);
      t4 = space();
      create_component(hst_variant5.$$.fragment);
      t5 = space();
      create_component(hst_variant6.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_variant3.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(hst_variant4.$$.fragment, nodes);
      t4 = claim_space(nodes);
      claim_component(hst_variant5.$$.fragment, nodes);
      t5 = claim_space(nodes);
      claim_component(hst_variant6.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_variant3, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(hst_variant4, target, anchor);
      insert_hydration_dev(target, t4, anchor);
      mount_component(hst_variant5, target, anchor);
      insert_hydration_dev(target, t5, anchor);
      mount_component(hst_variant6, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 4098) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 4098) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 4104) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
      const hst_variant3_changes = {};
      if (dirty & 4100) {
        hst_variant3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant3.$set(hst_variant3_changes);
      const hst_variant4_changes = {};
      if (dirty & 4098) {
        hst_variant4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant4.$set(hst_variant4_changes);
      const hst_variant5_changes = {};
      if (dirty & 4098) {
        hst_variant5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant5.$set(hst_variant5_changes);
      const hst_variant6_changes = {};
      if (dirty & 4098) {
        hst_variant6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant6.$set(hst_variant6_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      transition_in(hst_variant3.$$.fragment, local);
      transition_in(hst_variant4.$$.fragment, local);
      transition_in(hst_variant5.$$.fragment, local);
      transition_in(hst_variant6.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      transition_out(hst_variant3.$$.fragment, local);
      transition_out(hst_variant4.$$.fragment, local);
      transition_out(hst_variant5.$$.fragment, local);
      transition_out(hst_variant6.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_variant3, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(hst_variant4, detaching);
      if (detaching)
        detach_dev(t4);
      destroy_component(hst_variant5, detaching);
      if (detaching)
        detach_dev(t5);
      destroy_component(hst_variant6, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$7.name,
    type: "slot",
    source: `(8:0) <Hst.Story group=\\"ui\\" title=\\"Dropdown\\" layout={{ type: 'grid', width: '100%' }}>`,
    ctx
  });
  return block;
}
function create_fragment$d(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "ui",
      title: "Dropdown",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 4110) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$d.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const func$4 = (option) => option.label;
function instance$d($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dropdown_story", slots, []);
  let { Hst } = $$props;
  let selectedOption;
  let selectedComplexOption;
  let selectedOptionInitiallySet = "Sommer";
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Dropdown_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Dropdown_story> was created with unknown prop '${key}'`);
  });
  function dropdown_selectedOption_binding(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  function dropdown_selectedOption_binding_1(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  function dropdown_selectedOption_binding_2(value) {
    selectedOptionInitiallySet = value;
    $$invalidate(3, selectedOptionInitiallySet);
  }
  function dropdown_selectedOption_binding_3(value) {
    selectedComplexOption = value;
    $$invalidate(2, selectedComplexOption);
  }
  function dropdown_selectedOption_binding_4(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  function dropdown_selectedOption_binding_5(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  function dropdown_selectedOption_binding_6(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    Dropdown,
    selectedOption,
    selectedComplexOption,
    selectedOptionInitiallySet
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("selectedOption" in $$props2)
      $$invalidate(1, selectedOption = $$props2.selectedOption);
    if ("selectedComplexOption" in $$props2)
      $$invalidate(2, selectedComplexOption = $$props2.selectedComplexOption);
    if ("selectedOptionInitiallySet" in $$props2)
      $$invalidate(3, selectedOptionInitiallySet = $$props2.selectedOptionInitiallySet);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    selectedOption,
    selectedComplexOption,
    selectedOptionInitiallySet,
    dropdown_selectedOption_binding,
    dropdown_selectedOption_binding_1,
    dropdown_selectedOption_binding_2,
    dropdown_selectedOption_binding_3,
    dropdown_selectedOption_binding_4,
    dropdown_selectedOption_binding_5,
    dropdown_selectedOption_binding_6
  ];
}
class Dropdown_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$d, create_fragment$d, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dropdown_story",
      options,
      id: create_fragment$d.name
    });
  }
  get Hst() {
    throw new Error("<Dropdown_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Dropdown_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const RadioButtons_svelte_svelte_type_style_lang = "";
const file$b = "src/lib/components/shared/RadioButtons.svelte";
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  const constants_0 = child_ctx[14] === child_ctx[0];
  child_ctx[15] = constants_0;
  const constants_1 = child_ctx[5](child_ctx[14]);
  child_ctx[16] = constants_1;
  const constants_2 = child_ctx[14] === child_ctx[6];
  child_ctx[17] = constants_2;
  return child_ctx;
}
const get_default_slot_changes$4 = (dirty) => ({
  option: dirty & 4,
  selected: dirty & 5
});
const get_default_slot_context$4 = (ctx) => ({
  option: ctx[14],
  selected: ctx[15]
});
function create_if_block$8(ctx) {
  let legend;
  let t;
  const block = {
    c: function create() {
      legend = element("legend");
      t = text(ctx[3]);
      this.h();
    },
    l: function claim(nodes) {
      legend = claim_element(nodes, "LEGEND", { class: true });
      var legend_nodes = children(legend);
      t = claim_text(legend_nodes, ctx[3]);
      legend_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(legend, "class", "radio-buttons__label s-nrD3FYVJ6rL7");
      toggle_class(legend, "visually-hidden", ctx[4]);
      add_location(legend, file$b, 38, 4, 1091);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, legend, anchor);
      append_hydration_dev(legend, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
      if (dirty & 16) {
        toggle_class(legend, "visually-hidden", ctx2[4]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(legend);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$8.name,
    type: "if",
    source: "(38:2) {#if label}",
    ctx
  });
  return block;
}
function fallback_block$4(ctx) {
  let t_value = ctx[14] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[14] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$4.name,
    type: "fallback",
    source: "(72:40)          ",
    ctx
  });
  return block;
}
function create_each_block$5(ctx) {
  let label_1;
  let input;
  let input_value_value;
  let input_disabled_value;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  function focus_handler(...args) {
    return ctx[12](ctx[14], ...args);
  }
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], get_default_slot_context$4);
  const default_slot_or_fallback = default_slot || fallback_block$4(ctx);
  const block = {
    c: function create() {
      label_1 = element("label");
      input = element("input");
      t0 = space();
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true });
      var label_1_nodes = children(label_1);
      input = claim_element(label_1_nodes, "INPUT", { class: true, type: true, name: true });
      t0 = claim_space(label_1_nodes);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(label_1_nodes);
      t1 = claim_space(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "radio-buttons__input s-nrD3FYVJ6rL7");
      attr_dev(input, "type", "radio");
      attr_dev(input, "name", ctx[1]);
      input.__value = input_value_value = ctx[14];
      input.value = input.__value;
      input.disabled = input_disabled_value = ctx[16];
      ctx[11][0].push(input);
      add_location(input, file$b, 56, 6, 1549);
      attr_dev(label_1, "class", "radio-buttons__option s-nrD3FYVJ6rL7");
      toggle_class(label_1, "focused", ctx[17]);
      toggle_class(label_1, "checked", ctx[15]);
      toggle_class(label_1, "selected", ctx[15]);
      toggle_class(label_1, "disabled", ctx[16]);
      add_location(label_1, file$b, 49, 4, 1402);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, input);
      input.checked = input.__value === ctx[0];
      append_hydration_dev(label_1, t0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(label_1, null);
      }
      append_hydration_dev(label_1, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(input, "change", ctx[10]),
          listen_dev(input, "focus", focus_handler, false, false, false),
          listen_dev(input, "blur", ctx[13], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & 2) {
        attr_dev(input, "name", ctx[1]);
      }
      if (!current || dirty & 4 && input_value_value !== (input_value_value = ctx[14])) {
        prop_dev(input, "__value", input_value_value);
        input.value = input.__value;
      }
      if (!current || dirty & 36 && input_disabled_value !== (input_disabled_value = ctx[16])) {
        prop_dev(input, "disabled", input_disabled_value);
      }
      if (dirty & 1) {
        input.checked = input.__value === ctx[0];
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 261)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[8],
            !current ? get_all_dirty_from_scope(ctx[8]) : get_slot_changes(default_slot_template, ctx[8], dirty, get_default_slot_changes$4),
            get_default_slot_context$4
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
          default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 68) {
        toggle_class(label_1, "focused", ctx[17]);
      }
      if (!current || dirty & 5) {
        toggle_class(label_1, "checked", ctx[15]);
      }
      if (!current || dirty & 5) {
        toggle_class(label_1, "selected", ctx[15]);
      }
      if (!current || dirty & 36) {
        toggle_class(label_1, "disabled", ctx[16]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      ctx[11][0].splice(ctx[11][0].indexOf(input), 1);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$5.name,
    type: "each",
    source: "(46:2) {#each options as option}",
    ctx
  });
  return block;
}
function create_fragment$c(ctx) {
  let fieldset;
  let t;
  let fieldset_class_value;
  let fieldset_style_value;
  let current;
  let if_block = ctx[3] && create_if_block$8(ctx);
  let each_value = ctx[2];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      fieldset = element("fieldset");
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      fieldset = claim_element(nodes, "FIELDSET", { id: true, class: true, style: true });
      var fieldset_nodes = children(fieldset);
      if (if_block)
        if_block.l(fieldset_nodes);
      t = claim_space(fieldset_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(fieldset_nodes);
      }
      fieldset_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(fieldset, "id", ctx[1]);
      attr_dev(fieldset, "class", fieldset_class_value = null_to_empty(ctx[7].class) + " s-nrD3FYVJ6rL7");
      attr_dev(fieldset, "style", fieldset_style_value = ctx[7].style);
      toggle_class(fieldset, "radio-buttons", true);
      add_location(fieldset, file$b, 31, 0, 969);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, fieldset, anchor);
      if (if_block)
        if_block.m(fieldset, null);
      append_hydration_dev(fieldset, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(fieldset, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          if_block.m(fieldset, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 359) {
        each_value = ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(fieldset, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 2) {
        attr_dev(fieldset, "id", ctx2[1]);
      }
      if (!current || dirty & 128 && fieldset_class_value !== (fieldset_class_value = null_to_empty(ctx2[7].class) + " s-nrD3FYVJ6rL7")) {
        attr_dev(fieldset, "class", fieldset_class_value);
      }
      if (!current || dirty & 128 && fieldset_style_value !== (fieldset_style_value = ctx2[7].style)) {
        attr_dev(fieldset, "style", fieldset_style_value);
      }
      if (!current || dirty & 128) {
        toggle_class(fieldset, "radio-buttons", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(fieldset);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$c.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$c($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "options", "label", "selectedOption", "hideLabelVisually", "isOptionDisabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioButtons", slots, ["default"]);
  let { id } = $$props;
  let { options } = $$props;
  let { label } = $$props;
  let { selectedOption } = $$props;
  let { hideLabelVisually = false } = $$props;
  let { isOptionDisabled = () => false } = $$props;
  let focusedOption = null;
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<RadioButtons> was created without expected prop 'id'");
    }
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<RadioButtons> was created without expected prop 'options'");
    }
    if (label === void 0 && !("label" in $$props || $$self.$$.bound[$$self.$$.props["label"]])) {
      console.warn("<RadioButtons> was created without expected prop 'label'");
    }
    if (selectedOption === void 0 && !("selectedOption" in $$props || $$self.$$.bound[$$self.$$.props["selectedOption"]])) {
      console.warn("<RadioButtons> was created without expected prop 'selectedOption'");
    }
  });
  const $$binding_groups = [[]];
  function input_change_handler() {
    selectedOption = this.__value;
    $$invalidate(0, selectedOption);
  }
  const focus_handler = (option, e) => {
    const node = e.currentTarget;
    if (node.classList.contains("focus-visible")) {
      $$invalidate(6, focusedOption = option);
    }
  };
  const blur_handler = () => $$invalidate(6, focusedOption = null);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(1, id = $$new_props.id);
    if ("options" in $$new_props)
      $$invalidate(2, options = $$new_props.options);
    if ("label" in $$new_props)
      $$invalidate(3, label = $$new_props.label);
    if ("selectedOption" in $$new_props)
      $$invalidate(0, selectedOption = $$new_props.selectedOption);
    if ("hideLabelVisually" in $$new_props)
      $$invalidate(4, hideLabelVisually = $$new_props.hideLabelVisually);
    if ("isOptionDisabled" in $$new_props)
      $$invalidate(5, isOptionDisabled = $$new_props.isOptionDisabled);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    id,
    options,
    label,
    selectedOption,
    hideLabelVisually,
    isOptionDisabled,
    focusedOption
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(1, id = $$new_props.id);
    if ("options" in $$props)
      $$invalidate(2, options = $$new_props.options);
    if ("label" in $$props)
      $$invalidate(3, label = $$new_props.label);
    if ("selectedOption" in $$props)
      $$invalidate(0, selectedOption = $$new_props.selectedOption);
    if ("hideLabelVisually" in $$props)
      $$invalidate(4, hideLabelVisually = $$new_props.hideLabelVisually);
    if ("isOptionDisabled" in $$props)
      $$invalidate(5, isOptionDisabled = $$new_props.isOptionDisabled);
    if ("focusedOption" in $$props)
      $$invalidate(6, focusedOption = $$new_props.focusedOption);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    selectedOption,
    id,
    options,
    label,
    hideLabelVisually,
    isOptionDisabled,
    focusedOption,
    $$restProps,
    $$scope,
    slots,
    input_change_handler,
    $$binding_groups,
    focus_handler,
    blur_handler
  ];
}
class RadioButtons extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$c, create_fragment$c, safe_not_equal, {
      id: 1,
      options: 2,
      label: 3,
      selectedOption: 0,
      hideLabelVisually: 4,
      isOptionDisabled: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioButtons",
      options,
      id: create_fragment$c.name
    });
  }
  get id() {
    throw new Error("<RadioButtons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RadioButtons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<RadioButtons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<RadioButtons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RadioButtons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RadioButtons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedOption() {
    throw new Error("<RadioButtons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedOption(value) {
    throw new Error("<RadioButtons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabelVisually() {
    throw new Error("<RadioButtons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabelVisually(value) {
    throw new Error("<RadioButtons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOptionDisabled() {
    throw new Error("<RadioButtons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOptionDisabled(value) {
    throw new Error("<RadioButtons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const RadioButtons_story_svelte_svelte_type_style_lang = "";
const file$a = "src/lib/components/shared/RadioButtons.story.svelte";
function create_if_block_7(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$a, 22, 8, 563);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(22:6) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_9$2(ctx) {
  let radiobuttons;
  let updating_selectedOption;
  let t0;
  let div;
  let t1;
  let current;
  function radiobuttons_selectedOption_binding(value) {
    ctx[4](value);
  }
  let radiobuttons_props = {
    id: "my-unique-radio-id",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine Region:"
  };
  if (ctx[1] !== void 0) {
    radiobuttons_props.selectedOption = ctx[1];
  }
  radiobuttons = new RadioButtons({
    props: radiobuttons_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(radiobuttons, "selectedOption", radiobuttons_selectedOption_binding, ctx[1]));
  let if_block = ctx[1] && create_if_block_7(ctx);
  const block = {
    c: function create() {
      create_component(radiobuttons.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(radiobuttons.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-9aSb3n_4tAkN");
      add_location(div, file$a, 19, 4, 484);
    },
    m: function mount(target, anchor) {
      mount_component(radiobuttons, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const radiobuttons_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        radiobuttons_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      radiobuttons.$set(radiobuttons_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_7(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(radiobuttons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(radiobuttons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(radiobuttons, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9$2.name,
    type: "slot",
    source: '(13:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[3]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[3]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$a, 37, 8, 994);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(37:6) {#if selectedOptionInitiallySet.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_8$3(ctx) {
  let radiobuttons;
  let updating_selectedOption;
  let t0;
  let div;
  let t1;
  let current;
  function radiobuttons_selectedOption_binding_1(value) {
    ctx[5](value);
  }
  let radiobuttons_props = {
    id: "my-unique-radio-id",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine Region:"
  };
  if (ctx[3] !== void 0) {
    radiobuttons_props.selectedOption = ctx[3];
  }
  radiobuttons = new RadioButtons({
    props: radiobuttons_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(radiobuttons, "selectedOption", radiobuttons_selectedOption_binding_1, ctx[3]));
  let if_block = ctx[3].length > 0 && create_if_block_6(ctx);
  const block = {
    c: function create() {
      create_component(radiobuttons.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(radiobuttons.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-9aSb3n_4tAkN");
      add_location(div, file$a, 34, 4, 892);
    },
    m: function mount(target, anchor) {
      mount_component(radiobuttons, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const radiobuttons_changes = {};
      if (!updating_selectedOption && dirty & 8) {
        updating_selectedOption = true;
        radiobuttons_changes.selectedOption = ctx2[3];
        add_flush_callback(() => updating_selectedOption = false);
      }
      radiobuttons.$set(radiobuttons_changes);
      if (ctx2[3].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_6(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(radiobuttons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(radiobuttons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(radiobuttons, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8$3.name,
    type: "slot",
    source: '(28:2) <Hst.Variant title=\\"Specify initially selected values\\">',
    ctx
  });
  return block;
}
function create_if_block_5$1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(selected)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(selected)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5$1.name,
    type: "if",
    source: "(53:6) {#if selected}",
    ctx
  });
  return block;
}
function create_default_slot_7$3(ctx) {
  let t0;
  let t1_value = ctx[11] + "";
  let t1;
  let t2;
  let if_block_anchor;
  let if_block = ctx[12] && create_if_block_5$1(ctx);
  const block = {
    c: function create() {
      t0 = text("Hallo, ");
      t1 = text(t1_value);
      t2 = text("!\n      ");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, "Hallo, ");
      t1 = claim_text(nodes, t1_value);
      t2 = claim_text(nodes, "!\n      ");
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2048 && t1_value !== (t1_value = ctx2[11] + ""))
        set_data_dev(t1, t1_value);
      if (ctx2[12]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_5$1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7$3.name,
    type: "slot",
    source: `(44:4) <RadioButtons       id=\\"my-unique-radio-id\\"       options={['Berlin', 'Brandenburg', 'Stadt', 'Land']}       label=\\"Wähle eine Region:\\"       bind:selectedOption       let:option       let:selected     >`,
    ctx
  });
  return block;
}
function create_if_block_4$2(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$a, 59, 8, 1501);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4$2.name,
    type: "if",
    source: "(59:6) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_6$4(ctx) {
  let radiobuttons;
  let updating_selectedOption;
  let t0;
  let div;
  let t1;
  let current;
  function radiobuttons_selectedOption_binding_2(value) {
    ctx[6](value);
  }
  let radiobuttons_props = {
    id: "my-unique-radio-id",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine Region:",
    $$slots: {
      default: [
        create_default_slot_7$3,
        ({ option, selected }) => ({ 11: option, 12: selected }),
        ({ option, selected }) => (option ? 2048 : 0) | (selected ? 4096 : 0)
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    radiobuttons_props.selectedOption = ctx[1];
  }
  radiobuttons = new RadioButtons({
    props: radiobuttons_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(radiobuttons, "selectedOption", radiobuttons_selectedOption_binding_2, ctx[1]));
  let if_block = ctx[1] && create_if_block_4$2(ctx);
  const block = {
    c: function create() {
      create_component(radiobuttons.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(radiobuttons.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-9aSb3n_4tAkN");
      add_location(div, file$a, 56, 4, 1422);
    },
    m: function mount(target, anchor) {
      mount_component(radiobuttons, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const radiobuttons_changes = {};
      if (dirty & 14336) {
        radiobuttons_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        radiobuttons_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      radiobuttons.$set(radiobuttons_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$2(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(radiobuttons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(radiobuttons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(radiobuttons, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$4.name,
    type: "slot",
    source: '(43:2) <Hst.Variant title=\\"Custom option label\\">',
    ctx
  });
  return block;
}
function create_if_block_3$2(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$a, 75, 8, 1918);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3$2.name,
    type: "if",
    source: "(75:6) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_5$5(ctx) {
  let radiobuttons;
  let updating_selectedOption;
  let t0;
  let div;
  let t1;
  let current;
  function radiobuttons_selectedOption_binding_3(value) {
    ctx[7](value);
  }
  let radiobuttons_props = {
    id: "my-unique-radio-id",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine Region:",
    isOptionDisabled: func$3
  };
  if (ctx[1] !== void 0) {
    radiobuttons_props.selectedOption = ctx[1];
  }
  radiobuttons = new RadioButtons({
    props: radiobuttons_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(radiobuttons, "selectedOption", radiobuttons_selectedOption_binding_3, ctx[1]));
  let if_block = ctx[1] && create_if_block_3$2(ctx);
  const block = {
    c: function create() {
      create_component(radiobuttons.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected value:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(radiobuttons.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected value:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-9aSb3n_4tAkN");
      add_location(div, file$a, 72, 4, 1840);
    },
    m: function mount(target, anchor) {
      mount_component(radiobuttons, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const radiobuttons_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        radiobuttons_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      radiobuttons.$set(radiobuttons_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$2(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(radiobuttons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(radiobuttons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(radiobuttons, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$5.name,
    type: "slot",
    source: '(65:2) <Hst.Variant title=\\"Disabled option\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$5(ctx) {
  let t_value = ctx[11].label + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2048 && t_value !== (t_value = ctx2[11].label + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$5.name,
    type: "slot",
    source: `(82:4) <RadioButtons       id=\\"my-unique-radio-id\\"       options={[         { label: 'Berlin', value: 'berlin' },         { label: 'Brandenburg', value: 'brandenburg' },         { label: 'Stadt', value: 'city' },         { label: 'Land', value: 'country' },       ]}       label=\\"Wähle eine Region:\\"       bind:selectedOption={selectedComplexOption}       let:option     >`,
    ctx
  });
  return block;
}
function create_if_block_2$3(ctx) {
  let i;
  let t_value = JSON.stringify(ctx[2]) + "";
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, t_value);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$a, 98, 8, 2524);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = JSON.stringify(ctx2[2]) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$3.name,
    type: "if",
    source: "(98:6) {#if selectedComplexOption}",
    ctx
  });
  return block;
}
function create_default_slot_3$6(ctx) {
  let radiobuttons;
  let updating_selectedOption;
  let t0;
  let div;
  let t1;
  let current;
  function radiobuttons_selectedOption_binding_4(value) {
    ctx[8](value);
  }
  let radiobuttons_props = {
    id: "my-unique-radio-id",
    options: [
      { label: "Berlin", value: "berlin" },
      {
        label: "Brandenburg",
        value: "brandenburg"
      },
      { label: "Stadt", value: "city" },
      { label: "Land", value: "country" }
    ],
    label: "Wähle eine Region:",
    $$slots: {
      default: [
        create_default_slot_4$5,
        ({ option }) => ({ 11: option }),
        ({ option }) => option ? 2048 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[2] !== void 0) {
    radiobuttons_props.selectedOption = ctx[2];
  }
  radiobuttons = new RadioButtons({
    props: radiobuttons_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(radiobuttons, "selectedOption", radiobuttons_selectedOption_binding_4, ctx[2]));
  let if_block = ctx[2] && create_if_block_2$3(ctx);
  const block = {
    c: function create() {
      create_component(radiobuttons.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(radiobuttons.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-9aSb3n_4tAkN");
      add_location(div, file$a, 95, 4, 2438);
    },
    m: function mount(target, anchor) {
      mount_component(radiobuttons, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const radiobuttons_changes = {};
      if (dirty & 10240) {
        radiobuttons_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedOption && dirty & 4) {
        updating_selectedOption = true;
        radiobuttons_changes.selectedOption = ctx2[2];
        add_flush_callback(() => updating_selectedOption = false);
      }
      radiobuttons.$set(radiobuttons_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$3(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(radiobuttons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(radiobuttons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(radiobuttons, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$6.name,
    type: "slot",
    source: '(81:2) <Hst.Variant title=\\"Complex options\\">',
    ctx
  });
  return block;
}
function create_if_block_1$3(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$a, 114, 8, 2959);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$3.name,
    type: "if",
    source: "(114:6) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_2$6(ctx) {
  let radiobuttons;
  let updating_selectedOption;
  let t0;
  let div;
  let t1;
  let current;
  function radiobuttons_selectedOption_binding_5(value) {
    ctx[9](value);
  }
  let radiobuttons_props = {
    id: "my-unique-radio-id",
    class: "radio-buttons-with-custom-colors",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine Region:"
  };
  if (ctx[1] !== void 0) {
    radiobuttons_props.selectedOption = ctx[1];
  }
  radiobuttons = new RadioButtons({
    props: radiobuttons_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(radiobuttons, "selectedOption", radiobuttons_selectedOption_binding_5, ctx[1]));
  let if_block = ctx[1] && create_if_block_1$3(ctx);
  const block = {
    c: function create() {
      create_component(radiobuttons.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(radiobuttons.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-9aSb3n_4tAkN");
      add_location(div, file$a, 111, 4, 2880);
    },
    m: function mount(target, anchor) {
      mount_component(radiobuttons, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const radiobuttons_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        radiobuttons_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      radiobuttons.$set(radiobuttons_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$3(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(radiobuttons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(radiobuttons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(radiobuttons, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$6.name,
    type: "slot",
    source: '(104:2) <Hst.Variant title=\\"Custom accent color\\">',
    ctx
  });
  return block;
}
function create_if_block$7(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$a, 130, 8, 3348);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$7.name,
    type: "if",
    source: "(130:6) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_1$6(ctx) {
  let radiobuttons;
  let updating_selectedOption;
  let t0;
  let div;
  let t1;
  let current;
  function radiobuttons_selectedOption_binding_6(value) {
    ctx[10](value);
  }
  let radiobuttons_props = {
    id: "my-unique-radio-id",
    options: ["Berlin", "Brandenburg", "Stadt", "Land"],
    label: "Wähle eine Region:",
    hideLabelVisually: true
  };
  if (ctx[1] !== void 0) {
    radiobuttons_props.selectedOption = ctx[1];
  }
  radiobuttons = new RadioButtons({
    props: radiobuttons_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(radiobuttons, "selectedOption", radiobuttons_selectedOption_binding_6, ctx[1]));
  let if_block = ctx[1] && create_if_block$7(ctx);
  const block = {
    c: function create() {
      create_component(radiobuttons.$$.fragment);
      t0 = space();
      div = element("div");
      t1 = text("Selected values:\n      ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(radiobuttons.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t1 = claim_text(div_nodes, "Selected values:\n      ");
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "result s-9aSb3n_4tAkN");
      add_location(div, file$a, 127, 4, 3269);
    },
    m: function mount(target, anchor) {
      mount_component(radiobuttons, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const radiobuttons_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        radiobuttons_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      radiobuttons.$set(radiobuttons_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$7(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(radiobuttons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(radiobuttons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(radiobuttons, detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$6.name,
    type: "slot",
    source: '(120:2) <Hst.Variant title=\\"Hide label visually\\">',
    ctx
  });
  return block;
}
function create_default_slot$6(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let t2;
  let hst_variant3;
  let t3;
  let hst_variant4;
  let t4;
  let hst_variant5;
  let t5;
  let hst_variant6;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_9$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Specify initially selected values",
      $$slots: { default: [create_default_slot_8$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Custom option label",
      $$slots: { default: [create_default_slot_6$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant3 = new ctx[0].Variant({
    props: {
      title: "Disabled option",
      $$slots: { default: [create_default_slot_5$5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant4 = new ctx[0].Variant({
    props: {
      title: "Complex options",
      $$slots: { default: [create_default_slot_3$6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant5 = new ctx[0].Variant({
    props: {
      title: "Custom accent color",
      $$slots: { default: [create_default_slot_2$6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant6 = new ctx[0].Variant({
    props: {
      title: "Hide label visually",
      $$slots: { default: [create_default_slot_1$6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
      t2 = space();
      create_component(hst_variant3.$$.fragment);
      t3 = space();
      create_component(hst_variant4.$$.fragment);
      t4 = space();
      create_component(hst_variant5.$$.fragment);
      t5 = space();
      create_component(hst_variant6.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_variant3.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(hst_variant4.$$.fragment, nodes);
      t4 = claim_space(nodes);
      claim_component(hst_variant5.$$.fragment, nodes);
      t5 = claim_space(nodes);
      claim_component(hst_variant6.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_variant3, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(hst_variant4, target, anchor);
      insert_hydration_dev(target, t4, anchor);
      mount_component(hst_variant5, target, anchor);
      insert_hydration_dev(target, t5, anchor);
      mount_component(hst_variant6, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 8194) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 8200) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 8194) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
      const hst_variant3_changes = {};
      if (dirty & 8194) {
        hst_variant3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant3.$set(hst_variant3_changes);
      const hst_variant4_changes = {};
      if (dirty & 8196) {
        hst_variant4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant4.$set(hst_variant4_changes);
      const hst_variant5_changes = {};
      if (dirty & 8194) {
        hst_variant5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant5.$set(hst_variant5_changes);
      const hst_variant6_changes = {};
      if (dirty & 8194) {
        hst_variant6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant6.$set(hst_variant6_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      transition_in(hst_variant3.$$.fragment, local);
      transition_in(hst_variant4.$$.fragment, local);
      transition_in(hst_variant5.$$.fragment, local);
      transition_in(hst_variant6.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      transition_out(hst_variant3.$$.fragment, local);
      transition_out(hst_variant4.$$.fragment, local);
      transition_out(hst_variant5.$$.fragment, local);
      transition_out(hst_variant6.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_variant3, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(hst_variant4, detaching);
      if (detaching)
        detach_dev(t4);
      destroy_component(hst_variant5, detaching);
      if (detaching)
        detach_dev(t5);
      destroy_component(hst_variant6, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$6.name,
    type: "slot",
    source: `(8:0) <Hst.Story   group=\\"ui\\"   title=\\"RadioButtons\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$b(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "ui",
      title: "RadioButtons",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 8206) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$b.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const func$3 = (option) => option === "Berlin";
function instance$b($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioButtons_story", slots, []);
  let { Hst } = $$props;
  let selectedOption;
  let selectedComplexOption;
  let selectedOptionInitiallySet = "Berlin";
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<RadioButtons_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RadioButtons_story> was created with unknown prop '${key}'`);
  });
  function radiobuttons_selectedOption_binding(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  function radiobuttons_selectedOption_binding_1(value) {
    selectedOptionInitiallySet = value;
    $$invalidate(3, selectedOptionInitiallySet);
  }
  function radiobuttons_selectedOption_binding_2(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  function radiobuttons_selectedOption_binding_3(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  function radiobuttons_selectedOption_binding_4(value) {
    selectedComplexOption = value;
    $$invalidate(2, selectedComplexOption);
  }
  function radiobuttons_selectedOption_binding_5(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  function radiobuttons_selectedOption_binding_6(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    RadioButtons,
    selectedOption,
    selectedComplexOption,
    selectedOptionInitiallySet
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("selectedOption" in $$props2)
      $$invalidate(1, selectedOption = $$props2.selectedOption);
    if ("selectedComplexOption" in $$props2)
      $$invalidate(2, selectedComplexOption = $$props2.selectedComplexOption);
    if ("selectedOptionInitiallySet" in $$props2)
      $$invalidate(3, selectedOptionInitiallySet = $$props2.selectedOptionInitiallySet);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    selectedOption,
    selectedComplexOption,
    selectedOptionInitiallySet,
    radiobuttons_selectedOption_binding,
    radiobuttons_selectedOption_binding_1,
    radiobuttons_selectedOption_binding_2,
    radiobuttons_selectedOption_binding_3,
    radiobuttons_selectedOption_binding_4,
    radiobuttons_selectedOption_binding_5,
    radiobuttons_selectedOption_binding_6
  ];
}
class RadioButtons_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$b, create_fragment$b, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioButtons_story",
      options,
      id: create_fragment$b.name
    });
  }
  get Hst() {
    throw new Error("<RadioButtons_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<RadioButtons_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Search_svelte_svelte_type_style_lang = "";
const file$9 = "src/lib/components/shared/Search.svelte";
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  child_ctx[36] = list;
  child_ctx[37] = i;
  const constants_0 = child_ctx[8] === child_ctx[37];
  child_ctx[33] = constants_0;
  const constants_1 = child_ctx[11] === child_ctx[37];
  child_ctx[34] = constants_1;
  const constants_2 = child_ctx[1] === child_ctx[32];
  child_ctx[35] = constants_2;
  return child_ctx;
}
const get_default_slot_changes$3 = (dirty) => ({
  suggestion: dirty[0] & 1024,
  selected: dirty[0] & 1026
});
const get_default_slot_context$3 = (ctx) => ({
  suggestion: ctx[32],
  selected: ctx[35]
});
function create_if_block_2$2(ctx) {
  let label_1;
  let t;
  let label_1_for_value;
  const block = {
    c: function create() {
      label_1 = element("label");
      t = text(ctx[3]);
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_1_nodes = children(label_1);
      t = claim_text(label_1_nodes, ctx[3]);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label_1, "for", label_1_for_value = ctx[2] + "__input");
      attr_dev(label_1, "class", "search__label s-6z69-KQS1lKg");
      toggle_class(label_1, "visually-hidden", ctx[4]);
      add_location(label_1, file$9, 152, 6, 4793);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 8)
        set_data_dev(t, ctx2[3]);
      if (dirty[0] & 4 && label_1_for_value !== (label_1_for_value = ctx2[2] + "__input")) {
        attr_dev(label_1, "for", label_1_for_value);
      }
      if (dirty[0] & 16) {
        toggle_class(label_1, "visually-hidden", ctx2[4]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$2.name,
    type: "if",
    source: "(152:4) {#if label}",
    ctx
  });
  return block;
}
function create_if_block$6(ctx) {
  let ul;
  let ul_id_value;
  let current;
  let each_value = ctx[10];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {
        id: true,
        class: true,
        role: true,
        "aria-orientation": true
      });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "id", ul_id_value = ctx[2] + "__listbox");
      attr_dev(ul, "class", "search__suggestions | shadow-sm s-6z69-KQS1lKg");
      attr_dev(ul, "role", "listbox");
      attr_dev(ul, "aria-orientation", "vertical");
      add_location(ul, file$9, 196, 4, 5890);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1056582) {
        each_value = ctx2[10];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & 4 && ul_id_value !== (ul_id_value = ctx2[2] + "__listbox")) {
        attr_dev(ul, "id", ul_id_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$6.name,
    type: "if",
    source: "(196:2) {#if isOpen}",
    ctx
  });
  return block;
}
function fallback_block$3(ctx) {
  let t_value = ctx[32] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1024 && t_value !== (t_value = ctx2[32] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$3.name,
    type: "fallback",
    source: "(228:40)              ",
    ctx
  });
  return block;
}
function create_if_block_1$2(ctx) {
  let checkicon;
  let current;
  checkicon = new CheckIcon({ $$inline: true });
  const block = {
    c: function create() {
      create_component(checkicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkicon, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$2.name,
    type: "if",
    source: "(231:10) {#if selected}",
    ctx
  });
  return block;
}
function create_each_block$4(ctx) {
  let li;
  let t0;
  let t1;
  let li_id_value;
  let li_aria_selected_value;
  let i = ctx[37];
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[21].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[20], get_default_slot_context$3);
  const default_slot_or_fallback = default_slot || fallback_block$3(ctx);
  let if_block = ctx[35] && create_if_block_1$2(ctx);
  const assign_li = () => ctx[24](li, i);
  const unassign_li = () => ctx[24](null, i);
  function click_handler() {
    return ctx[25](ctx[37]);
  }
  function mouseenter_handler() {
    return ctx[26](ctx[37]);
  }
  function touchstart_handler() {
    return ctx[28](ctx[37]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        id: true,
        class: true,
        role: true,
        "aria-selected": true
      });
      var li_nodes = children(li);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(li_nodes);
      t0 = claim_space(li_nodes);
      if (if_block)
        if_block.l(li_nodes);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "id", li_id_value = ctx[2] + "--option-" + ctx[37]);
      attr_dev(li, "class", "search__suggestion s-6z69-KQS1lKg");
      attr_dev(li, "role", "option");
      attr_dev(li, "aria-selected", li_aria_selected_value = ctx[35]);
      toggle_class(li, "focused", ctx[33]);
      toggle_class(li, "highlighted", ctx[34]);
      toggle_class(li, "selected", ctx[35]);
      add_location(li, file$9, 207, 8, 6333);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(li, null);
      }
      append_hydration_dev(li, t0);
      if (if_block)
        if_block.m(li, null);
      append_hydration_dev(li, t1);
      assign_li();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(li, "click", click_handler, false, false, false),
          listen_dev(li, "mouseenter", mouseenter_handler, false, false, false),
          listen_dev(li, "mouseleave", ctx[27], false, false, false),
          listen_dev(li, "touchstart", touchstart_handler, { passive: true }, false, false),
          listen_dev(li, "touchend", ctx[29], { passive: true }, false, false),
          listen_dev(li, "touchcancel", ctx[30], { passive: true }, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 1049602)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[20],
            !current ? get_all_dirty_from_scope(ctx[20]) : get_slot_changes(default_slot_template, ctx[20], dirty, get_default_slot_changes$3),
            get_default_slot_context$3
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 1024)) {
          default_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
        }
      }
      if (ctx[35]) {
        if (if_block) {
          if (dirty[0] & 1026) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$2(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(li, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 4 && li_id_value !== (li_id_value = ctx[2] + "--option-" + ctx[37])) {
        attr_dev(li, "id", li_id_value);
      }
      if (!current || dirty[0] & 1026 && li_aria_selected_value !== (li_aria_selected_value = ctx[35])) {
        attr_dev(li, "aria-selected", li_aria_selected_value);
      }
      if (i !== ctx[37]) {
        unassign_li();
        i = ctx[37];
        assign_li();
      }
      if (!current || dirty[0] & 256) {
        toggle_class(li, "focused", ctx[33]);
      }
      if (!current || dirty[0] & 2048) {
        toggle_class(li, "highlighted", ctx[34]);
      }
      if (!current || dirty[0] & 1026) {
        toggle_class(li, "selected", ctx[35]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
      unassign_li();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$4.name,
    type: "each",
    source: "(203:6) {#each suggestions as suggestion, i}",
    ctx
  });
  return block;
}
function create_fragment$a(ctx) {
  let div1;
  let form;
  let t0;
  let div0;
  let input;
  let input_id_value;
  let input_aria_controls_value;
  let input_aria_activedescendant_value;
  let t1;
  let button;
  let searchicon;
  let t2;
  let div1_class_value;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[3] && create_if_block_2$2(ctx);
  searchicon = new SearchIcon({
    props: { color: "#ffffff" },
    $$inline: true
  });
  let if_block1 = ctx[0] && create_if_block$6(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      form = element("form");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      input = element("input");
      t1 = space();
      button = element("button");
      create_component(searchicon.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { id: true, class: true, style: true });
      var div1_nodes = children(div1);
      form = claim_element(div1_nodes, "FORM", { class: true });
      var form_nodes = children(form);
      if (if_block0)
        if_block0.l(form_nodes);
      t0 = claim_space(form_nodes);
      div0 = claim_element(form_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", {
        id: true,
        class: true,
        role: true,
        type: true,
        placeholder: true,
        autocomplete: true,
        spellcheck: true,
        autocorrect: true,
        autocapitalize: true,
        enterkeyhint: true,
        "aria-haspopup": true,
        "aria-controls": true,
        "aria-expanded": true,
        "aria-autocomplete": true,
        "aria-activedescendant": true
      });
      t1 = claim_space(div0_nodes);
      button = claim_element(div0_nodes, "BUTTON", {
        type: true,
        class: true,
        "data-slant-position": true,
        "aria-label": true
      });
      var button_nodes = children(button);
      claim_component(searchicon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "id", input_id_value = ctx[2] + "__input");
      attr_dev(input, "class", "search__input | reset s-6z69-KQS1lKg");
      attr_dev(input, "role", "combobox");
      attr_dev(input, "type", "text");
      attr_dev(input, "placeholder", ctx[5]);
      attr_dev(input, "autocomplete", "off");
      attr_dev(input, "spellcheck", "false");
      attr_dev(input, "autocorrect", "off");
      attr_dev(input, "autocapitalize", "off");
      attr_dev(input, "enterkeyhint", "done");
      attr_dev(input, "aria-haspopup", "listbox");
      attr_dev(input, "aria-controls", input_aria_controls_value = ctx[0] ? `${ctx[2]}__listbox` : null);
      attr_dev(input, "aria-expanded", ctx[0]);
      attr_dev(input, "aria-autocomplete", "list");
      attr_dev(input, "aria-activedescendant", input_aria_activedescendant_value = ctx[8] ? `${ctx[2]}--option-${ctx[8]}` : null);
      add_location(input, file$9, 161, 6, 4993);
      attr_dev(button, "type", "submit");
      attr_dev(button, "class", "search__button-submit | slant reset s-6z69-KQS1lKg");
      attr_dev(button, "data-slant-position", "left");
      attr_dev(button, "aria-label", "Bestätigen");
      add_location(button, file$9, 184, 6, 5637);
      attr_dev(div0, "class", "search__field s-6z69-KQS1lKg");
      add_location(div0, file$9, 160, 4, 4959);
      attr_dev(form, "class", "search__form");
      add_location(form, file$9, 146, 2, 4661);
      attr_dev(div1, "id", ctx[2]);
      attr_dev(div1, "class", div1_class_value = null_to_empty(ctx[17].class) + " s-6z69-KQS1lKg");
      attr_dev(div1, "style", div1_style_value = ctx[17].style);
      toggle_class(div1, "search", true);
      add_location(div1, file$9, 140, 0, 4567);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, form);
      if (if_block0)
        if_block0.m(form, null);
      append_hydration_dev(form, t0);
      append_hydration_dev(form, div0);
      append_hydration_dev(div0, input);
      ctx[22](input);
      set_input_value(input, ctx[7]);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div0, button);
      mount_component(searchicon, button, null);
      append_hydration_dev(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "click", ctx[16], false, false, false),
          listen_dev(input, "input", ctx[23]),
          listen_dev(input, "input", ctx[15], false, false, false),
          listen_dev(form, "submit", prevent_default(ctx[13]), false, true, false),
          listen_dev(form, "keydown", ctx[14], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$2(ctx2);
          if_block0.c();
          if_block0.m(form, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty[0] & 4 && input_id_value !== (input_id_value = ctx2[2] + "__input")) {
        attr_dev(input, "id", input_id_value);
      }
      if (!current || dirty[0] & 32) {
        attr_dev(input, "placeholder", ctx2[5]);
      }
      if (!current || dirty[0] & 5 && input_aria_controls_value !== (input_aria_controls_value = ctx2[0] ? `${ctx2[2]}__listbox` : null)) {
        attr_dev(input, "aria-controls", input_aria_controls_value);
      }
      if (!current || dirty[0] & 1) {
        attr_dev(input, "aria-expanded", ctx2[0]);
      }
      if (!current || dirty[0] & 260 && input_aria_activedescendant_value !== (input_aria_activedescendant_value = ctx2[8] ? `${ctx2[2]}--option-${ctx2[8]}` : null)) {
        attr_dev(input, "aria-activedescendant", input_aria_activedescendant_value);
      }
      if (dirty[0] & 128 && input.value !== ctx2[7]) {
        set_input_value(input, ctx2[7]);
      }
      if (ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 4) {
        attr_dev(div1, "id", ctx2[2]);
      }
      if (!current || dirty[0] & 131072 && div1_class_value !== (div1_class_value = null_to_empty(ctx2[17].class) + " s-6z69-KQS1lKg")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & 131072 && div1_style_value !== (div1_style_value = ctx2[17].style)) {
        attr_dev(div1, "style", div1_style_value);
      }
      if (!current || dirty[0] & 131072) {
        toggle_class(div1, "search", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(searchicon.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(searchicon.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block0)
        if_block0.d();
      ctx[22](null);
      destroy_component(searchicon);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$a.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function isPromise(r2) {
  return typeof r2 === "object" && typeof r2.then === "function";
}
function instance$a($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "id",
    "search",
    "label",
    "hideLabelVisually",
    "placeholder",
    "isOpen",
    "selectedSuggestion",
    "formatSuggestion"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Search", slots, ["default"]);
  let { id } = $$props;
  let { search } = $$props;
  let { label } = $$props;
  let { hideLabelVisually = false } = $$props;
  let { placeholder = void 0 } = $$props;
  let { isOpen = false } = $$props;
  let { selectedSuggestion } = $$props;
  let { formatSuggestion = (suggestion) => suggestion } = $$props;
  let inputElement;
  let inputValue;
  let focusedIndex;
  let highlightedIndex;
  let suggestionElements = [];
  let suggestions = [];
  function discardSuggestions() {
    $$invalidate(10, suggestions = []);
    $$invalidate(8, focusedIndex = void 0);
  }
  function submit() {
    if (highlightedIndex === void 0)
      return;
    $$invalidate(1, selectedSuggestion = suggestions[highlightedIndex]);
    $$invalidate(7, inputValue = formatSuggestion(selectedSuggestion));
    tick().then(discardSuggestions);
  }
  function handleSubmit() {
    submit();
  }
  function handleKeyDown(e) {
    if (e.key === "Escape") {
      $$invalidate(1, selectedSuggestion = void 0);
      discardSuggestions();
    }
    if (!["Home", "End", "ArrowUp", "ArrowDown"].includes(e.key))
      return;
    if (suggestions.length === 0)
      return;
    e.preventDefault();
    if (focusedIndex === void 0) {
      if (e.key === "Home" || e.key === "End") {
        $$invalidate(8, focusedIndex = e.key === "Home" ? 0 : suggestions.length - 1);
        return;
      }
      const selectedIndex = suggestions.indexOf(selectedSuggestion);
      if (!selectedSuggestion || selectedIndex < 0) {
        $$invalidate(8, focusedIndex = e.key === "ArrowDown" ? 0 : suggestions.length - 1);
      } else {
        $$invalidate(8, focusedIndex = selectedSuggestion ? selectedIndex : void 0);
      }
    } else {
      const getNextIndex = e.key === "ArrowUp" ? getIndexBefore : getIndexAfter;
      $$invalidate(8, focusedIndex = getNextIndex(focusedIndex, suggestions.length));
    }
  }
  function handleInput() {
    let selectedIndex = suggestions.indexOf(selectedSuggestion);
    if (selectedIndex < 0)
      selectedIndex = void 0;
    $$invalidate(11, highlightedIndex = selectedIndex || focusedIndex || 0);
  }
  function handleClickOutside(e) {
    const node = e.target;
    if (node.closest(`#${id}`) || node.tagName === "LI" && node.getAttribute("role") === "option")
      return;
    $$invalidate(0, isOpen = false);
  }
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Search> was created without expected prop 'id'");
    }
    if (search === void 0 && !("search" in $$props || $$self.$$.bound[$$self.$$.props["search"]])) {
      console.warn("<Search> was created without expected prop 'search'");
    }
    if (label === void 0 && !("label" in $$props || $$self.$$.bound[$$self.$$.props["label"]])) {
      console.warn("<Search> was created without expected prop 'label'");
    }
    if (selectedSuggestion === void 0 && !("selectedSuggestion" in $$props || $$self.$$.bound[$$self.$$.props["selectedSuggestion"]])) {
      console.warn("<Search> was created without expected prop 'selectedSuggestion'");
    }
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(6, inputElement);
    });
  }
  function input_input_handler() {
    inputValue = this.value;
    $$invalidate(7, inputValue);
  }
  function li_binding($$value, i) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      suggestionElements[i] = $$value;
      $$invalidate(9, suggestionElements);
    });
  }
  const click_handler = (i) => {
    $$invalidate(8, focusedIndex = i);
    submit();
    inputElement.focus();
  };
  const mouseenter_handler = (i) => $$invalidate(11, highlightedIndex = i);
  const mouseleave_handler = () => $$invalidate(11, highlightedIndex = void 0);
  const touchstart_handler = (i) => $$invalidate(11, highlightedIndex = i);
  const touchend_handler = () => $$invalidate(11, highlightedIndex = void 0);
  const touchcancel_handler = () => $$invalidate(11, highlightedIndex = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("search" in $$new_props)
      $$invalidate(18, search = $$new_props.search);
    if ("label" in $$new_props)
      $$invalidate(3, label = $$new_props.label);
    if ("hideLabelVisually" in $$new_props)
      $$invalidate(4, hideLabelVisually = $$new_props.hideLabelVisually);
    if ("placeholder" in $$new_props)
      $$invalidate(5, placeholder = $$new_props.placeholder);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("selectedSuggestion" in $$new_props)
      $$invalidate(1, selectedSuggestion = $$new_props.selectedSuggestion);
    if ("formatSuggestion" in $$new_props)
      $$invalidate(19, formatSuggestion = $$new_props.formatSuggestion);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    tick,
    CheckIcon,
    SearchIcon,
    getIndexBefore,
    getIndexAfter,
    id,
    search,
    label,
    hideLabelVisually,
    placeholder,
    isOpen,
    selectedSuggestion,
    formatSuggestion,
    inputElement,
    inputValue,
    focusedIndex,
    highlightedIndex,
    suggestionElements,
    suggestions,
    isPromise,
    discardSuggestions,
    submit,
    handleSubmit,
    handleKeyDown,
    handleInput,
    handleClickOutside
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(2, id = $$new_props.id);
    if ("search" in $$props)
      $$invalidate(18, search = $$new_props.search);
    if ("label" in $$props)
      $$invalidate(3, label = $$new_props.label);
    if ("hideLabelVisually" in $$props)
      $$invalidate(4, hideLabelVisually = $$new_props.hideLabelVisually);
    if ("placeholder" in $$props)
      $$invalidate(5, placeholder = $$new_props.placeholder);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("selectedSuggestion" in $$props)
      $$invalidate(1, selectedSuggestion = $$new_props.selectedSuggestion);
    if ("formatSuggestion" in $$props)
      $$invalidate(19, formatSuggestion = $$new_props.formatSuggestion);
    if ("inputElement" in $$props)
      $$invalidate(6, inputElement = $$new_props.inputElement);
    if ("inputValue" in $$props)
      $$invalidate(7, inputValue = $$new_props.inputValue);
    if ("focusedIndex" in $$props)
      $$invalidate(8, focusedIndex = $$new_props.focusedIndex);
    if ("highlightedIndex" in $$props)
      $$invalidate(11, highlightedIndex = $$new_props.highlightedIndex);
    if ("suggestionElements" in $$props)
      $$invalidate(9, suggestionElements = $$new_props.suggestionElements);
    if ("suggestions" in $$props)
      $$invalidate(10, suggestions = $$new_props.suggestions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 786562) {
      if (!(selectedSuggestion && formatSuggestion(selectedSuggestion) === inputValue)) {
        const result = search(inputValue);
        if (isPromise(result)) {
          result.then((s) => $$invalidate(10, suggestions = s));
        } else {
          $$invalidate(10, suggestions = result);
        }
      }
    }
    if ($$self.$$.dirty[0] & 1024) {
      $$invalidate(0, isOpen = suggestions.length > 0);
    }
    if ($$self.$$.dirty[0] & 1) {
      if (!isOpen)
        $$invalidate(8, focusedIndex = void 0);
    }
    if ($$self.$$.dirty[0] & 128) {
      if (!inputValue)
        discardSuggestions();
    }
    if ($$self.$$.dirty[0] & 256) {
      $$invalidate(11, highlightedIndex = focusedIndex);
    }
    if ($$self.$$.dirty[0] & 832) {
      if (focusedIndex !== void 0 && suggestionElements[focusedIndex]) {
        const element2 = suggestionElements[focusedIndex];
        element2.tabIndex = 0;
        suggestionElements[focusedIndex].focus();
        inputElement.focus();
        element2.tabIndex = -1;
      }
    }
  };
  return [
    isOpen,
    selectedSuggestion,
    id,
    label,
    hideLabelVisually,
    placeholder,
    inputElement,
    inputValue,
    focusedIndex,
    suggestionElements,
    suggestions,
    highlightedIndex,
    submit,
    handleSubmit,
    handleKeyDown,
    handleInput,
    handleClickOutside,
    $$restProps,
    search,
    formatSuggestion,
    $$scope,
    slots,
    input_binding,
    input_input_handler,
    li_binding,
    click_handler,
    mouseenter_handler,
    mouseleave_handler,
    touchstart_handler,
    touchend_handler,
    touchcancel_handler
  ];
}
class Search extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance$a,
      create_fragment$a,
      safe_not_equal,
      {
        id: 2,
        search: 18,
        label: 3,
        hideLabelVisually: 4,
        placeholder: 5,
        isOpen: 0,
        selectedSuggestion: 1,
        formatSuggestion: 19
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Search",
      options,
      id: create_fragment$a.name
    });
  }
  get id() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get search() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set search(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabelVisually() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabelVisually(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedSuggestion() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedSuggestion(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatSuggestion() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatSuggestion(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Search_story_svelte_svelte_type_style_lang = "";
const file$8 = "src/lib/components/shared/Search.story.svelte";
function create_if_block_5(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$8, 88, 10, 2163);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(88:8) {#if selectedSuggestion}",
    ctx
  });
  return block;
}
function create_default_slot_8$2(ctx) {
  let div1;
  let search;
  let updating_selectedSuggestion;
  let t0;
  let div0;
  let t1;
  let current;
  function search_selectedSuggestion_binding(value) {
    ctx[8](value);
  }
  let search_props = {
    id: "my-unique-search-id",
    search: ctx[5],
    label: "Suche nach Namen (mit A)",
    placeholder: "z.B. Anna"
  };
  if (ctx[1] !== void 0) {
    search_props.selectedSuggestion = ctx[1];
  }
  search = new Search({ props: search_props, $$inline: true });
  binding_callbacks.push(() => bind(search, "selectedSuggestion", search_selectedSuggestion_binding, ctx[1]));
  let if_block = ctx[1] && create_if_block_5(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(search.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(search.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-DuHwGkmG9OZn");
      add_location(div0, file$8, 85, 6, 2075);
      attr_dev(div1, "class", "wrapper s-DuHwGkmG9OZn");
      add_location(div1, file$8, 77, 4, 1856);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(search, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const search_changes = {};
      if (!updating_selectedSuggestion && dirty & 2) {
        updating_selectedSuggestion = true;
        search_changes.selectedSuggestion = ctx2[1];
        add_flush_callback(() => updating_selectedSuggestion = false);
      }
      search.$set(search_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(search.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(search.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(search);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8$2.name,
    type: "slot",
    source: '(77:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_7$2(ctx) {
  let t_value = ctx[18].name + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 262144 && t_value !== (t_value = ctx2[18].name + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7$2.name,
    type: "slot",
    source: '(97:6) <Search         id=\\"my-unique-search-id\\"         search={simpleSearchWithComplexOptions}         label=\\"Suche nach Namen (mit A)\\"         placeholder=\\"z.B. Anna\\"         formatSuggestion={(s) => s.name}         bind:selectedSuggestion={selectedComplexSuggestion}         let:suggestion       >',
    ctx
  });
  return block;
}
function create_if_block_4$1(ctx) {
  let t_value = JSON.stringify(ctx[1], null, 2) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = JSON.stringify(ctx2[1], null, 2) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4$1.name,
    type: "if",
    source: "(110:8) {#if selectedSuggestion}",
    ctx
  });
  return block;
}
function create_default_slot_6$3(ctx) {
  let div1;
  let search;
  let updating_selectedSuggestion;
  let t0;
  let div0;
  let t1;
  let current;
  function search_selectedSuggestion_binding_1(value) {
    ctx[9](value);
  }
  let search_props = {
    id: "my-unique-search-id",
    search: ctx[6],
    label: "Suche nach Namen (mit A)",
    placeholder: "z.B. Anna",
    formatSuggestion: func$2,
    $$slots: {
      default: [
        create_default_slot_7$2,
        ({ suggestion }) => ({ 18: suggestion }),
        ({ suggestion }) => suggestion ? 262144 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[2] !== void 0) {
    search_props.selectedSuggestion = ctx[2];
  }
  search = new Search({ props: search_props, $$inline: true });
  binding_callbacks.push(() => bind(search, "selectedSuggestion", search_selectedSuggestion_binding_1, ctx[2]));
  let if_block = ctx[1] && create_if_block_4$1(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(search.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(search.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-DuHwGkmG9OZn");
      add_location(div0, file$8, 107, 6, 2661);
      attr_dev(div1, "class", "wrapper s-DuHwGkmG9OZn");
      add_location(div1, file$8, 95, 4, 2291);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(search, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const search_changes = {};
      if (dirty & 786432) {
        search_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedSuggestion && dirty & 4) {
        updating_selectedSuggestion = true;
        search_changes.selectedSuggestion = ctx2[2];
        add_flush_callback(() => updating_selectedSuggestion = false);
      }
      search.$set(search_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$1(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(search.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(search.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(search);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$3.name,
    type: "slot",
    source: '(95:2) <Hst.Variant title=\\"Complex options\\">',
    ctx
  });
  return block;
}
function create_if_block_3$1(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$8, 128, 10, 3228);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3$1.name,
    type: "if",
    source: "(128:8) {#if selectedSuggestion}",
    ctx
  });
  return block;
}
function create_default_slot_5$4(ctx) {
  let div1;
  let search;
  let updating_selectedSuggestion;
  let t0;
  let div0;
  let t1;
  let current;
  function search_selectedSuggestion_binding_2(value) {
    ctx[11](value);
  }
  let search_props = {
    id: "my-unique-search-id",
    search: ctx[10],
    label: "Suche nach Namen (mit A)",
    placeholder: "z.B. Anna"
  };
  if (ctx[1] !== void 0) {
    search_props.selectedSuggestion = ctx[1];
  }
  search = new Search({ props: search_props, $$inline: true });
  binding_callbacks.push(() => bind(search, "selectedSuggestion", search_selectedSuggestion_binding_2, ctx[1]));
  let if_block = ctx[1] && create_if_block_3$1(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(search.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(search.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-DuHwGkmG9OZn");
      add_location(div0, file$8, 125, 6, 3140);
      attr_dev(div1, "class", "wrapper s-DuHwGkmG9OZn");
      add_location(div1, file$8, 117, 4, 2895);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(search, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const search_changes = {};
      if (!updating_selectedSuggestion && dirty & 2) {
        updating_selectedSuggestion = true;
        search_changes.selectedSuggestion = ctx2[1];
        add_flush_callback(() => updating_selectedSuggestion = false);
      }
      search.$set(search_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$1(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(search.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(search.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(search);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$4.name,
    type: "slot",
    source: '(117:2) <Hst.Variant title=\\"Fuzzy searching\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$4(ctx) {
  let t_value = ctx[18].name + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 262144 && t_value !== (t_value = ctx2[18].name + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$4.name,
    type: "slot",
    source: `(137:6) <Search         id=\\"my-unique-search-id\\"         search={(query) => fuzzysearch(query, complexOptions, { key: 'name' })}         label=\\"Suche nach Namen (mit A)\\"         placeholder=\\"z.B. Anna\\"         formatSuggestion={(s) => s.name}         bind:selectedSuggestion={selectedComplexSuggestion}         let:suggestion       >`,
    ctx
  });
  return block;
}
function create_if_block_2$1(ctx) {
  let t_value = JSON.stringify(ctx[1], null, 2) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = JSON.stringify(ctx2[1], null, 2) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$1.name,
    type: "if",
    source: "(150:8) {#if selectedSuggestion}",
    ctx
  });
  return block;
}
function create_default_slot_3$5(ctx) {
  let div1;
  let search;
  let updating_selectedSuggestion;
  let t0;
  let div0;
  let t1;
  let current;
  function search_selectedSuggestion_binding_3(value) {
    ctx[13](value);
  }
  let search_props = {
    id: "my-unique-search-id",
    search: ctx[12],
    label: "Suche nach Namen (mit A)",
    placeholder: "z.B. Anna",
    formatSuggestion: func_3,
    $$slots: {
      default: [
        create_default_slot_4$4,
        ({ suggestion }) => ({ 18: suggestion }),
        ({ suggestion }) => suggestion ? 262144 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[2] !== void 0) {
    search_props.selectedSuggestion = ctx[2];
  }
  search = new Search({ props: search_props, $$inline: true });
  binding_callbacks.push(() => bind(search, "selectedSuggestion", search_selectedSuggestion_binding_3, ctx[2]));
  let if_block = ctx[1] && create_if_block_2$1(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(search.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(search.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-DuHwGkmG9OZn");
      add_location(div0, file$8, 147, 6, 3774);
      attr_dev(div1, "class", "wrapper s-DuHwGkmG9OZn");
      add_location(div1, file$8, 135, 4, 3372);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(search, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const search_changes = {};
      if (dirty & 786432) {
        search_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedSuggestion && dirty & 4) {
        updating_selectedSuggestion = true;
        search_changes.selectedSuggestion = ctx2[2];
        add_flush_callback(() => updating_selectedSuggestion = false);
      }
      search.$set(search_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$1(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(search.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(search.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(search);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$5.name,
    type: "slot",
    source: '(135:2) <Hst.Variant title=\\"Fuzzy searching complex options\\">',
    ctx
  });
  return block;
}
function create_if_block_1$1(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$8, 170, 10, 4374);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$1.name,
    type: "if",
    source: "(170:8) {#if selectedSuggestion}",
    ctx
  });
  return block;
}
function create_default_slot_2$5(ctx) {
  let div1;
  let search;
  let updating_selectedSuggestion;
  let t0;
  let div0;
  let t1;
  let current;
  function search_selectedSuggestion_binding_4(value) {
    ctx[15](value);
  }
  let search_props = {
    id: "my-unique-search-id",
    search: ctx[14],
    label: "Suche nach Namen",
    placeholder: "z.B. Anna"
  };
  if (ctx[1] !== void 0) {
    search_props.selectedSuggestion = ctx[1];
  }
  search = new Search({ props: search_props, $$inline: true });
  binding_callbacks.push(() => bind(search, "selectedSuggestion", search_selectedSuggestion_binding_4, ctx[1]));
  let if_block = ctx[1] && create_if_block_1$1(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(search.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(search.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-DuHwGkmG9OZn");
      add_location(div0, file$8, 167, 6, 4286);
      attr_dev(div1, "class", "wrapper s-DuHwGkmG9OZn");
      add_location(div1, file$8, 157, 4, 4006);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(search, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const search_changes = {};
      if (!updating_selectedSuggestion && dirty & 2) {
        updating_selectedSuggestion = true;
        search_changes.selectedSuggestion = ctx2[1];
        add_flush_callback(() => updating_selectedSuggestion = false);
      }
      search.$set(search_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(search.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(search.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(search);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$5.name,
    type: "slot",
    source: '(157:2) <Hst.Variant title=\\"Async loading\\">',
    ctx
  });
  return block;
}
function create_if_block$5(ctx) {
  let t_value = JSON.stringify(ctx[1], null, 2) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = JSON.stringify(ctx2[1], null, 2) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$5.name,
    type: "if",
    source: "(189:8) {#if selectedSuggestion}",
    ctx
  });
  return block;
}
function create_default_slot_1$5(ctx) {
  let div1;
  let search;
  let updating_selectedSuggestion;
  let t0;
  let div0;
  let t1;
  let current;
  function search_selectedSuggestion_binding_5(value) {
    ctx[16](value);
  }
  let search_props = {
    id: "my-unique-search-id",
    search: ctx[5],
    label: "Suche nach Namen (mit A)",
    placeholder: "Suche nach Namen (mit A)",
    hideLabelVisually: true
  };
  if (ctx[1] !== void 0) {
    search_props.selectedSuggestion = ctx[1];
  }
  search = new Search({ props: search_props, $$inline: true });
  binding_callbacks.push(() => bind(search, "selectedSuggestion", search_selectedSuggestion_binding_5, ctx[1]));
  let if_block = ctx[1] && create_if_block$5(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(search.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(search.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-DuHwGkmG9OZn");
      add_location(div0, file$8, 186, 6, 4766);
      attr_dev(div1, "class", "wrapper s-DuHwGkmG9OZn");
      add_location(div1, file$8, 177, 4, 4506);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(search, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const search_changes = {};
      if (!updating_selectedSuggestion && dirty & 2) {
        updating_selectedSuggestion = true;
        search_changes.selectedSuggestion = ctx2[1];
        add_flush_callback(() => updating_selectedSuggestion = false);
      }
      search.$set(search_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$5(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(search.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(search.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(search);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$5.name,
    type: "slot",
    source: '(177:2) <Hst.Variant title=\\"Hide label visually\\">',
    ctx
  });
  return block;
}
function create_default_slot$5(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let t2;
  let hst_variant3;
  let t3;
  let hst_variant4;
  let t4;
  let hst_variant5;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_8$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Complex options",
      $$slots: { default: [create_default_slot_6$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Fuzzy searching",
      $$slots: { default: [create_default_slot_5$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant3 = new ctx[0].Variant({
    props: {
      title: "Fuzzy searching complex options",
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant4 = new ctx[0].Variant({
    props: {
      title: "Async loading",
      $$slots: { default: [create_default_slot_2$5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant5 = new ctx[0].Variant({
    props: {
      title: "Hide label visually",
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
      t2 = space();
      create_component(hst_variant3.$$.fragment);
      t3 = space();
      create_component(hst_variant4.$$.fragment);
      t4 = space();
      create_component(hst_variant5.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_variant3.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(hst_variant4.$$.fragment, nodes);
      t4 = claim_space(nodes);
      claim_component(hst_variant5.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_variant3, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(hst_variant4, target, anchor);
      insert_hydration_dev(target, t4, anchor);
      mount_component(hst_variant5, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 524290) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 524294) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 524290) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
      const hst_variant3_changes = {};
      if (dirty & 524294) {
        hst_variant3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant3.$set(hst_variant3_changes);
      const hst_variant4_changes = {};
      if (dirty & 524290) {
        hst_variant4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant4.$set(hst_variant4_changes);
      const hst_variant5_changes = {};
      if (dirty & 524290) {
        hst_variant5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant5.$set(hst_variant5_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      transition_in(hst_variant3.$$.fragment, local);
      transition_in(hst_variant4.$$.fragment, local);
      transition_in(hst_variant5.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      transition_out(hst_variant3.$$.fragment, local);
      transition_out(hst_variant4.$$.fragment, local);
      transition_out(hst_variant5.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_variant3, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(hst_variant4, detaching);
      if (detaching)
        detach_dev(t4);
      destroy_component(hst_variant5, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$5.name,
    type: "slot",
    source: `(76:0) <Hst.Story group=\\"ui\\" title=\\"Search\\" layout={{ type: 'grid', width: '100%' }}>`,
    ctx
  });
  return block;
}
function create_fragment$9(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "ui",
      title: "Search",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 524294) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const func$2 = (s) => s.name;
const func_3 = (s) => s.name;
function instance$9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Search_story", slots, []);
  let { Hst } = $$props;
  const options = ["Amber", "Anna", "Anton", "Anja", "Arnold", "Archie", "Ashton"];
  const complexOptions = [
    { name: "Amber", value: "amber" },
    { name: "Anna", value: "anna" },
    { name: "Anton", value: "anton" },
    { name: "Anja", value: "anja" },
    { name: "Arnold", value: "arnold" },
    { name: "Archie", value: "archie" },
    { name: "Ashton", value: "ashton" }
  ];
  let selectedSuggestion;
  let selectedComplexSuggestion;
  const simpleSearch = (query) => {
    if (!query)
      return [];
    return options.filter((o) => o.toLowerCase().startsWith(query.toLowerCase()));
  };
  const simpleSearchWithComplexOptions = (query) => {
    if (!query)
      return [];
    return complexOptions.filter((o) => o.name.toLowerCase().startsWith(query.toLowerCase()));
  };
  async function autocomplete(query, limit = 5) {
    const params = new URLSearchParams({ name: query, limit: limit.toString() });
    const url = `https://datasette-rtt5dktola-ey.a.run.app/berlin_first_names/autocomplete_regardless_of_gender.csv?${params}`;
    const res = await fetch(url, { method: "GET" });
    const text2 = await res.text();
    const response = csvParse(text2);
    return response.map(({ name }) => name);
  }
  const debouncedAutocomplete = lodash_debounce((query) => autocomplete(query), 300, { leading: true, trailing: true });
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Search_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Search_story> was created with unknown prop '${key}'`);
  });
  function search_selectedSuggestion_binding(value) {
    selectedSuggestion = value;
    $$invalidate(1, selectedSuggestion);
  }
  function search_selectedSuggestion_binding_1(value) {
    selectedComplexSuggestion = value;
    $$invalidate(2, selectedComplexSuggestion);
  }
  const func_12 = (query) => fuzzysearch(query, options);
  function search_selectedSuggestion_binding_2(value) {
    selectedSuggestion = value;
    $$invalidate(1, selectedSuggestion);
  }
  const func_22 = (query) => fuzzysearch(query, complexOptions, { key: "name" });
  function search_selectedSuggestion_binding_3(value) {
    selectedComplexSuggestion = value;
    $$invalidate(2, selectedComplexSuggestion);
  }
  const func_4 = async (query) => {
    return await debouncedAutocomplete(query);
  };
  function search_selectedSuggestion_binding_4(value) {
    selectedSuggestion = value;
    $$invalidate(1, selectedSuggestion);
  }
  function search_selectedSuggestion_binding_5(value) {
    selectedSuggestion = value;
    $$invalidate(1, selectedSuggestion);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    csvParse,
    debounce: lodash_debounce,
    Search,
    fuzzysearch,
    options,
    complexOptions,
    selectedSuggestion,
    selectedComplexSuggestion,
    simpleSearch,
    simpleSearchWithComplexOptions,
    autocomplete,
    debouncedAutocomplete
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("selectedSuggestion" in $$props2)
      $$invalidate(1, selectedSuggestion = $$props2.selectedSuggestion);
    if ("selectedComplexSuggestion" in $$props2)
      $$invalidate(2, selectedComplexSuggestion = $$props2.selectedComplexSuggestion);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    selectedSuggestion,
    selectedComplexSuggestion,
    options,
    complexOptions,
    simpleSearch,
    simpleSearchWithComplexOptions,
    debouncedAutocomplete,
    search_selectedSuggestion_binding,
    search_selectedSuggestion_binding_1,
    func_12,
    search_selectedSuggestion_binding_2,
    func_22,
    search_selectedSuggestion_binding_3,
    func_4,
    search_selectedSuggestion_binding_4,
    search_selectedSuggestion_binding_5
  ];
}
class Search_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$9, create_fragment$9, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Search_story",
      options,
      id: create_fragment$9.name
    });
  }
  get Hst() {
    throw new Error("<Search_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Search_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Select_svelte_svelte_type_style_lang = "";
const file$7 = "src/lib/components/shared/Select.svelte";
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  const constants_0 = child_ctx[9] === child_ctx[0];
  child_ctx[10] = constants_0;
  return child_ctx;
}
const get_default_slot_changes$2 = (dirty) => ({
  option: dirty & 8,
  selected: dirty & 9
});
const get_default_slot_context$2 = (ctx) => ({
  option: ctx[9],
  selected: ctx[10]
});
function fallback_block$2(ctx) {
  let t_value = ctx[9] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[9] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$2.name,
    type: "fallback",
    source: "(42:36)              ",
    ctx
  });
  return block;
}
function create_each_block$3(ctx) {
  let option;
  let t;
  let option_value_value;
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], get_default_slot_context$2);
  const default_slot_or_fallback = default_slot || fallback_block$2(ctx);
  const block = {
    c: function create() {
      option = element("option");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(option_nodes);
      t = claim_space(option_nodes);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = ctx[9];
      option.value = option.__value;
      toggle_class(option, "selected", ctx[10]);
      add_location(option, file$7, 40, 8, 1062);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(option, null);
      }
      append_hydration_dev(option, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 73)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, get_default_slot_changes$2),
            get_default_slot_context$2
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 8)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 8 && option_value_value !== (option_value_value = ctx2[9])) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
      if (!current || dirty & 9) {
        toggle_class(option, "selected", ctx2[10]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$3.name,
    type: "each",
    source: "(39:6) {#each options as option}",
    ctx
  });
  return block;
}
function create_fragment$8(ctx) {
  let div1;
  let label_1;
  let t0;
  let t1;
  let div0;
  let select;
  let t2;
  let dropdownicon;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[3];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let select_levels = [{ id: ctx[1] }, ctx[5]];
  let select_data = {};
  for (let i = 0; i < select_levels.length; i += 1) {
    select_data = assign(select_data, select_levels[i]);
  }
  dropdownicon = new DropdownIcon({ $$inline: true });
  const block = {
    c: function create() {
      div1 = element("div");
      label_1 = element("label");
      t0 = text(ctx[2]);
      t1 = space();
      div0 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      create_component(dropdownicon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      label_1 = claim_element(div1_nodes, "LABEL", { for: true, class: true });
      var label_1_nodes = children(label_1);
      t0 = claim_text(label_1_nodes, ctx[2]);
      label_1_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      select = claim_element(div0_nodes, "SELECT", { id: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      t2 = claim_space(div0_nodes);
      claim_component(dropdownicon.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label_1, "for", ctx[1]);
      attr_dev(label_1, "class", "select__label s-hNFWdVcujiPn");
      toggle_class(label_1, "visually-hidden", ctx[4]);
      add_location(label_1, file$7, 23, 2, 673);
      set_attributes(select, select_data);
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[8].call(select));
      toggle_class(select, "select__field", true);
      toggle_class(select, "reset", true);
      toggle_class(select, "s-hNFWdVcujiPn", true);
      add_location(select, file$7, 31, 4, 828);
      attr_dev(div0, "class", "select__wrapper s-hNFWdVcujiPn");
      add_location(div0, file$7, 30, 2, 794);
      attr_dev(div1, "class", "select s-hNFWdVcujiPn");
      add_location(div1, file$7, 22, 0, 650);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, label_1);
      append_hydration_dev(label_1, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (select.autofocus)
        select.focus();
      select_option(select, ctx[0]);
      append_hydration_dev(div0, t2);
      mount_component(dropdownicon, div0, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(select, "change", ctx[8]);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 4)
        set_data_dev(t0, ctx2[2]);
      if (!current || dirty & 2) {
        attr_dev(label_1, "for", ctx2[1]);
      }
      if (!current || dirty & 16) {
        toggle_class(label_1, "visually-hidden", ctx2[4]);
      }
      if (dirty & 73) {
        each_value = ctx2[3];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(select, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      set_attributes(select, select_data = get_spread_update(select_levels, [
        (!current || dirty & 2) && { id: ctx2[1] },
        dirty & 32 && ctx2[5]
      ]));
      if (dirty & 34 && "value" in select_data)
        (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (dirty & 9) {
        select_option(select, ctx2[0]);
      }
      toggle_class(select, "select__field", true);
      toggle_class(select, "reset", true);
      toggle_class(select, "s-hNFWdVcujiPn", true);
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(dropdownicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(dropdownicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_each(each_blocks, detaching);
      destroy_component(dropdownicon);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$8($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "label", "options", "selectedOption", "hideLabelVisually"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, ["default"]);
  let { id } = $$props;
  let { label = void 0 } = $$props;
  let { options } = $$props;
  let { selectedOption = void 0 } = $$props;
  let { hideLabelVisually = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Select> was created without expected prop 'id'");
    }
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<Select> was created without expected prop 'options'");
    }
  });
  function select_change_handler() {
    selectedOption = select_value(this);
    $$invalidate(0, selectedOption);
    $$invalidate(3, options);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(1, id = $$new_props.id);
    if ("label" in $$new_props)
      $$invalidate(2, label = $$new_props.label);
    if ("options" in $$new_props)
      $$invalidate(3, options = $$new_props.options);
    if ("selectedOption" in $$new_props)
      $$invalidate(0, selectedOption = $$new_props.selectedOption);
    if ("hideLabelVisually" in $$new_props)
      $$invalidate(4, hideLabelVisually = $$new_props.hideLabelVisually);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    DropdownIcon,
    id,
    label,
    options,
    selectedOption,
    hideLabelVisually
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(1, id = $$new_props.id);
    if ("label" in $$props)
      $$invalidate(2, label = $$new_props.label);
    if ("options" in $$props)
      $$invalidate(3, options = $$new_props.options);
    if ("selectedOption" in $$props)
      $$invalidate(0, selectedOption = $$new_props.selectedOption);
    if ("hideLabelVisually" in $$props)
      $$invalidate(4, hideLabelVisually = $$new_props.hideLabelVisually);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    selectedOption,
    id,
    label,
    options,
    hideLabelVisually,
    $$restProps,
    $$scope,
    slots,
    select_change_handler
  ];
}
class Select extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$8, create_fragment$8, safe_not_equal, {
      id: 1,
      label: 2,
      options: 3,
      selectedOption: 0,
      hideLabelVisually: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment$8.name
    });
  }
  get id() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedOption() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedOption(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideLabelVisually() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideLabelVisually(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Select_story_svelte_svelte_type_style_lang = "";
const file$6 = "src/lib/components/shared/Select.story.svelte";
function create_if_block_4(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$6, 19, 10, 581);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(19:8) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_6$2(ctx) {
  let div1;
  let select;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function select_selectedOption_binding(value) {
    ctx[4](value);
  }
  let select_props = {
    id: "my-unique-select-id",
    label: "Wähle eine Jahreszeit",
    options: ["Frühling", "Sommer", "Herbst", "Winter"]
  };
  if (ctx[1] !== void 0) {
    select_props.selectedOption = ctx[1];
  }
  select = new Select({ props: select_props, $$inline: true });
  binding_callbacks.push(() => bind(select, "selectedOption", select_selectedOption_binding, ctx[1]));
  let if_block = ctx[1] && create_if_block_4(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(select.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(select.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-tSNKq4koiSFo");
      add_location(div0, file$6, 16, 6, 497);
      attr_dev(div1, "class", "wrapper s-tSNKq4koiSFo");
      add_location(div1, file$6, 9, 4, 286);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(select, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const select_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        select_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      select.$set(select_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(select);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$2.name,
    type: "slot",
    source: '(9:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[3]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[3]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$6, 36, 10, 1058);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(36:8) {#if selectedOptionInitiallySet}",
    ctx
  });
  return block;
}
function create_default_slot_5$3(ctx) {
  let div1;
  let select;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function select_selectedOption_binding_1(value) {
    ctx[5](value);
  }
  let select_props = {
    id: "my-unique-select-id",
    label: "Wähle eine Jahreszeit",
    options: ["Frühling", "Sommer", "Herbst", "Winter"]
  };
  if (ctx[3] !== void 0) {
    select_props.selectedOption = ctx[3];
  }
  select = new Select({ props: select_props, $$inline: true });
  binding_callbacks.push(() => bind(select, "selectedOption", select_selectedOption_binding_1, ctx[3]));
  let if_block = ctx[3] && create_if_block_3(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(select.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(select.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-tSNKq4koiSFo");
      add_location(div0, file$6, 33, 6, 962);
      attr_dev(div1, "class", "wrapper s-tSNKq4koiSFo");
      add_location(div1, file$6, 26, 4, 722);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(select, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const select_changes = {};
      if (!updating_selectedOption && dirty & 8) {
        updating_selectedOption = true;
        select_changes.selectedOption = ctx2[3];
        add_flush_callback(() => updating_selectedOption = false);
      }
      select.$set(select_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(select);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$3.name,
    type: "slot",
    source: '(26:2) <Hst.Variant title=\\"Specify initially selected value\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$3(ctx) {
  let t_value = ctx[9].label + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 512 && t_value !== (t_value = ctx2[9].label + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$3.name,
    type: "slot",
    source: `(45:6) <Select         id=\\"my-unique-select-id\\"         label=\\"Wähle eine Jahreszeit\\"         options={[           { label: 'Frühling', value: 'spring' },           { label: 'Sommer', value: 'summer' },           { label: 'Herbst', value: 'autumn' },           { label: 'Winter', value: 'winter' },         ]}         bind:selectedOption={selectedComplexOption}         let:option       >`,
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let t_value = JSON.stringify(ctx[2], null, 2) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = JSON.stringify(ctx2[2], null, 2) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(61:8) {#if selectedComplexOption}",
    ctx
  });
  return block;
}
function create_default_slot_3$4(ctx) {
  let div1;
  let select;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function select_selectedOption_binding_2(value) {
    ctx[6](value);
  }
  let select_props = {
    id: "my-unique-select-id",
    label: "Wähle eine Jahreszeit",
    options: [
      { label: "Frühling", value: "spring" },
      { label: "Sommer", value: "summer" },
      { label: "Herbst", value: "autumn" },
      { label: "Winter", value: "winter" }
    ],
    $$slots: {
      default: [
        create_default_slot_4$3,
        ({ option }) => ({ 9: option }),
        ({ option }) => option ? 512 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[2] !== void 0) {
    select_props.selectedOption = ctx[2];
  }
  select = new Select({ props: select_props, $$inline: true });
  binding_callbacks.push(() => bind(select, "selectedOption", select_selectedOption_binding_2, ctx[2]));
  let if_block = ctx[2] && create_if_block_2(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(select.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(select.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-tSNKq4koiSFo");
      add_location(div0, file$6, 58, 6, 1649);
      attr_dev(div1, "class", "wrapper s-tSNKq4koiSFo");
      add_location(div1, file$6, 43, 4, 1194);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(select, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const select_changes = {};
      if (dirty & 1536) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedOption && dirty & 4) {
        updating_selectedOption = true;
        select_changes.selectedOption = ctx2[2];
        add_flush_callback(() => updating_selectedOption = false);
      }
      select.$set(select_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(select);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$4.name,
    type: "slot",
    source: '(43:2) <Hst.Variant title=\\"Complex options\\">',
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$6, 79, 10, 2194);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(79:8) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_2$4(ctx) {
  let div1;
  let select;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function select_selectedOption_binding_3(value) {
    ctx[7](value);
  }
  let select_props = {
    id: "my-unique-select-id",
    label: "Wähle eine Jahreszeit",
    options: ["Frühling", "Sommer", "Herbst", "Winter"],
    disabled: true
  };
  if (ctx[1] !== void 0) {
    select_props.selectedOption = ctx[1];
  }
  select = new Select({ props: select_props, $$inline: true });
  binding_callbacks.push(() => bind(select, "selectedOption", select_selectedOption_binding_3, ctx[1]));
  let if_block = ctx[1] && create_if_block_1(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(select.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(select.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-tSNKq4koiSFo");
      add_location(div0, file$6, 76, 6, 2110);
      attr_dev(div1, "class", "wrapper s-tSNKq4koiSFo");
      add_location(div1, file$6, 68, 4, 1882);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(select, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const select_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        select_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      select.$set(select_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(select);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$4.name,
    type: "slot",
    source: '(68:2) <Hst.Variant title=\\"Disabled\\">',
    ctx
  });
  return block;
}
function create_if_block$4(ctx) {
  let i;
  let t;
  const block = {
    c: function create() {
      i = element("i");
      t = text(ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", {});
      var i_nodes = children(i);
      t = claim_text(i_nodes, ctx[1]);
      i_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(i, file$6, 97, 10, 2643);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
      append_hydration_dev(i, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$4.name,
    type: "if",
    source: "(97:8) {#if selectedOption}",
    ctx
  });
  return block;
}
function create_default_slot_1$4(ctx) {
  let div1;
  let select;
  let updating_selectedOption;
  let t0;
  let div0;
  let t1;
  let current;
  function select_selectedOption_binding_4(value) {
    ctx[8](value);
  }
  let select_props = {
    id: "my-unique-select-id",
    label: "Wähle eine Jahreszeit",
    hideLabelVisually: true,
    options: ["Frühling", "Sommer", "Herbst", "Winter"]
  };
  if (ctx[1] !== void 0) {
    select_props.selectedOption = ctx[1];
  }
  select = new Select({ props: select_props, $$inline: true });
  binding_callbacks.push(() => bind(select, "selectedOption", select_selectedOption_binding_4, ctx[1]));
  let if_block = ctx[1] && create_if_block$4(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(select.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text("Selected value:\n        ");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(select.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, "Selected value:\n        ");
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "result s-tSNKq4koiSFo");
      add_location(div0, file$6, 94, 6, 2559);
      attr_dev(div1, "class", "wrapper s-tSNKq4koiSFo");
      add_location(div1, file$6, 86, 4, 2322);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(select, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const select_changes = {};
      if (!updating_selectedOption && dirty & 2) {
        updating_selectedOption = true;
        select_changes.selectedOption = ctx2[1];
        add_flush_callback(() => updating_selectedOption = false);
      }
      select.$set(select_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(select);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$4.name,
    type: "slot",
    source: '(86:2) <Hst.Variant title=\\"Hide label visually\\">',
    ctx
  });
  return block;
}
function create_default_slot$4(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let t2;
  let hst_variant3;
  let t3;
  let hst_variant4;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_6$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Specify initially selected value",
      $$slots: { default: [create_default_slot_5$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Complex options",
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant3 = new ctx[0].Variant({
    props: {
      title: "Disabled",
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant4 = new ctx[0].Variant({
    props: {
      title: "Hide label visually",
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
      t2 = space();
      create_component(hst_variant3.$$.fragment);
      t3 = space();
      create_component(hst_variant4.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_variant3.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(hst_variant4.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_variant3, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(hst_variant4, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 1026) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 1032) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 1028) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
      const hst_variant3_changes = {};
      if (dirty & 1026) {
        hst_variant3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant3.$set(hst_variant3_changes);
      const hst_variant4_changes = {};
      if (dirty & 1026) {
        hst_variant4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant4.$set(hst_variant4_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      transition_in(hst_variant3.$$.fragment, local);
      transition_in(hst_variant4.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      transition_out(hst_variant3.$$.fragment, local);
      transition_out(hst_variant4.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_variant3, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(hst_variant4, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$4.name,
    type: "slot",
    source: `(8:0) <Hst.Story group=\\"ui\\" title=\\"Select\\" layout={{ type: 'grid', width: '100%' }}>`,
    ctx
  });
  return block;
}
function create_fragment$7(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "ui",
      title: "Select",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 1038) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select_story", slots, []);
  let { Hst } = $$props;
  let selectedOption;
  let selectedComplexOption;
  let selectedOptionInitiallySet = "Sommer";
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Select_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Select_story> was created with unknown prop '${key}'`);
  });
  function select_selectedOption_binding(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  function select_selectedOption_binding_1(value) {
    selectedOptionInitiallySet = value;
    $$invalidate(3, selectedOptionInitiallySet);
  }
  function select_selectedOption_binding_2(value) {
    selectedComplexOption = value;
    $$invalidate(2, selectedComplexOption);
  }
  function select_selectedOption_binding_3(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  function select_selectedOption_binding_4(value) {
    selectedOption = value;
    $$invalidate(1, selectedOption);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    Select,
    selectedOption,
    selectedComplexOption,
    selectedOptionInitiallySet
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("selectedOption" in $$props2)
      $$invalidate(1, selectedOption = $$props2.selectedOption);
    if ("selectedComplexOption" in $$props2)
      $$invalidate(2, selectedComplexOption = $$props2.selectedComplexOption);
    if ("selectedOptionInitiallySet" in $$props2)
      $$invalidate(3, selectedOptionInitiallySet = $$props2.selectedOptionInitiallySet);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    selectedOption,
    selectedComplexOption,
    selectedOptionInitiallySet,
    select_selectedOption_binding,
    select_selectedOption_binding_1,
    select_selectedOption_binding_2,
    select_selectedOption_binding_3,
    select_selectedOption_binding_4
  ];
}
class Select_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$7, create_fragment$7, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select_story",
      options,
      id: create_fragment$7.name
    });
  }
  get Hst() {
    throw new Error("<Select_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Select_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
function create_default_slot_5$2(ctx) {
  let slant;
  let current;
  slant = new Slant({
    props: {
      position: ctx[2],
      direction: ctx[3]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(slant.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(slant.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(slant, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const slant_changes = {};
      if (dirty & 4)
        slant_changes.position = ctx2[2];
      if (dirty & 8)
        slant_changes.direction = ctx2[3];
      slant.$set(slant_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(slant.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(slant.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(slant, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$2.name,
    type: "slot",
    source: '(10:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$2.name,
    type: "slot",
    source: "(15:4) <Slant {position} {direction}>",
    ctx
  });
  return block;
}
function create_default_slot_3$3(ctx) {
  let slant;
  let current;
  slant = new Slant({
    props: {
      position: ctx[2],
      direction: ctx[3],
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(slant.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(slant.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(slant, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const slant_changes = {};
      if (dirty & 4)
        slant_changes.position = ctx2[2];
      if (dirty & 8)
        slant_changes.direction = ctx2[3];
      if (dirty & 258) {
        slant_changes.$$scope = { dirty, ctx: ctx2 };
      }
      slant.$set(slant_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(slant.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(slant.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(slant, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$3.name,
    type: "slot",
    source: '(14:2) <Hst.Variant title=\\"With text\\">',
    ctx
  });
  return block;
}
function create_controls_slot_2(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding(value) {
    ctx[6](value);
  }
  let hst_text_props = { title: "Text" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot_2.name,
    type: "slot",
    source: '(19:4) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_default_slot_2$3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$3.name,
    type: "slot",
    source: '(25:4) <Slant       {position}       {direction}       backgroundColor={tokens.cYellow200}       color=\\"black\\"     >',
    ctx
  });
  return block;
}
function create_default_slot_1$3(ctx) {
  let slant;
  let current;
  slant = new Slant({
    props: {
      position: ctx[2],
      direction: ctx[3],
      backgroundColor: cYellow200,
      color: "black",
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(slant.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(slant.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(slant, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const slant_changes = {};
      if (dirty & 4)
        slant_changes.position = ctx2[2];
      if (dirty & 8)
        slant_changes.direction = ctx2[3];
      if (dirty & 258) {
        slant_changes.$$scope = { dirty, ctx: ctx2 };
      }
      slant.$set(slant_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(slant.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(slant.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(slant, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$3.name,
    type: "slot",
    source: '(24:2) <Hst.Variant title=\\"With custom colors\\">',
    ctx
  });
  return block;
}
function create_controls_slot_1(ctx) {
  let hst_text;
  let updating_value;
  let current;
  function hst_text_value_binding_1(value) {
    ctx[7](value);
  }
  let hst_text_props = { title: "Text" };
  if (ctx[1] !== void 0) {
    hst_text_props.value = ctx[1];
  }
  hst_text = new ctx[0].Text({ props: hst_text_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_text, "value", hst_text_value_binding_1, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_text.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_text.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_text, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_text_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_text_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_text.$set(hst_text_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_text.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_text.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_text, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot_1.name,
    type: "slot",
    source: '(34:4) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_default_slot$3(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_5$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "With text",
      $$slots: {
        controls: [create_controls_slot_2],
        default: [create_default_slot_3$3]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "With custom colors",
      $$slots: {
        controls: [create_controls_slot_1],
        default: [create_default_slot_1$3]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 268) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 270) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 270) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$3.name,
    type: "slot",
    source: `(9:0) <Hst.Story group=\\"ui\\" title=\\"Slant\\" layout={{ type: 'grid', width: '100%' }}>`,
    ctx
  });
  return block;
}
function create_controls_slot$1(ctx) {
  let hst_radio0;
  let updating_value;
  let t;
  let hst_radio1;
  let updating_value_1;
  let current;
  function hst_radio0_value_binding(value) {
    ctx[4](value);
  }
  let hst_radio0_props = {
    title: "Position",
    options: [
      { label: "Right", value: "right" },
      { label: "Left", value: "left" },
      { label: "Both", value: "both" }
    ]
  };
  if (ctx[2] !== void 0) {
    hst_radio0_props.value = ctx[2];
  }
  hst_radio0 = new ctx[0].Radio({ props: hst_radio0_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_radio0, "value", hst_radio0_value_binding, ctx[2]));
  function hst_radio1_value_binding(value) {
    ctx[5](value);
  }
  let hst_radio1_props = {
    title: "Direction",
    options: [
      { label: "Forward", value: "forward" },
      { label: "Backward", value: "backward" }
    ]
  };
  if (ctx[3] !== void 0) {
    hst_radio1_props.value = ctx[3];
  }
  hst_radio1 = new ctx[0].Radio({ props: hst_radio1_props, $$inline: true });
  binding_callbacks.push(() => bind(hst_radio1, "value", hst_radio1_value_binding, ctx[3]));
  const block = {
    c: function create() {
      create_component(hst_radio0.$$.fragment);
      t = space();
      create_component(hst_radio1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_radio0.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(hst_radio1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_radio0, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(hst_radio1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_radio0_changes = {};
      if (!updating_value && dirty & 4) {
        updating_value = true;
        hst_radio0_changes.value = ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      hst_radio0.$set(hst_radio0_changes);
      const hst_radio1_changes = {};
      if (!updating_value_1 && dirty & 8) {
        updating_value_1 = true;
        hst_radio1_changes.value = ctx2[3];
        add_flush_callback(() => updating_value_1 = false);
      }
      hst_radio1.$set(hst_radio1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_radio0.$$.fragment, local);
      transition_in(hst_radio1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_radio0.$$.fragment, local);
      transition_out(hst_radio1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_radio0, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(hst_radio1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot$1.name,
    type: "slot",
    source: '(39:2) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_fragment$6(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "ui",
      title: "Slant",
      layout: { type: "grid", width: "100%" },
      $$slots: {
        controls: [create_controls_slot$1],
        default: [create_default_slot$3]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 270) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Slant_story", slots, []);
  let { Hst } = $$props;
  let text2 = "Text";
  let position = "right";
  let direction = "forward";
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Slant_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Slant_story> was created with unknown prop '${key}'`);
  });
  function hst_radio0_value_binding(value) {
    position = value;
    $$invalidate(2, position);
  }
  function hst_radio1_value_binding(value) {
    direction = value;
    $$invalidate(3, direction);
  }
  function hst_text_value_binding(value) {
    text2 = value;
    $$invalidate(1, text2);
  }
  function hst_text_value_binding_1(value) {
    text2 = value;
    $$invalidate(1, text2);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    Slant,
    tokens,
    text: text2,
    position,
    direction
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
    if ("position" in $$props2)
      $$invalidate(2, position = $$props2.position);
    if ("direction" in $$props2)
      $$invalidate(3, direction = $$props2.direction);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    text2,
    position,
    direction,
    hst_radio0_value_binding,
    hst_radio1_value_binding,
    hst_text_value_binding,
    hst_text_value_binding_1
  ];
}
class Slant_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$6, create_fragment$6, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slant_story",
      options,
      id: create_fragment$6.name
    });
  }
  get Hst() {
    throw new Error("<Slant_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Slant_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Tabs_svelte_svelte_type_style_lang = "";
const file$5 = "src/lib/components/shared/Tabs.svelte";
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[21] = list;
  child_ctx[22] = i;
  const constants_0 = child_ctx[22] === child_ctx[0];
  child_ctx[17] = constants_0;
  const constants_1 = child_ctx[5](child_ctx[16]);
  child_ctx[18] = constants_1;
  const constants_2 = child_ctx[6](child_ctx[16]);
  child_ctx[19] = constants_2;
  const constants_3 = child_ctx[22] === 0 ? "right" : child_ctx[22] === child_ctx[2].length - 1 ? "left" : "both";
  child_ctx[20] = constants_3;
  return child_ctx;
}
const get_default_slot_changes$1 = (dirty) => ({
  tab: dirty & 4,
  active: dirty & 1
});
const get_default_slot_context$1 = (ctx) => ({
  tab: ctx[16],
  active: ctx[17]
});
function fallback_block$1(ctx) {
  let t_value = ctx[16] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[16] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block$1.name,
    type: "fallback",
    source: "(100:29)            ",
    ctx
  });
  return block;
}
function create_each_block$2(ctx) {
  let button;
  let div;
  let t;
  let button_id_value;
  let button_class_value;
  let button_data_slant_position_value;
  let button_aria_controls_value;
  let button_aria_selected_value;
  let button_aria_disabled_value;
  let button_tabindex_value;
  let i = ctx[22];
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], get_default_slot_context$1);
  const default_slot_or_fallback = default_slot || fallback_block$1(ctx);
  const assign_button = () => ctx[13](button, i);
  const unassign_button = () => ctx[13](null, i);
  function focus_handler() {
    return ctx[14](ctx[18], ctx[22]);
  }
  function click_handler(...args) {
    return ctx[15](ctx[18], ...args);
  }
  const block = {
    c: function create() {
      button = element("button");
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        id: true,
        type: true,
        role: true,
        class: true,
        "data-slant-position": true,
        "aria-controls": true,
        "aria-selected": true,
        "aria-disabled": true,
        tabindex: true
      });
      var button_nodes = children(button);
      div = claim_element(button_nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t = claim_space(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file$5, 98, 6, 3004);
      attr_dev(button, "id", button_id_value = ctx[1] + "--tab-" + ctx[22]);
      attr_dev(button, "type", "button");
      attr_dev(button, "role", "tab");
      attr_dev(button, "class", button_class_value = (ctx[19] || "") + " | tabs__tab | reset s-UBXEnNqzXpLd");
      attr_dev(button, "data-slant-position", button_data_slant_position_value = ctx[20]);
      attr_dev(button, "aria-controls", button_aria_controls_value = ctx[1] + "--tabpanel-" + ctx[22]);
      attr_dev(button, "aria-selected", button_aria_selected_value = ctx[17]);
      attr_dev(button, "aria-disabled", button_aria_disabled_value = ctx[18]);
      attr_dev(button, "tabindex", button_tabindex_value = ctx[17] ? 0 : -1);
      toggle_class(button, "slant", ctx[4]);
      toggle_class(button, "active", ctx[17]);
      toggle_class(button, "disabled", ctx[18]);
      add_location(button, file$5, 73, 4, 2309);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, div);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      append_hydration_dev(button, t);
      assign_button();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "focus", focus_handler, false, false, false),
          listen_dev(button, "keydown", ctx[9], false, false, false),
          listen_dev(button, "click", click_handler, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2053)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[11],
            !current ? get_all_dirty_from_scope(ctx[11]) : get_slot_changes(default_slot_template, ctx[11], dirty, get_default_slot_changes$1),
            get_default_slot_context$1
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 4)) {
          default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 2 && button_id_value !== (button_id_value = ctx[1] + "--tab-" + ctx[22])) {
        attr_dev(button, "id", button_id_value);
      }
      if (!current || dirty & 68 && button_class_value !== (button_class_value = (ctx[19] || "") + " | tabs__tab | reset s-UBXEnNqzXpLd")) {
        attr_dev(button, "class", button_class_value);
      }
      if (!current || dirty & 4 && button_data_slant_position_value !== (button_data_slant_position_value = ctx[20])) {
        attr_dev(button, "data-slant-position", button_data_slant_position_value);
      }
      if (!current || dirty & 2 && button_aria_controls_value !== (button_aria_controls_value = ctx[1] + "--tabpanel-" + ctx[22])) {
        attr_dev(button, "aria-controls", button_aria_controls_value);
      }
      if (!current || dirty & 1 && button_aria_selected_value !== (button_aria_selected_value = ctx[17])) {
        attr_dev(button, "aria-selected", button_aria_selected_value);
      }
      if (!current || dirty & 36 && button_aria_disabled_value !== (button_aria_disabled_value = ctx[18])) {
        attr_dev(button, "aria-disabled", button_aria_disabled_value);
      }
      if (!current || dirty & 1 && button_tabindex_value !== (button_tabindex_value = ctx[17] ? 0 : -1)) {
        attr_dev(button, "tabindex", button_tabindex_value);
      }
      if (i !== ctx[22]) {
        unassign_button();
        i = ctx[22];
        assign_button();
      }
      if (!current || dirty & 84) {
        toggle_class(button, "slant", ctx[4]);
      }
      if (!current || dirty & 69) {
        toggle_class(button, "active", ctx[17]);
      }
      if (!current || dirty & 100) {
        toggle_class(button, "disabled", ctx[18]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      unassign_button();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$2.name,
    type: "each",
    source: "(68:2) {#each tabs as tab, i}",
    ctx
  });
  return block;
}
function create_fragment$5(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let current;
  let each_value = ctx[2];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        id: true,
        role: true,
        "aria-orientation": true,
        "aria-label": true,
        class: true,
        style: true
      });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "id", ctx[1]);
      attr_dev(div, "role", "tablist");
      attr_dev(div, "aria-orientation", "horizontal");
      attr_dev(div, "aria-label", ctx[3]);
      attr_dev(div, "class", div_class_value = null_to_empty(ctx[10].class) + " s-UBXEnNqzXpLd");
      attr_dev(div, "style", div_style_value = ctx[10].style);
      toggle_class(div, "tabs", true);
      add_location(div, file$5, 58, 0, 1900);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 3063) {
        each_value = ctx2[2];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & 2) {
        attr_dev(div, "id", ctx2[1]);
      }
      if (!current || dirty & 8) {
        attr_dev(div, "aria-label", ctx2[3]);
      }
      if (!current || dirty & 1024 && div_class_value !== (div_class_value = null_to_empty(ctx2[10].class) + " s-UBXEnNqzXpLd")) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & 1024 && div_style_value !== (div_style_value = ctx2[10].style)) {
        attr_dev(div, "style", div_style_value);
      }
      if (!current || dirty & 1024) {
        toggle_class(div, "tabs", true);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$5($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "tabs", "label", "activeIndex", "slants", "isTabDisabled", "getTabClass"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tabs", slots, ["default"]);
  let { id } = $$props;
  let { tabs } = $$props;
  let { label } = $$props;
  let { activeIndex = 0 } = $$props;
  let { slants = true } = $$props;
  let { isTabDisabled = () => false } = $$props;
  let { getTabClass = () => null } = $$props;
  let buttons = [];
  let focusedIndex = activeIndex;
  function handleKeyDown(e) {
    const getNextIndex = (keyPressed) => {
      switch (keyPressed) {
        case "Home":
          return 0;
        case "End":
          return tabs.length - 1;
        case "ArrowLeft":
          return getIndexBefore(focusedIndex, tabs.length, { circular: true });
        case "ArrowRight":
          return getIndexAfter(focusedIndex, tabs.length, { circular: true });
      }
    };
    if (!["Home", "End", "ArrowLeft", "ArrowRight"].includes(e.key))
      return;
    const nextIndex = getNextIndex(e.key);
    buttons[nextIndex].focus();
    $$invalidate(8, focusedIndex = nextIndex);
  }
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Tabs> was created without expected prop 'id'");
    }
    if (tabs === void 0 && !("tabs" in $$props || $$self.$$.bound[$$self.$$.props["tabs"]])) {
      console.warn("<Tabs> was created without expected prop 'tabs'");
    }
    if (label === void 0 && !("label" in $$props || $$self.$$.bound[$$self.$$.props["label"]])) {
      console.warn("<Tabs> was created without expected prop 'label'");
    }
  });
  function button_binding($$value, i) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[i] = $$value;
      $$invalidate(7, buttons);
    });
  }
  const focus_handler = (disabled, i) => {
    if (disabled)
      return;
    $$invalidate(0, activeIndex = i);
    $$invalidate(8, focusedIndex = activeIndex);
  };
  const click_handler = (disabled, e) => {
    if (disabled)
      return;
    e.currentTarget.focus();
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(1, id = $$new_props.id);
    if ("tabs" in $$new_props)
      $$invalidate(2, tabs = $$new_props.tabs);
    if ("label" in $$new_props)
      $$invalidate(3, label = $$new_props.label);
    if ("activeIndex" in $$new_props)
      $$invalidate(0, activeIndex = $$new_props.activeIndex);
    if ("slants" in $$new_props)
      $$invalidate(4, slants = $$new_props.slants);
    if ("isTabDisabled" in $$new_props)
      $$invalidate(5, isTabDisabled = $$new_props.isTabDisabled);
    if ("getTabClass" in $$new_props)
      $$invalidate(6, getTabClass = $$new_props.getTabClass);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getIndexBefore,
    getIndexAfter,
    id,
    tabs,
    label,
    activeIndex,
    slants,
    isTabDisabled,
    getTabClass,
    buttons,
    focusedIndex,
    handleKeyDown
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(1, id = $$new_props.id);
    if ("tabs" in $$props)
      $$invalidate(2, tabs = $$new_props.tabs);
    if ("label" in $$props)
      $$invalidate(3, label = $$new_props.label);
    if ("activeIndex" in $$props)
      $$invalidate(0, activeIndex = $$new_props.activeIndex);
    if ("slants" in $$props)
      $$invalidate(4, slants = $$new_props.slants);
    if ("isTabDisabled" in $$props)
      $$invalidate(5, isTabDisabled = $$new_props.isTabDisabled);
    if ("getTabClass" in $$props)
      $$invalidate(6, getTabClass = $$new_props.getTabClass);
    if ("buttons" in $$props)
      $$invalidate(7, buttons = $$new_props.buttons);
    if ("focusedIndex" in $$props)
      $$invalidate(8, focusedIndex = $$new_props.focusedIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    activeIndex,
    id,
    tabs,
    label,
    slants,
    isTabDisabled,
    getTabClass,
    buttons,
    focusedIndex,
    handleKeyDown,
    $$restProps,
    $$scope,
    slots,
    button_binding,
    focus_handler,
    click_handler
  ];
}
class Tabs extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$5, create_fragment$5, safe_not_equal, {
      id: 1,
      tabs: 2,
      label: 3,
      activeIndex: 0,
      slants: 4,
      isTabDisabled: 5,
      getTabClass: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tabs",
      options,
      id: create_fragment$5.name
    });
  }
  get id() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabs() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slants() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slants(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isTabDisabled() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isTabDisabled(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getTabClass() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getTabClass(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const { console: console_1 } = globals;
const file$4 = "src/lib/components/shared/TabPanels.svelte";
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  child_ctx[8] = i;
  const constants_0 = child_ctx[8] === child_ctx[2];
  child_ctx[6] = constants_0;
  return child_ctx;
}
const get_default_slot_changes = (dirty) => ({ tab: dirty & 2 });
const get_default_slot_context = (ctx) => ({ tab: ctx[5] });
function create_if_block$3(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], get_default_slot_context);
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 10)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, get_default_slot_changes),
            get_default_slot_context
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$3.name,
    type: "if",
    source: "(37:4) {#if active}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t_value = ctx[5] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[5] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(38:18)          ",
    ctx
  });
  return block;
}
function create_each_block$1(ctx) {
  let div;
  let t;
  let div_id_value;
  let div_aria_labelledby_value;
  let div_aria_expanded_value;
  let div_tabindex_value;
  let current;
  let if_block = ctx[6] && create_if_block$3(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        id: true,
        class: true,
        role: true,
        "aria-labelledby": true,
        "aria-expanded": true,
        tabindex: true
      });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "id", div_id_value = ctx[0] + "--tabpanel-" + ctx[8]);
      attr_dev(div, "class", "tab-panel");
      attr_dev(div, "role", "tabpanel");
      attr_dev(div, "aria-labelledby", div_aria_labelledby_value = ctx[0] + "--tab-" + ctx[8]);
      attr_dev(div, "aria-expanded", div_aria_expanded_value = ctx[6]);
      attr_dev(div, "tabindex", div_tabindex_value = ctx[6] ? 0 : -1);
      add_location(div, file$4, 28, 2, 905);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 1 && div_id_value !== (div_id_value = ctx2[0] + "--tabpanel-" + ctx2[8])) {
        attr_dev(div, "id", div_id_value);
      }
      if (!current || dirty & 1 && div_aria_labelledby_value !== (div_aria_labelledby_value = ctx2[0] + "--tab-" + ctx2[8])) {
        attr_dev(div, "aria-labelledby", div_aria_labelledby_value);
      }
      if (!current || dirty & 4 && div_aria_expanded_value !== (div_aria_expanded_value = ctx2[6])) {
        attr_dev(div, "aria-expanded", div_aria_expanded_value);
      }
      if (!current || dirty & 4 && div_tabindex_value !== (div_tabindex_value = ctx2[6] ? 0 : -1)) {
        attr_dev(div, "tabindex", div_tabindex_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$1.name,
    type: "each",
    source: "(26:0) {#each tabs as tab, i}",
    ctx
  });
  return block;
}
function create_fragment$4(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 15) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabPanels", slots, ["default"]);
  let { id } = $$props;
  let { tabs } = $$props;
  let { activeIndex } = $$props;
  onMount(() => {
    if (!document.getElementById(id)) {
      console.warn("rbb-data/svelte-starter: The id of <TabPanel {id} /> does not match the id of <Tab />.");
    }
  });
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console_1.warn("<TabPanels> was created without expected prop 'id'");
    }
    if (tabs === void 0 && !("tabs" in $$props || $$self.$$.bound[$$self.$$.props["tabs"]])) {
      console_1.warn("<TabPanels> was created without expected prop 'tabs'");
    }
    if (activeIndex === void 0 && !("activeIndex" in $$props || $$self.$$.bound[$$self.$$.props["activeIndex"]])) {
      console_1.warn("<TabPanels> was created without expected prop 'activeIndex'");
    }
  });
  const writable_props = ["id", "tabs", "activeIndex"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<TabPanels> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("tabs" in $$props2)
      $$invalidate(1, tabs = $$props2.tabs);
    if ("activeIndex" in $$props2)
      $$invalidate(2, activeIndex = $$props2.activeIndex);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ onMount, id, tabs, activeIndex });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("tabs" in $$props2)
      $$invalidate(1, tabs = $$props2.tabs);
    if ("activeIndex" in $$props2)
      $$invalidate(2, activeIndex = $$props2.activeIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [id, tabs, activeIndex, $$scope, slots];
}
class TabPanels extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4, create_fragment$4, safe_not_equal, { id: 0, tabs: 1, activeIndex: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabPanels",
      options,
      id: create_fragment$4.name
    });
  }
  get id() {
    throw new Error("<TabPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TabPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabs() {
    throw new Error("<TabPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<TabPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<TabPanels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<TabPanels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const TabPanels_story_svelte_svelte_type_style_lang = "";
const file$3 = "src/lib/components/shared/TabPanels.story.svelte";
function create_default_slot_18$1(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s-XJ_1c8CSCPyr");
      add_location(div, file$3, 27, 6, 674);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_18$1.name,
    type: "slot",
    source: '(27:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_17$1(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding(value) {
    ctx[5](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[3]
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_18$1,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17$1.name,
    type: "slot",
    source: '(19:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_16$1(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s-XJ_1c8CSCPyr");
      add_location(div, file$3, 45, 6, 1081);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16$1.name,
    type: "slot",
    source: '(40:4) <TabPanels       id=\\"my-unique-tabs-id\\"       {tabs}       activeIndex={activeIndexInitiallySelected}       let:tab     >',
    ctx
  });
  return block;
}
function create_default_slot_15$1(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_1(value) {
    ctx[6](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[3]
  };
  if (ctx[2] !== void 0) {
    tabs_1_props.activeIndex = ctx[2];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_1, ctx[2]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[2],
      $$slots: {
        default: [
          create_default_slot_16$1,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 4) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[2];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 4)
        tabpanels_changes.activeIndex = ctx2[2];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15$1.name,
    type: "slot",
    source: '(32:2) <Hst.Variant title=\\"Specify initially selected tab\\">',
    ctx
  });
  return block;
}
function create_if_block$2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(active)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(active)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$2.name,
    type: "if",
    source: "(60:6) {#if active}",
    ctx
  });
  return block;
}
function create_default_slot_14$1(ctx) {
  let t0_value = ctx[13] + "";
  let t0;
  let t1;
  let if_block_anchor;
  let if_block = ctx[14] && create_if_block$2(ctx);
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t0_value !== (t0_value = ctx2[13] + ""))
        set_data_dev(t0, t0_value);
      if (ctx2[14]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14$1.name,
    type: "slot",
    source: '(51:4) <Tabs       id=\\"my-unique-tabs-id\\"       label=\\"Wähle einen Tab\\"       {tabs}       bind:activeIndex       let:tab       let:active     >',
    ctx
  });
  return block;
}
function create_default_slot_13$1(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s-XJ_1c8CSCPyr");
      add_location(div, file$3, 65, 6, 1488);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13$1.name,
    type: "slot",
    source: '(65:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_12$1(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_2(value) {
    ctx[7](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[3],
    $$slots: {
      default: [
        create_default_slot_14$1,
        ({ tab, active }) => ({ 13: tab, 14: active }),
        ({ tab, active }) => (tab ? 8192 : 0) | (active ? 16384 : 0)
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_2, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_13$1,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (dirty & 57344) {
        tabs_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12$1.name,
    type: "slot",
    source: '(50:2) <Hst.Variant title=\\"Custom tab labels\\">',
    ctx
  });
  return block;
}
function create_default_slot_11$1(ctx) {
  let t_value = ctx[13].label + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t_value !== (t_value = ctx2[13].label + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_11$1.name,
    type: "slot",
    source: '(71:4) <Tabs       id=\\"my-unique-tabs-id\\"       label=\\"Wähle einen Tab\\"       tabs={complexTabs}       bind:activeIndex       let:tab     >',
    ctx
  });
  return block;
}
function create_default_slot_10$1(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13].label + "";
  let t1;
  let t2;
  let t3_value = ctx[13].data + "";
  let t3;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      t2 = text(" with data ");
      t3 = text(t3_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      t2 = claim_text(div_nodes, " with data ");
      t3 = claim_text(div_nodes, t3_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s-XJ_1c8CSCPyr");
      add_location(div, file$3, 81, 6, 1855);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, t2);
      append_hydration_dev(div, t3);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13].label + ""))
        set_data_dev(t1, t1_value);
      if (dirty & 8192 && t3_value !== (t3_value = ctx2[13].data + ""))
        set_data_dev(t3, t3_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10$1.name,
    type: "slot",
    source: '(81:4) <TabPanels id=\\"my-unique-tabs-id\\" tabs={complexTabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_9$1(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_3(value) {
    ctx[8](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[4],
    $$slots: {
      default: [
        create_default_slot_11$1,
        ({ tab }) => ({ 13: tab }),
        ({ tab }) => tab ? 8192 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_3, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[4],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_10$1,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (dirty & 40960) {
        tabs_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9$1.name,
    type: "slot",
    source: '(70:2) <Hst.Variant title=\\"Complex tabs\\">',
    ctx
  });
  return block;
}
function create_default_slot_8$1(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s-XJ_1c8CSCPyr");
      add_location(div, file$3, 95, 6, 2229);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8$1.name,
    type: "slot",
    source: '(95:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_7$1(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_4(value) {
    ctx[9](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[3],
    isTabDisabled: func$1
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_4, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_8$1,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7$1.name,
    type: "slot",
    source: '(86:2) <Hst.Variant title=\\"Disabled tab\\">',
    ctx
  });
  return block;
}
function create_default_slot_6$1(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s-XJ_1c8CSCPyr");
      add_location(div, file$3, 109, 6, 2580);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6$1.name,
    type: "slot",
    source: '(109:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_5$1(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_5(value) {
    ctx[10](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    class: "tabs-with-custom-accent-color",
    label: "Wähle einen Tab",
    tabs: ctx[3]
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_5, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_6$1,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5$1.name,
    type: "slot",
    source: '(100:2) <Hst.Variant title=\\"Custom accent color\\">',
    ctx
  });
  return block;
}
function create_default_slot_4$1(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s-XJ_1c8CSCPyr");
      add_location(div, file$3, 124, 6, 2991);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4$1.name,
    type: "slot",
    source: '(124:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_3$2(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_6(value) {
    ctx[11](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    class: "tabs-with-custom-colors",
    label: "Wähle einen Tab",
    tabs: ctx[3],
    getTabClass: func_1$1
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_6, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_4$1,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$2.name,
    type: "slot",
    source: '(114:2) <Hst.Variant title=\\"Customize all colors\\">',
    ctx
  });
  return block;
}
function create_default_slot_2$2(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s-XJ_1c8CSCPyr");
      add_location(div, file$3, 138, 6, 3314);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$2.name,
    type: "slot",
    source: '(138:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_1$2(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_7(value) {
    ctx[12](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[3],
    slants: false
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_7, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_2$2,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$2.name,
    type: "slot",
    source: '(129:2) <Hst.Variant title=\\"Without slants\\">',
    ctx
  });
  return block;
}
function create_default_slot$2(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let t2;
  let hst_variant3;
  let t3;
  let hst_variant4;
  let t4;
  let hst_variant5;
  let t5;
  let hst_variant6;
  let t6;
  let hst_variant7;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_17$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Specify initially selected tab",
      $$slots: { default: [create_default_slot_15$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Custom tab labels",
      $$slots: { default: [create_default_slot_12$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant3 = new ctx[0].Variant({
    props: {
      title: "Complex tabs",
      $$slots: { default: [create_default_slot_9$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant4 = new ctx[0].Variant({
    props: {
      title: "Disabled tab",
      $$slots: { default: [create_default_slot_7$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant5 = new ctx[0].Variant({
    props: {
      title: "Custom accent color",
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant6 = new ctx[0].Variant({
    props: {
      title: "Customize all colors",
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant7 = new ctx[0].Variant({
    props: {
      title: "Without slants",
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
      t2 = space();
      create_component(hst_variant3.$$.fragment);
      t3 = space();
      create_component(hst_variant4.$$.fragment);
      t4 = space();
      create_component(hst_variant5.$$.fragment);
      t5 = space();
      create_component(hst_variant6.$$.fragment);
      t6 = space();
      create_component(hst_variant7.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_variant3.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(hst_variant4.$$.fragment, nodes);
      t4 = claim_space(nodes);
      claim_component(hst_variant5.$$.fragment, nodes);
      t5 = claim_space(nodes);
      claim_component(hst_variant6.$$.fragment, nodes);
      t6 = claim_space(nodes);
      claim_component(hst_variant7.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_variant3, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(hst_variant4, target, anchor);
      insert_hydration_dev(target, t4, anchor);
      mount_component(hst_variant5, target, anchor);
      insert_hydration_dev(target, t5, anchor);
      mount_component(hst_variant6, target, anchor);
      insert_hydration_dev(target, t6, anchor);
      mount_component(hst_variant7, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 32770) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 32772) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 32770) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
      const hst_variant3_changes = {};
      if (dirty & 32770) {
        hst_variant3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant3.$set(hst_variant3_changes);
      const hst_variant4_changes = {};
      if (dirty & 32770) {
        hst_variant4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant4.$set(hst_variant4_changes);
      const hst_variant5_changes = {};
      if (dirty & 32770) {
        hst_variant5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant5.$set(hst_variant5_changes);
      const hst_variant6_changes = {};
      if (dirty & 32770) {
        hst_variant6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant6.$set(hst_variant6_changes);
      const hst_variant7_changes = {};
      if (dirty & 32770) {
        hst_variant7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant7.$set(hst_variant7_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      transition_in(hst_variant3.$$.fragment, local);
      transition_in(hst_variant4.$$.fragment, local);
      transition_in(hst_variant5.$$.fragment, local);
      transition_in(hst_variant6.$$.fragment, local);
      transition_in(hst_variant7.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      transition_out(hst_variant3.$$.fragment, local);
      transition_out(hst_variant4.$$.fragment, local);
      transition_out(hst_variant5.$$.fragment, local);
      transition_out(hst_variant6.$$.fragment, local);
      transition_out(hst_variant7.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_variant3, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(hst_variant4, detaching);
      if (detaching)
        detach_dev(t4);
      destroy_component(hst_variant5, detaching);
      if (detaching)
        detach_dev(t5);
      destroy_component(hst_variant6, detaching);
      if (detaching)
        detach_dev(t6);
      destroy_component(hst_variant7, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$2.name,
    type: "slot",
    source: `(14:0) <Hst.Story   group=\\"ui\\"   title=\\"TabPanels\\"   layout={{ type: 'grid', width: '100%' }} >`,
    ctx
  });
  return block;
}
function create_fragment$3(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "ui",
      title: "TabPanels",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 32774) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const func$1 = (tab) => tab === "Tab 3";
const func_1$1 = (tab) => tab.toLowerCase().replace(" ", "-");
function instance$3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabPanels_story", slots, []);
  let { Hst } = $$props;
  const tabs = ["Tab 1", "Tab 2", "Tab 3"];
  const complexTabs = [
    { label: "Tab 1", data: [1, 2, 3] },
    { label: "Tab 2", data: [2, 3, 4] },
    { label: "Tab 3", data: [3, 4, 5] }
  ];
  let activeIndex;
  let activeIndexInitiallySelected = 1;
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<TabPanels_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TabPanels_story> was created with unknown prop '${key}'`);
  });
  function tabs_1_activeIndex_binding(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_1(value) {
    activeIndexInitiallySelected = value;
    $$invalidate(2, activeIndexInitiallySelected);
  }
  function tabs_1_activeIndex_binding_2(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_3(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_4(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_5(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_6(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_7(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    Tabs,
    TabPanels,
    tabs,
    complexTabs,
    activeIndex,
    activeIndexInitiallySelected
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("activeIndex" in $$props2)
      $$invalidate(1, activeIndex = $$props2.activeIndex);
    if ("activeIndexInitiallySelected" in $$props2)
      $$invalidate(2, activeIndexInitiallySelected = $$props2.activeIndexInitiallySelected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    activeIndex,
    activeIndexInitiallySelected,
    tabs,
    complexTabs,
    tabs_1_activeIndex_binding,
    tabs_1_activeIndex_binding_1,
    tabs_1_activeIndex_binding_2,
    tabs_1_activeIndex_binding_3,
    tabs_1_activeIndex_binding_4,
    tabs_1_activeIndex_binding_5,
    tabs_1_activeIndex_binding_6,
    tabs_1_activeIndex_binding_7
  ];
}
class TabPanels_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3, create_fragment$3, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabPanels_story",
      options,
      id: create_fragment$3.name
    });
  }
  get Hst() {
    throw new Error("<TabPanels_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<TabPanels_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Table_svelte_svelte_type_style_lang = "";
const file$2 = "src/lib/components/shared/Table.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  child_ctx[7] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i].getValue;
  child_ctx[9] = list[i].class;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i].name;
  child_ctx[9] = list[i].class;
  return child_ctx;
}
function create_if_block$1(ctx) {
  let caption_1;
  let t;
  const block = {
    c: function create() {
      caption_1 = element("caption");
      t = text(ctx[2]);
      this.h();
    },
    l: function claim(nodes) {
      caption_1 = claim_element(nodes, "CAPTION", { class: true });
      var caption_1_nodes = children(caption_1);
      t = claim_text(caption_1_nodes, ctx[2]);
      caption_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(caption_1, "class", "s-B3JuG3EW7hlw");
      add_location(caption_1, file$2, 21, 4, 531);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, caption_1, anchor);
      append_hydration_dev(caption_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(caption_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$1.name,
    type: "if",
    source: "(21:2) {#if caption}",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let th;
  let t0_value = ctx[12] + "";
  let t0;
  let t1;
  let th_class_value;
  const block = {
    c: function create() {
      th = element("th");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true, scope: true });
      var th_nodes = children(th);
      t0 = claim_text(th_nodes, t0_value);
      t1 = claim_space(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "class", th_class_value = null_to_empty(ctx[9]) + " s-B3JuG3EW7hlw");
      attr_dev(th, "scope", "col");
      toggle_class(th, "row-header", ctx[3]);
      add_location(th, file$2, 28, 8, 659);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, t0);
      append_hydration_dev(th, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[12] + ""))
        set_data_dev(t0, t0_value);
      if (dirty & 2 && th_class_value !== (th_class_value = null_to_empty(ctx2[9]) + " s-B3JuG3EW7hlw")) {
        attr_dev(th, "class", th_class_value);
      }
      if (dirty & 10) {
        toggle_class(th, "row-header", ctx2[3]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(28:6) {#each columns as { name, class: className }}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let td;
  let t_value = ctx[8](ctx[5], ctx[7]) + "";
  let t;
  let td_class_value;
  const block = {
    c: function create() {
      td = element("td");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      t = claim_text(td_nodes, t_value);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", td_class_value = null_to_empty(ctx[9]) + " s-B3JuG3EW7hlw");
      add_location(td, file$2, 44, 10, 1085);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 3 && t_value !== (t_value = ctx2[8](ctx2[5], ctx2[7]) + ""))
        set_data_dev(t, t_value);
      if (dirty & 2 && td_class_value !== (td_class_value = null_to_empty(ctx2[9]) + " s-B3JuG3EW7hlw")) {
        attr_dev(td, "class", td_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(44:8) {#each columns.slice(1) as { getValue, class: className }}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let tr;
  let th;
  let t0_value = ctx[1][0].getValue(ctx[5], ctx[7]) + "";
  let t0;
  let th_scope_value;
  let t1;
  let t2;
  let each_value_1 = ctx[1].slice(1);
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      tr = element("tr");
      th = element("th");
      t0 = text(t0_value);
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      th = claim_element(tr_nodes, "TH", { scope: true, class: true });
      var th_nodes = children(th);
      t0 = claim_text(th_nodes, t0_value);
      th_nodes.forEach(detach_dev);
      t1 = claim_space(tr_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t2 = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "scope", th_scope_value = ctx[3] ? "row" : void 0);
      attr_dev(th, "class", "s-B3JuG3EW7hlw");
      toggle_class(th, "row-header", ctx[3]);
      add_location(th, file$2, 37, 8, 847);
      attr_dev(tr, "class", "s-B3JuG3EW7hlw");
      add_location(tr, file$2, 36, 6, 834);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      append_hydration_dev(tr, th);
      append_hydration_dev(th, t0);
      append_hydration_dev(tr, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tr, null);
      }
      append_hydration_dev(tr, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 3 && t0_value !== (t0_value = ctx2[1][0].getValue(ctx2[5], ctx2[7]) + ""))
        set_data_dev(t0, t0_value);
      if (dirty & 8 && th_scope_value !== (th_scope_value = ctx2[3] ? "row" : void 0)) {
        attr_dev(th, "scope", th_scope_value);
      }
      if (dirty & 8) {
        toggle_class(th, "row-header", ctx2[3]);
      }
      if (dirty & 3) {
        each_value_1 = ctx2[1].slice(1);
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, t2);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(36:4) {#each data as d, i}",
    ctx
  });
  return block;
}
function create_fragment$2(ctx) {
  let table;
  let t0;
  let thead;
  let tr;
  let t1;
  let tbody;
  let table_class_value;
  let table_style_value;
  let if_block = ctx[2] && create_if_block$1(ctx);
  let each_value_2 = ctx[1];
  validate_each_argument(each_value_2);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      table = element("table");
      if (if_block)
        if_block.c();
      t0 = space();
      thead = element("thead");
      tr = element("tr");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      table = claim_element(nodes, "TABLE", { class: true, style: true });
      var table_nodes = children(table);
      if (if_block)
        if_block.l(table_nodes);
      t0 = claim_space(table_nodes);
      thead = claim_element(table_nodes, "THEAD", { class: true });
      var thead_nodes = children(thead);
      tr = claim_element(thead_nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t1 = claim_space(table_nodes);
      tbody = claim_element(table_nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      table_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "class", "s-B3JuG3EW7hlw");
      add_location(tr, file$2, 26, 4, 594);
      attr_dev(thead, "class", "s-B3JuG3EW7hlw");
      add_location(thead, file$2, 25, 2, 582);
      attr_dev(tbody, "class", "s-B3JuG3EW7hlw");
      add_location(tbody, file$2, 34, 2, 795);
      attr_dev(table, "class", table_class_value = null_to_empty(ctx[4].class) + " s-B3JuG3EW7hlw");
      attr_dev(table, "style", table_style_value = ctx[4].style);
      toggle_class(table, "table", true);
      add_location(table, file$2, 19, 0, 432);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, table, anchor);
      if (if_block)
        if_block.m(table, null);
      append_hydration_dev(table, t0);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(tr, null);
      }
      append_hydration_dev(table, t1);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tbody, null);
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          if_block.m(table, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 10) {
        each_value_2 = ctx2[1];
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_2(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(tr, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty & 11) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 16 && table_class_value !== (table_class_value = null_to_empty(ctx2[4].class) + " s-B3JuG3EW7hlw")) {
        attr_dev(table, "class", table_class_value);
      }
      if (dirty & 16 && table_style_value !== (table_style_value = ctx2[4].style)) {
        attr_dev(table, "style", table_style_value);
      }
      if (dirty & 16) {
        toggle_class(table, "table", true);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(table);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2($$self, $$props, $$invalidate) {
  const omit_props_names = ["data", "columns", "caption", "useRowHeaders"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, []);
  let { data } = $$props;
  let { columns } = $$props;
  let { caption } = $$props;
  let { useRowHeaders = true } = $$props;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Table> was created without expected prop 'data'");
    }
    if (columns === void 0 && !("columns" in $$props || $$self.$$.bound[$$self.$$.props["columns"]])) {
      console.warn("<Table> was created without expected prop 'columns'");
    }
    if (caption === void 0 && !("caption" in $$props || $$self.$$.bound[$$self.$$.props["caption"]])) {
      console.warn("<Table> was created without expected prop 'caption'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("data" in $$new_props)
      $$invalidate(0, data = $$new_props.data);
    if ("columns" in $$new_props)
      $$invalidate(1, columns = $$new_props.columns);
    if ("caption" in $$new_props)
      $$invalidate(2, caption = $$new_props.caption);
    if ("useRowHeaders" in $$new_props)
      $$invalidate(3, useRowHeaders = $$new_props.useRowHeaders);
  };
  $$self.$capture_state = () => ({ data, columns, caption, useRowHeaders });
  $$self.$inject_state = ($$new_props) => {
    if ("data" in $$props)
      $$invalidate(0, data = $$new_props.data);
    if ("columns" in $$props)
      $$invalidate(1, columns = $$new_props.columns);
    if ("caption" in $$props)
      $$invalidate(2, caption = $$new_props.caption);
    if ("useRowHeaders" in $$props)
      $$invalidate(3, useRowHeaders = $$new_props.useRowHeaders);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [data, columns, caption, useRowHeaders, $$restProps];
}
class Table extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2, create_fragment$2, safe_not_equal, {
      data: 0,
      columns: 1,
      caption: 2,
      useRowHeaders: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment$2.name
    });
  }
  get data() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columns() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columns(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caption() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caption(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useRowHeaders() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useRowHeaders(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Table_story_svelte_svelte_type_style_lang = "";
const file$1 = "src/lib/components/shared/Table.story.svelte";
function create_default_slot_3$1(ctx) {
  let table;
  let current;
  table = new Table({
    props: {
      data: ctx[2],
      columns: ctx[3],
      highlightFirstColumn: ctx[1],
      caption: "Titel Datensatz"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(table.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(table.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(table, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const table_changes = {};
      if (dirty & 2)
        table_changes.highlightFirstColumn = ctx2[1];
      table.$set(table_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(table.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(table.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(table, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3$1.name,
    type: "slot",
    source: '(64:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_2$1(ctx) {
  let div;
  let table;
  let current;
  table = new Table({
    props: {
      data: ctx[2],
      columns: ctx[4],
      caption: "Titel Datensatz"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(table.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(table.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "custom-table s-rTqnjXO7zxWr");
      add_location(div, file$1, 68, 4, 1874);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(table, div, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(table.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(table.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(table);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2$1.name,
    type: "slot",
    source: '(68:2) <Hst.Variant title=\\"Right-aligned data columns\\">',
    ctx
  });
  return block;
}
function create_default_slot_1$1(ctx) {
  let div;
  let table;
  let current;
  table = new Table({
    props: {
      data: ctx[2],
      columns: ctx[5],
      highlightFirstColumn: ctx[1],
      caption: "Titel Datensatz"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(table.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(table.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "custom-table s-rTqnjXO7zxWr");
      add_location(div, file$1, 74, 4, 2055);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(table, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const table_changes = {};
      if (dirty & 2)
        table_changes.highlightFirstColumn = ctx2[1];
      table.$set(table_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(table.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(table.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(table);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$1.name,
    type: "slot",
    source: '(74:2) <Hst.Variant title=\\"Customized columns\\">',
    ctx
  });
  return block;
}
function create_default_slot$1(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Right-aligned data columns",
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Customized columns",
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 130) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 128) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 130) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$1.name,
    type: "slot",
    source: `(63:0) <Hst.Story group=\\"ui\\" title=\\"Table\\" layout={{ type: 'grid', width: '100%' }}>`,
    ctx
  });
  return block;
}
function create_controls_slot(ctx) {
  let hst_checkbox;
  let updating_value;
  let current;
  function hst_checkbox_value_binding(value) {
    ctx[6](value);
  }
  let hst_checkbox_props = { title: "Highlight first column?" };
  if (ctx[1] !== void 0) {
    hst_checkbox_props.value = ctx[1];
  }
  hst_checkbox = new ctx[0].Checkbox({
    props: hst_checkbox_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(hst_checkbox, "value", hst_checkbox_value_binding, ctx[1]));
  const block = {
    c: function create() {
      create_component(hst_checkbox.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_checkbox.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_checkbox, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_checkbox_changes = {};
      if (!updating_value && dirty & 2) {
        updating_value = true;
        hst_checkbox_changes.value = ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      hst_checkbox.$set(hst_checkbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_checkbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_checkbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_checkbox, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_controls_slot.name,
    type: "slot",
    source: '(85:2) <svelte:fragment slot=\\"controls\\">',
    ctx
  });
  return block;
}
function create_fragment$1(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "ui",
      title: "Table",
      layout: { type: "grid", width: "100%" },
      $$slots: {
        controls: [create_controls_slot],
        default: [create_default_slot$1]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 130) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function r(min = 0, max = 20) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function instance$1($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table_story", slots, []);
  let { Hst } = $$props;
  let highlightFirstColumn = false;
  const data = [
    { year: 2008, a: r(), b: r(), c: r() },
    { year: 2009, a: r(), b: r(), c: r() },
    { year: 2010, a: r(), b: r(), c: r() },
    { year: 2011, a: r(), b: r(), c: r() },
    { year: 2012, a: r(), b: r(), c: r() },
    { year: 2013, a: r(), b: r(), c: r() },
    { year: 2014, a: r(), b: r(), c: r() },
    { year: 2015, a: r(), b: r(), c: r() }
  ];
  const columns = [
    { name: "Jahr", getValue: (d) => d.year },
    { name: "Kategorie A", getValue: (d) => d.a },
    { name: "Kategorie B", getValue: (d) => d.b },
    { name: "Kategorie C", getValue: (d) => d.c }
  ];
  const columnsWithClasses = [
    { name: "Jahr", getValue: (d) => d.year },
    {
      name: "Kategorie A",
      getValue: (d) => d.a,
      class: "align-right"
    },
    {
      name: "Kategorie B",
      getValue: (d) => d.b,
      class: "align-right"
    },
    {
      name: "Kategorie C",
      getValue: (d) => d.c,
      class: "align-right"
    }
  ];
  const columnsWithCustomClasses = [
    { name: "Jahr", getValue: (d) => d.year },
    {
      name: "Kategorie A",
      getValue: (d) => d.a,
      class: "cat-a"
    },
    {
      name: "Kategorie B",
      getValue: (d) => d.b,
      class: "cat-b"
    },
    {
      name: "Kategorie C",
      getValue: (d) => d.c,
      class: "cat-c"
    }
  ];
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Table_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Table_story> was created with unknown prop '${key}'`);
  });
  function hst_checkbox_value_binding(value) {
    highlightFirstColumn = value;
    $$invalidate(1, highlightFirstColumn);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    Table,
    highlightFirstColumn,
    r,
    data,
    columns,
    columnsWithClasses,
    columnsWithCustomClasses
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("highlightFirstColumn" in $$props2)
      $$invalidate(1, highlightFirstColumn = $$props2.highlightFirstColumn);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    highlightFirstColumn,
    data,
    columns,
    columnsWithClasses,
    columnsWithCustomClasses,
    hst_checkbox_value_binding
  ];
}
class Table_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table_story",
      options,
      id: create_fragment$1.name
    });
  }
  get Hst() {
    throw new Error("<Table_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Table_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Tabs_story_svelte_svelte_type_style_lang = "";
const file = "src/lib/components/shared/Tabs.story.svelte";
function create_default_slot_18(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s--pQoW_zgAn_6");
      add_location(div, file, 23, 6, 662);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_18.name,
    type: "slot",
    source: '(23:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_17(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding(value) {
    ctx[5](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[3]
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_18,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17.name,
    type: "slot",
    source: '(15:2) <Hst.Variant title=\\"Basic\\">',
    ctx
  });
  return block;
}
function create_default_slot_16(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s--pQoW_zgAn_6");
      add_location(div, file, 41, 6, 1069);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: '(36:4) <TabPanels       id=\\"my-unique-tabs-id\\"       {tabs}       activeIndex={activeIndexInitiallySelected}       let:tab     >',
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_1(value) {
    ctx[6](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[3]
  };
  if (ctx[2] !== void 0) {
    tabs_1_props.activeIndex = ctx[2];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_1, ctx[2]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[2],
      $$slots: {
        default: [
          create_default_slot_16,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 4) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[2];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 4)
        tabpanels_changes.activeIndex = ctx2[2];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: '(28:2) <Hst.Variant title=\\"Specify initially selected tab\\">',
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(active)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(active)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(56:6) {#if active}",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let t0_value = ctx[13] + "";
  let t0;
  let t1;
  let if_block_anchor;
  let if_block = ctx[14] && create_if_block(ctx);
  const block = {
    c: function create() {
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t0_value !== (t0_value = ctx2[13] + ""))
        set_data_dev(t0, t0_value);
      if (ctx2[14]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: '(47:4) <Tabs       id=\\"my-unique-tabs-id\\"       label=\\"Wähle einen Tab\\"       {tabs}       bind:activeIndex       let:tab       let:active     >',
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s--pQoW_zgAn_6");
      add_location(div, file, 61, 6, 1476);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: '(61:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_2(value) {
    ctx[7](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[3],
    $$slots: {
      default: [
        create_default_slot_14,
        ({ tab, active }) => ({ 13: tab, 14: active }),
        ({ tab, active }) => (tab ? 8192 : 0) | (active ? 16384 : 0)
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_2, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_13,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (dirty & 57344) {
        tabs_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: '(46:2) <Hst.Variant title=\\"Custom tab labels\\">',
    ctx
  });
  return block;
}
function create_default_slot_11(ctx) {
  let t_value = ctx[13].label + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t_value !== (t_value = ctx2[13].label + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_11.name,
    type: "slot",
    source: '(67:4) <Tabs       id=\\"my-unique-tabs-id\\"       label=\\"Wähle einen Tab\\"       tabs={complexTabs}       bind:activeIndex       let:tab     >',
    ctx
  });
  return block;
}
function create_default_slot_10(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13].label + "";
  let t1;
  let t2;
  let t3_value = ctx[13].data + "";
  let t3;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      t2 = text(" with data ");
      t3 = text(t3_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      t2 = claim_text(div_nodes, " with data ");
      t3 = claim_text(div_nodes, t3_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s--pQoW_zgAn_6");
      add_location(div, file, 77, 6, 1843);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, t2);
      append_hydration_dev(div, t3);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13].label + ""))
        set_data_dev(t1, t1_value);
      if (dirty & 8192 && t3_value !== (t3_value = ctx2[13].data + ""))
        set_data_dev(t3, t3_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_10.name,
    type: "slot",
    source: '(77:4) <TabPanels id=\\"my-unique-tabs-id\\" tabs={complexTabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_9(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_3(value) {
    ctx[8](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[4],
    $$slots: {
      default: [
        create_default_slot_11,
        ({ tab }) => ({ 13: tab }),
        ({ tab }) => tab ? 8192 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_3, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[4],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_10,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (dirty & 40960) {
        tabs_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9.name,
    type: "slot",
    source: '(66:2) <Hst.Variant title=\\"Complex tabs\\">',
    ctx
  });
  return block;
}
function create_default_slot_8(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s--pQoW_zgAn_6");
      add_location(div, file, 91, 6, 2217);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8.name,
    type: "slot",
    source: '(91:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_7(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_4(value) {
    ctx[9](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[3],
    isTabDisabled: func
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_4, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_8,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7.name,
    type: "slot",
    source: '(82:2) <Hst.Variant title=\\"Disabled tab\\">',
    ctx
  });
  return block;
}
function create_default_slot_6(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s--pQoW_zgAn_6");
      add_location(div, file, 105, 6, 2568);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: '(105:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_5(value) {
    ctx[10](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    class: "tabs-with-custom-accent-color",
    label: "Wähle einen Tab",
    tabs: ctx[3]
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_5, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_6,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: '(96:2) <Hst.Variant title=\\"Custom accent color\\">',
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s--pQoW_zgAn_6");
      add_location(div, file, 120, 6, 2979);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: '(120:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_6(value) {
    ctx[11](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    class: "tabs-with-custom-colors",
    label: "Wähle einen Tab",
    tabs: ctx[3],
    getTabClass: func_1
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_6, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_4,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: '(110:2) <Hst.Variant title=\\"Customize all colors\\">',
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let div;
  let t0;
  let t1_value = ctx[13] + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text("Panel for ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, "Panel for ");
      t1 = claim_text(div_nodes, t1_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "panel s--pQoW_zgAn_6");
      add_location(div, file, 134, 6, 3302);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8192 && t1_value !== (t1_value = ctx2[13] + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: '(134:4) <TabPanels id=\\"my-unique-tabs-id\\" {tabs} {activeIndex} let:tab>',
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let tabs_1;
  let updating_activeIndex;
  let t;
  let tabpanels;
  let current;
  function tabs_1_activeIndex_binding_7(value) {
    ctx[12](value);
  }
  let tabs_1_props = {
    id: "my-unique-tabs-id",
    label: "Wähle einen Tab",
    tabs: ctx[3],
    slants: false
  };
  if (ctx[1] !== void 0) {
    tabs_1_props.activeIndex = ctx[1];
  }
  tabs_1 = new Tabs({ props: tabs_1_props, $$inline: true });
  binding_callbacks.push(() => bind(tabs_1, "activeIndex", tabs_1_activeIndex_binding_7, ctx[1]));
  tabpanels = new TabPanels({
    props: {
      id: "my-unique-tabs-id",
      tabs: ctx[3],
      activeIndex: ctx[1],
      $$slots: {
        default: [
          create_default_slot_2,
          ({ tab }) => ({ 13: tab }),
          ({ tab }) => tab ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tabs_1.$$.fragment);
      t = space();
      create_component(tabpanels.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabs_1.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(tabpanels.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabs_1, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(tabpanels, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabs_1_changes = {};
      if (!updating_activeIndex && dirty & 2) {
        updating_activeIndex = true;
        tabs_1_changes.activeIndex = ctx2[1];
        add_flush_callback(() => updating_activeIndex = false);
      }
      tabs_1.$set(tabs_1_changes);
      const tabpanels_changes = {};
      if (dirty & 2)
        tabpanels_changes.activeIndex = ctx2[1];
      if (dirty & 40960) {
        tabpanels_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanels.$set(tabpanels_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabs_1.$$.fragment, local);
      transition_in(tabpanels.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabs_1.$$.fragment, local);
      transition_out(tabpanels.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tabs_1, detaching);
      if (detaching)
        detach_dev(t);
      destroy_component(tabpanels, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(125:2) <Hst.Variant title=\\"Without slants\\">',
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let hst_variant0;
  let t0;
  let hst_variant1;
  let t1;
  let hst_variant2;
  let t2;
  let hst_variant3;
  let t3;
  let hst_variant4;
  let t4;
  let hst_variant5;
  let t5;
  let hst_variant6;
  let t6;
  let hst_variant7;
  let current;
  hst_variant0 = new ctx[0].Variant({
    props: {
      title: "Basic",
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant1 = new ctx[0].Variant({
    props: {
      title: "Specify initially selected tab",
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant2 = new ctx[0].Variant({
    props: {
      title: "Custom tab labels",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant3 = new ctx[0].Variant({
    props: {
      title: "Complex tabs",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant4 = new ctx[0].Variant({
    props: {
      title: "Disabled tab",
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant5 = new ctx[0].Variant({
    props: {
      title: "Custom accent color",
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant6 = new ctx[0].Variant({
    props: {
      title: "Customize all colors",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  hst_variant7 = new ctx[0].Variant({
    props: {
      title: "Without slants",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_variant0.$$.fragment);
      t0 = space();
      create_component(hst_variant1.$$.fragment);
      t1 = space();
      create_component(hst_variant2.$$.fragment);
      t2 = space();
      create_component(hst_variant3.$$.fragment);
      t3 = space();
      create_component(hst_variant4.$$.fragment);
      t4 = space();
      create_component(hst_variant5.$$.fragment);
      t5 = space();
      create_component(hst_variant6.$$.fragment);
      t6 = space();
      create_component(hst_variant7.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_variant0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(hst_variant1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(hst_variant2.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(hst_variant3.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(hst_variant4.$$.fragment, nodes);
      t4 = claim_space(nodes);
      claim_component(hst_variant5.$$.fragment, nodes);
      t5 = claim_space(nodes);
      claim_component(hst_variant6.$$.fragment, nodes);
      t6 = claim_space(nodes);
      claim_component(hst_variant7.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_variant0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(hst_variant1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(hst_variant2, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      mount_component(hst_variant3, target, anchor);
      insert_hydration_dev(target, t3, anchor);
      mount_component(hst_variant4, target, anchor);
      insert_hydration_dev(target, t4, anchor);
      mount_component(hst_variant5, target, anchor);
      insert_hydration_dev(target, t5, anchor);
      mount_component(hst_variant6, target, anchor);
      insert_hydration_dev(target, t6, anchor);
      mount_component(hst_variant7, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hst_variant0_changes = {};
      if (dirty & 32770) {
        hst_variant0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant0.$set(hst_variant0_changes);
      const hst_variant1_changes = {};
      if (dirty & 32772) {
        hst_variant1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant1.$set(hst_variant1_changes);
      const hst_variant2_changes = {};
      if (dirty & 32770) {
        hst_variant2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant2.$set(hst_variant2_changes);
      const hst_variant3_changes = {};
      if (dirty & 32770) {
        hst_variant3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant3.$set(hst_variant3_changes);
      const hst_variant4_changes = {};
      if (dirty & 32770) {
        hst_variant4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant4.$set(hst_variant4_changes);
      const hst_variant5_changes = {};
      if (dirty & 32770) {
        hst_variant5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant5.$set(hst_variant5_changes);
      const hst_variant6_changes = {};
      if (dirty & 32770) {
        hst_variant6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant6.$set(hst_variant6_changes);
      const hst_variant7_changes = {};
      if (dirty & 32770) {
        hst_variant7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_variant7.$set(hst_variant7_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_variant0.$$.fragment, local);
      transition_in(hst_variant1.$$.fragment, local);
      transition_in(hst_variant2.$$.fragment, local);
      transition_in(hst_variant3.$$.fragment, local);
      transition_in(hst_variant4.$$.fragment, local);
      transition_in(hst_variant5.$$.fragment, local);
      transition_in(hst_variant6.$$.fragment, local);
      transition_in(hst_variant7.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_variant0.$$.fragment, local);
      transition_out(hst_variant1.$$.fragment, local);
      transition_out(hst_variant2.$$.fragment, local);
      transition_out(hst_variant3.$$.fragment, local);
      transition_out(hst_variant4.$$.fragment, local);
      transition_out(hst_variant5.$$.fragment, local);
      transition_out(hst_variant6.$$.fragment, local);
      transition_out(hst_variant7.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_variant0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(hst_variant1, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(hst_variant2, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(hst_variant3, detaching);
      if (detaching)
        detach_dev(t3);
      destroy_component(hst_variant4, detaching);
      if (detaching)
        detach_dev(t4);
      destroy_component(hst_variant5, detaching);
      if (detaching)
        detach_dev(t5);
      destroy_component(hst_variant6, detaching);
      if (detaching)
        detach_dev(t6);
      destroy_component(hst_variant7, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: `(14:0) <Hst.Story group=\\"ui\\" title=\\"Tabs\\" layout={{ type: 'grid', width: '100%' }}>`,
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let hst_story;
  let current;
  hst_story = new ctx[0].Story({
    props: {
      group: "ui",
      title: "Tabs",
      layout: { type: "grid", width: "100%" },
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hst_story.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hst_story.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hst_story, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hst_story_changes = {};
      if (dirty & 32774) {
        hst_story_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hst_story.$set(hst_story_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hst_story.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hst_story.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hst_story, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const func = (tab) => tab === "Tab 3";
const func_1 = (tab) => tab.toLowerCase().replace(" ", "-");
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tabs_story", slots, []);
  let { Hst } = $$props;
  const tabs = ["Tab 1", "Tab 2", "Tab 3"];
  const complexTabs = [
    { label: "Tab 1", data: [1, 2, 3] },
    { label: "Tab 2", data: [2, 3, 4] },
    { label: "Tab 3", data: [3, 4, 5] }
  ];
  let activeIndex;
  let activeIndexInitiallySelected = 1;
  $$self.$$.on_mount.push(function() {
    if (Hst === void 0 && !("Hst" in $$props || $$self.$$.bound[$$self.$$.props["Hst"]])) {
      console.warn("<Tabs_story> was created without expected prop 'Hst'");
    }
  });
  const writable_props = ["Hst"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tabs_story> was created with unknown prop '${key}'`);
  });
  function tabs_1_activeIndex_binding(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_1(value) {
    activeIndexInitiallySelected = value;
    $$invalidate(2, activeIndexInitiallySelected);
  }
  function tabs_1_activeIndex_binding_2(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_3(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_4(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_5(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_6(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  function tabs_1_activeIndex_binding_7(value) {
    activeIndex = value;
    $$invalidate(1, activeIndex);
  }
  $$self.$$set = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
  };
  $$self.$capture_state = () => ({
    Hst,
    Tabs,
    TabPanels,
    tabs,
    complexTabs,
    activeIndex,
    activeIndexInitiallySelected
  });
  $$self.$inject_state = ($$props2) => {
    if ("Hst" in $$props2)
      $$invalidate(0, Hst = $$props2.Hst);
    if ("activeIndex" in $$props2)
      $$invalidate(1, activeIndex = $$props2.activeIndex);
    if ("activeIndexInitiallySelected" in $$props2)
      $$invalidate(2, activeIndexInitiallySelected = $$props2.activeIndexInitiallySelected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    Hst,
    activeIndex,
    activeIndexInitiallySelected,
    tabs,
    complexTabs,
    tabs_1_activeIndex_binding,
    tabs_1_activeIndex_binding_1,
    tabs_1_activeIndex_binding_2,
    tabs_1_activeIndex_binding_3,
    tabs_1_activeIndex_binding_4,
    tabs_1_activeIndex_binding_5,
    tabs_1_activeIndex_binding_6,
    tabs_1_activeIndex_binding_7
  ];
}
class Tabs_story extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { Hst: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tabs_story",
      options,
      id: create_fragment.name
    });
  }
  get Hst() {
    throw new Error("<Tabs_story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Hst(value) {
    throw new Error("<Tabs_story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
const Comp32 = { "title": "Introduction", "icon": "carbon:document-blank", "group": "top", "docsOnly": true, "variants": [] };
let files = [
  { "id": "src-lib-components-layercake-areay-story-svelte", "path": ["AreaY"], "filePath": "src/lib/components/layercake/AreaY.story.svelte", "story": { "id": "src-lib-components-layercake-areay-story-svelte", "title": "AreaY", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-areay-story-svelte-0", "title": "Within chart", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-areay-story-svelte-1", "title": "Shape only", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 0, component: AreaY_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-areay-story-svelte-7efbbe18.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-areay0-story-svelte", "path": ["AreaY0"], "filePath": "src/lib/components/layercake/AreaY0.story.svelte", "story": { "id": "src-lib-components-layercake-areay0-story-svelte", "title": "AreaY0", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-areay0-story-svelte-0", "title": "Within chart", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-areay0-story-svelte-1", "title": "Shape only", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 1, component: AreaY0_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-areay0-story-svelte-0ce9883e.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-arrow-story-svelte", "path": ["Arrow"], "filePath": "src/lib/components/layercake/Arrow.story.svelte", "story": { "id": "src-lib-components-layercake-arrow-story-svelte", "title": "Arrow", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-arrow-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-arrow-story-svelte-1", "title": "Curve", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-arrow-story-svelte-2", "title": "Within chart", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 2, component: Arrow_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-arrow-story-svelte-26ed22d5.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-axislabelx-story-svelte", "path": ["AxisLabelX"], "filePath": "src/lib/components/layercake/AxisLabelX.story.svelte", "story": { "id": "src-lib-components-layercake-axislabelx-story-svelte", "title": "AxisLabelX", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "_default", "title": "default" }] }, "supportPluginId": "svelte3", "index": 3, component: AxisLabelX_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-axislabelx-story-svelte-f27dd0b3.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-axislabely-story-svelte", "path": ["AxisLabelY"], "filePath": "src/lib/components/layercake/AxisLabelY.story.svelte", "story": { "id": "src-lib-components-layercake-axislabely-story-svelte", "title": "AxisLabelY", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "_default", "title": "default" }] }, "supportPluginId": "svelte3", "index": 4, component: AxisLabelY_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-axislabely-story-svelte-f9ab2a1a.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-axisx-story-svelte", "path": ["AxisX"], "filePath": "src/lib/components/layercake/AxisX.story.svelte", "story": { "id": "src-lib-components-layercake-axisx-story-svelte", "title": "AxisX", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-axisx-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-axisx-story-svelte-1", "title": "On top", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 5, component: AxisX_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-axisx-story-svelte-101b8f6c.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-axisy-story-svelte", "path": ["AxisY"], "filePath": "src/lib/components/layercake/AxisY.story.svelte", "story": { "id": "src-lib-components-layercake-axisy-story-svelte", "title": "AxisY", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "_default", "title": "default" }] }, "supportPluginId": "svelte3", "index": 6, component: AxisY_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-axisy-story-svelte-e14ac09f.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-barh-story-svelte", "path": ["BarH"], "filePath": "src/lib/components/layercake/BarH.story.svelte", "story": { "id": "src-lib-components-layercake-barh-story-svelte", "title": "BarH", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-barh-story-svelte-0", "title": "Within chart", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-barh-story-svelte-1", "title": "With bar labels", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-barh-story-svelte-2", "title": "With bar labels at the end", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 7, component: BarH_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-barh-story-svelte-ebc8334f.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-barv-story-svelte", "path": ["BarV"], "filePath": "src/lib/components/layercake/BarV.story.svelte", "story": { "id": "src-lib-components-layercake-barv-story-svelte", "title": "BarV", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-barv-story-svelte-0", "title": "Within chart", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-barv-story-svelte-1", "title": "With bar labels", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-barv-story-svelte-2", "title": "With bar labels on top", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 8, component: BarV_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-barv-story-svelte-12f06cdc.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-circle-story-svelte", "path": ["Circle"], "filePath": "src/lib/components/layercake/Circle.story.svelte", "story": { "id": "src-lib-components-layercake-circle-story-svelte", "title": "Circle", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-circle-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-circle-story-svelte-1", "title": "Custom attributes", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-circle-story-svelte-2", "title": "Within chart", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 9, component: Circle_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-circle-story-svelte-07edbf3e.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-group-story-svelte", "path": ["Group"], "filePath": "src/lib/components/layercake/Group.story.svelte", "story": { "id": "src-lib-components-layercake-group-story-svelte", "title": "Group", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "_default", "title": "default" }] }, "supportPluginId": "svelte3", "index": 10, component: Group_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-group-story-svelte-8465ac88.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-htmltext-story-svelte", "path": ["HtmlText"], "filePath": "src/lib/components/layercake/HtmlText.story.svelte", "story": { "id": "src-lib-components-layercake-htmltext-story-svelte", "title": "HtmlText", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-htmltext-story-svelte-0", "title": "Within chart", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-htmltext-story-svelte-1", "title": "With custom attributes", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-htmltext-story-svelte-2", "title": "With custom offsets", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-htmltext-story-svelte-3", "title": "Align along x-axis", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-htmltext-story-svelte-4", "title": "Align on y-axis", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 11, component: HtmlText_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-htmltext-story-svelte-c5b12835.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-line-story-svelte", "path": ["Line"], "filePath": "src/lib/components/layercake/Line.story.svelte", "story": { "id": "src-lib-components-layercake-line-story-svelte", "title": "Line", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-line-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-line-story-svelte-1", "title": "Custom attributes", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-line-story-svelte-2", "title": "Within chart", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 12, component: Line_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-line-story-svelte-2a6a2030.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-lineh-story-svelte", "path": ["LineH"], "filePath": "src/lib/components/layercake/LineH.story.svelte", "story": { "id": "src-lib-components-layercake-lineh-story-svelte", "title": "LineH", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-lineh-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-lineh-story-svelte-1", "title": "Custom attributes", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-lineh-story-svelte-2", "title": "Within chart", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 13, component: LineH_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-lineh-story-svelte-74570fb6.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-linev-story-svelte", "path": ["LineV"], "filePath": "src/lib/components/layercake/LineV.story.svelte", "story": { "id": "src-lib-components-layercake-linev-story-svelte", "title": "LineV", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-linev-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-linev-story-svelte-1", "title": "Custom attributes", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-linev-story-svelte-2", "title": "Within chart", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 14, component: LineV_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-linev-story-svelte-94aa852c.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-path-story-svelte", "path": ["Path"], "filePath": "src/lib/components/layercake/Path.story.svelte", "story": { "id": "src-lib-components-layercake-path-story-svelte", "title": "Path", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-path-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-path-story-svelte-1", "title": "Custom attributes", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-path-story-svelte-2", "title": "Within chart", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 15, component: Path_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-path-story-svelte-db38142c.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-recth-story-svelte", "path": ["RectH"], "filePath": "src/lib/components/layercake/RectH.story.svelte", "story": { "id": "src-lib-components-layercake-recth-story-svelte", "title": "RectH", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-recth-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-recth-story-svelte-1", "title": "Custom attributes", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-recth-story-svelte-2", "title": "Within chart", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 16, component: RectH_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-recth-story-svelte-0d99fb8d.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-rectv-story-svelte", "path": ["RectV"], "filePath": "src/lib/components/layercake/RectV.story.svelte", "story": { "id": "src-lib-components-layercake-rectv-story-svelte", "title": "RectV", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-rectv-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-rectv-story-svelte-1", "title": "Custom attributes", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-rectv-story-svelte-2", "title": "Within chart", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 17, component: RectV_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-rectv-story-svelte-8e1c3ef5.js"), true ? [] : void 0) },
  { "id": "src-lib-components-layercake-svgtext-story-svelte", "path": ["SvgText"], "filePath": "src/lib/components/layercake/SvgText.story.svelte", "story": { "id": "src-lib-components-layercake-svgtext-story-svelte", "title": "SvgText", "group": "layercake", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-layercake-svgtext-story-svelte-0", "title": "Within chart", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-svgtext-story-svelte-1", "title": "With custom attributes", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-svgtext-story-svelte-2", "title": "With custom offsets", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-svgtext-story-svelte-3", "title": "Align along x-axis", "icon": null, "iconColor": null }, { "id": "src-lib-components-layercake-svgtext-story-svelte-4", "title": "Align on y-axis", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 18, component: SvgText_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-layercake-svgtext-story-svelte-3d5a67e4.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-button-story-svelte", "path": ["Button"], "filePath": "src/lib/components/shared/Button.story.svelte", "story": { "id": "src-lib-components-shared-button-story-svelte", "title": "Button", "group": "ui", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-button-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-button-story-svelte-1", "title": "Full width", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-button-story-svelte-2", "title": "Custom accent color", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-button-story-svelte-3", "title": "With icon", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-button-story-svelte-4", "title": "Round with icon", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-button-story-svelte-5", "title": "Icon and text", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 19, component: Button_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-button-story-svelte-24c3bae7.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-chartfooter-story-svelte", "path": ["ChartFooter"], "filePath": "src/lib/components/shared/ChartFooter.story.svelte", "story": { "id": "src-lib-components-shared-chartfooter-story-svelte", "title": "ChartFooter", "group": "viz", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "_default", "title": "default" }] }, "supportPluginId": "svelte3", "index": 20, component: ChartFooter_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-chartfooter-story-svelte-ea92a1b2.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-chartheader-story-svelte", "path": ["ChartHeader"], "filePath": "src/lib/components/shared/ChartHeader.story.svelte", "story": { "id": "src-lib-components-shared-chartheader-story-svelte", "title": "ChartHeader", "group": "viz", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-chartheader-story-svelte-0", "title": "Title", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-chartheader-story-svelte-1", "title": "With subtitle", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 21, component: ChartHeader_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-chartheader-story-svelte-c27b0f71.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-chartlegend-story-svelte", "path": ["ChartLegend"], "filePath": "src/lib/components/shared/ChartLegend.story.svelte", "story": { "id": "src-lib-components-shared-chartlegend-story-svelte", "title": "ChartLegend", "group": "viz", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-chartlegend-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-chartlegend-story-svelte-1", "title": "With complex items", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-chartlegend-story-svelte-2", "title": "With custom shapes", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 22, component: ChartLegend_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-chartlegend-story-svelte-6886e6b5.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-checkboxes-story-svelte", "path": ["CheckBoxes"], "filePath": "src/lib/components/shared/CheckBoxes.story.svelte", "story": { "id": "src-lib-components-shared-checkboxes-story-svelte", "title": "CheckBoxes", "group": "ui", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-checkboxes-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-checkboxes-story-svelte-1", "title": "Specify initially selected values", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-checkboxes-story-svelte-2", "title": "Custom option label", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-checkboxes-story-svelte-3", "title": "Disabled option", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-checkboxes-story-svelte-4", "title": "Complex options", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-checkboxes-story-svelte-5", "title": "Custom accent color", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-checkboxes-story-svelte-6", "title": "Hide label visually", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-checkboxes-story-svelte-7", "title": "Chips", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 23, component: CheckBoxes_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-checkboxes-story-svelte-02c33898.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-dropdown-story-svelte", "path": ["Dropdown"], "filePath": "src/lib/components/shared/Dropdown.story.svelte", "story": { "id": "src-lib-components-shared-dropdown-story-svelte", "title": "Dropdown", "group": "ui", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-dropdown-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-dropdown-story-svelte-1", "title": "Initially Open", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-dropdown-story-svelte-2", "title": "Specify initially selected value", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-dropdown-story-svelte-3", "title": "Complex options", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-dropdown-story-svelte-4", "title": "Disabled", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-dropdown-story-svelte-5", "title": "Hide clear button", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-dropdown-story-svelte-6", "title": "Hide label visually", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 24, component: Dropdown_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-dropdown-story-svelte-b767d8a2.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-radiobuttons-story-svelte", "path": ["RadioButtons"], "filePath": "src/lib/components/shared/RadioButtons.story.svelte", "story": { "id": "src-lib-components-shared-radiobuttons-story-svelte", "title": "RadioButtons", "group": "ui", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-radiobuttons-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-radiobuttons-story-svelte-1", "title": "Specify initially selected values", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-radiobuttons-story-svelte-2", "title": "Custom option label", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-radiobuttons-story-svelte-3", "title": "Disabled option", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-radiobuttons-story-svelte-4", "title": "Complex options", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-radiobuttons-story-svelte-5", "title": "Custom accent color", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-radiobuttons-story-svelte-6", "title": "Hide label visually", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 25, component: RadioButtons_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-radiobuttons-story-svelte-9196e3e0.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-search-story-svelte", "path": ["Search"], "filePath": "src/lib/components/shared/Search.story.svelte", "story": { "id": "src-lib-components-shared-search-story-svelte", "title": "Search", "group": "ui", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-search-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-search-story-svelte-1", "title": "Complex options", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-search-story-svelte-2", "title": "Fuzzy searching", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-search-story-svelte-3", "title": "Fuzzy searching complex options", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-search-story-svelte-4", "title": "Async loading", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-search-story-svelte-5", "title": "Hide label visually", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 26, component: Search_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-search-story-svelte-c81dd885.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-select-story-svelte", "path": ["Select"], "filePath": "src/lib/components/shared/Select.story.svelte", "story": { "id": "src-lib-components-shared-select-story-svelte", "title": "Select", "group": "ui", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-select-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-select-story-svelte-1", "title": "Specify initially selected value", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-select-story-svelte-2", "title": "Complex options", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-select-story-svelte-3", "title": "Disabled", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-select-story-svelte-4", "title": "Hide label visually", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 27, component: Select_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-select-story-svelte-dfd0f1ad.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-slant-story-svelte", "path": ["Slant"], "filePath": "src/lib/components/shared/Slant.story.svelte", "story": { "id": "src-lib-components-shared-slant-story-svelte", "title": "Slant", "group": "ui", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-slant-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-slant-story-svelte-1", "title": "With text", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-slant-story-svelte-2", "title": "With custom colors", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 28, component: Slant_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-slant-story-svelte-460cb209.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-tabpanels-story-svelte", "path": ["TabPanels"], "filePath": "src/lib/components/shared/TabPanels.story.svelte", "story": { "id": "src-lib-components-shared-tabpanels-story-svelte", "title": "TabPanels", "group": "ui", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-tabpanels-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabpanels-story-svelte-1", "title": "Specify initially selected tab", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabpanels-story-svelte-2", "title": "Custom tab labels", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabpanels-story-svelte-3", "title": "Complex tabs", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabpanels-story-svelte-4", "title": "Disabled tab", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabpanels-story-svelte-5", "title": "Custom accent color", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabpanels-story-svelte-6", "title": "Customize all colors", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabpanels-story-svelte-7", "title": "Without slants", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 29, component: TabPanels_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-tabpanels-story-svelte-b065f237.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-table-story-svelte", "path": ["Table"], "filePath": "src/lib/components/shared/Table.story.svelte", "story": { "id": "src-lib-components-shared-table-story-svelte", "title": "Table", "group": "ui", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-table-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-table-story-svelte-1", "title": "Right-aligned data columns", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-table-story-svelte-2", "title": "Customized columns", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 30, component: Table_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-table-story-svelte-d3f378a6.js"), true ? [] : void 0) },
  { "id": "src-lib-components-shared-tabs-story-svelte", "path": ["Tabs"], "filePath": "src/lib/components/shared/Tabs.story.svelte", "story": { "id": "src-lib-components-shared-tabs-story-svelte", "title": "Tabs", "group": "ui", "layout": { "type": "grid", "width": "100%" }, "icon": null, "iconColor": null, "docsOnly": false, "variants": [{ "id": "src-lib-components-shared-tabs-story-svelte-0", "title": "Basic", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabs-story-svelte-1", "title": "Specify initially selected tab", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabs-story-svelte-2", "title": "Custom tab labels", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabs-story-svelte-3", "title": "Complex tabs", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabs-story-svelte-4", "title": "Disabled tab", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabs-story-svelte-5", "title": "Custom accent color", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabs-story-svelte-6", "title": "Customize all colors", "icon": null, "iconColor": null }, { "id": "src-lib-components-shared-tabs-story-svelte-7", "title": "Without slants", "icon": null, "iconColor": null }] }, "supportPluginId": "svelte3", "index": 31, component: Tabs_story, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-shared-tabs-story-svelte-69595f37.js"), true ? [] : void 0) },
  { "id": "src-lib-components-introduction-story-js", "path": ["Introduction"], "filePath": "src/lib/components/Introduction.story.js", "story": { "id": "src-lib-components-introduction-story-js", "title": "Introduction", "group": "top", "layout": { "type": "single", "iframe": true }, "icon": "carbon:document-blank", "docsOnly": true, "variants": [] }, "supportPluginId": "vanilla", "index": 32, component: Comp32, source: () => __vitePreload(() => import("./__resolved__virtual_story-source_src-lib-components-introduction-story-js-9a92e9e8.js"), true ? [] : void 0) }
];
let tree = [{ "group": true, "id": "top", "title": "", "children": [{ "title": "Introduction", "index": 32 }] }, { "group": true, "id": "ui", "title": "User Interface", "children": [{ "title": "Button", "index": 19 }, { "title": "CheckBoxes", "index": 23 }, { "title": "Dropdown", "index": 24 }, { "title": "RadioButtons", "index": 25 }, { "title": "Search", "index": 26 }, { "title": "Select", "index": 27 }, { "title": "Slant", "index": 28 }, { "title": "Table", "index": 30 }, { "title": "TabPanels", "index": 29 }, { "title": "Tabs", "index": 31 }] }, { "group": true, "id": "viz", "title": "Visualization", "children": [{ "title": "ChartFooter", "index": 20 }, { "title": "ChartHeader", "index": 21 }, { "title": "ChartLegend", "index": 22 }] }, { "group": true, "id": "layercake", "title": "LayerCake", "children": [{ "title": "AreaY", "index": 0 }, { "title": "AreaY0", "index": 1 }, { "title": "Arrow", "index": 2 }, { "title": "AxisLabelX", "index": 3 }, { "title": "AxisLabelY", "index": 4 }, { "title": "AxisX", "index": 5 }, { "title": "AxisY", "index": 6 }, { "title": "BarH", "index": 7 }, { "title": "BarV", "index": 8 }, { "title": "Circle", "index": 9 }, { "title": "Group", "index": 10 }, { "title": "HtmlText", "index": 11 }, { "title": "Line", "index": 12 }, { "title": "LineH", "index": 13 }, { "title": "LineV", "index": 14 }, { "title": "Path", "index": 15 }, { "title": "RectH", "index": 16 }, { "title": "RectV", "index": 17 }, { "title": "SvgText", "index": 18 }] }];
const copiedFromExistingVariant = [
  "state",
  "slots",
  "source",
  "responsiveDisabled",
  "autoPropsDisabled",
  "setupApp",
  "configReady",
  "previewReady"
];
function mapFile(file2, existingFile) {
  let result;
  if (existingFile) {
    result = existingFile;
    for (const key in file2) {
      if (key === "story") {
        Object.assign(result.story, __spreadProps(__spreadValues({}, file2.story), {
          file: markRaw(result),
          variants: file2.story.variants.map((v) => mapVariant(v, existingFile.story.variants.find((item) => item.id === v.id)))
        }));
      } else if (key !== "component") {
        result[key] = file2[key];
      }
    }
  } else {
    result = __spreadProps(__spreadValues({}, file2), {
      component: markRaw(file2.component),
      story: __spreadProps(__spreadValues({}, file2.story), {
        title: file2.story.title,
        file: markRaw(file2),
        variants: file2.story.variants.map((v) => mapVariant(v)),
        slots: () => ({})
      })
    });
  }
  return result;
}
function mapVariant(variant, existingVariant) {
  let result;
  if (existingVariant) {
    result = existingVariant;
    for (const key in variant) {
      if (!copiedFromExistingVariant.includes(key)) {
        result[key] = variant[key];
      }
    }
  } else {
    result = __spreadProps(__spreadValues({}, variant), {
      state: reactive({
        _hPropState: {},
        _hPropDefs: {}
      }),
      setupApp: null,
      slots: () => ({}),
      previewReady: false
    });
  }
  return result;
}
const __default__ = {
  inheritAttrs: false
};
const _sfc_main = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__), {
  __name: "GenericMountStory",
  props: {
    story: null
  },
  setup(__props) {
    const props = __props;
    const mountComponent = ref(null);
    watchEffect(async () => {
      var _a;
      const clientPlugin = clientSupportPlugins[(_a = props.story.file) == null ? void 0 : _a.supportPluginId];
      if (clientPlugin) {
        const pluginModule = await clientPlugin();
        mountComponent.value = markRaw(pluginModule.MountStory);
      }
    });
    return (_ctx, _cache) => {
      return mountComponent.value ? (openBlock(), createBlock(resolveDynamicComponent(mountComponent.value), mergeProps({
        key: 0,
        class: "histoire-generic-mount-story",
        story: __props.story
      }, _ctx.$attrs), null, 16, ["story"])) : createCommentVNode("", true);
    };
  }
}));
export {
  _sfc_main as _,
  files as f,
  mapFile as m,
  tree as t
};
